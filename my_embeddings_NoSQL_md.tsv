chunk_key	doc_name	chunk_title	source	chunk	source_key	source_content	data_point
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000101	What is the purpose of the tutorial according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What is the purpose of the tutorial according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000102	What language does Cassandra use for querying data, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What language does Cassandra use for querying data, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000103	What type of queries can be performed using CQL, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What type of queries can be performed using CQL, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000104	Can you describe the example database used in the tutorial, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'Can you describe the example database used in the tutorial, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000105	What is the goal of the students who are supposed to work through this tutorial, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What is the goal of the students who are supposed to work through this tutorial, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000106	How does CQL compare to SQL, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'How does CQL compare to SQL, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000107	What is the focus of this tutorial, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What is the focus of this tutorial, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000108	Can you summarize the main points of the tutorial, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'Can you summarize the main points of the tutorial, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000109	What kind of data can be accessed and modified using CQL, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What kind of data can be accessed and modified using CQL, according to the paragraph?'  
C004400001	Cassandra 2_ Tutorial de CQL	Cassandra.  Tutorial de CQL	synthetic_question	Cassandra utiliza CQL (Cassandra Query Language) como lenguaje de consulta. CQL es un lenguaje declarativo muy parecido a SQL. Este documento pretende que los estudiantes se familiaricen con CQL y aprendan a acceder y modificar los datos alojados en Cassandra. Para ello, se propone realizar un conjunto de consultas de forma interactiva sobre una base de datos de ejemplo con información de	C00440000110	What is the advantage of using CQL over other query languages, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Cassandra.  Tutorial de CQL'; content: 'What is the advantage of using CQL over other query languages, according to the paragraph?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000201	Who is the author of the tutorial on Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'Who is the author of the tutorial on Cassandra?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000202	What is the title of the document being referred to in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'What is the title of the document being referred to in the paragraph?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000203	Can you identify the name of the person who revised the document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'Can you identify the name of the person who revised the document?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000204	In which year was the tutorial written?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'In which year was the tutorial written?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000205	What is the main topic discussed in the tutorial?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'What is the main topic discussed in the tutorial?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000206	Is Antonio Sarasa Cabezuelo one of the authors mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'Is Antonio Sarasa Cabezuelo one of the authors mentioned in the paragraph?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000207	How many authors are mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'How many authors are mentioned in the paragraph?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000208	What is the occupation of each author mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'What is the occupation of each author mentioned in the paragraph?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000209	Does the document have a reviser?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'Does the document have a reviser?'  
C004400002	Cassandra 2_ Tutorial de CQL	. Twitter.  Autores	synthetic_question	Antonio Sarasa Cabezuelo Joan Anton Pérez Braña Jordi Conesa i Caralt (revisor)	C00440000210	What is the name of the company or organization responsible for creating the document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. Twitter.  Autores'; content: 'What is the name of the company or organization responsible for creating the document?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000301	What is the main topic discussed in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'What is the main topic discussed in the paragraph?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000302	According to the paragraph, what type of database management system does Cassandra use?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'According to the paragraph, what type of database management system does Cassandra use?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000303	Can you identify the primary key in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'Can you identify the primary key in the paragraph?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000304	How does the author describe the data stored in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'How does the author describe the data stored in Cassandra?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000305	What is the purpose of an index in Cassandra, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'What is the purpose of an index in Cassandra, according to the paragraph?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000306	"The paragraph mentions something called ""secondary indexes."" What are they, and how do they differ from primary indexes?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'The paragraph mentions something called ""secondary indexes."" What are they, and how do they differ from primary indexes?'  "
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000307	Can you summarize the benefits of using secondary indexes in Cassandra, as stated in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'Can you summarize the benefits of using secondary indexes in Cassandra, as stated in the paragraph?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000308	What is the difference between a composite key and a simple key, as described in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'What is the difference between a composite key and a simple key, as described in the paragraph?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000309	How does the choice of data types affect the performance of queries in Cassandra, as mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'How does the choice of data types affect the performance of queries in Cassandra, as mentioned in the paragraph?'  
C004400003	Cassandra 2_ Tutorial de CQL	Índice	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440000310	What is the recommended approach for optimizing query performance in Cassandra, as suggested in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'Índice'; content: 'What is the recommended approach for optimizing query performance in Cassandra, as suggested in the paragraph?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000401	What is the recommended action before starting the examples presented in this document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What is the recommended action before starting the examples presented in this document?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000402	What type of environment should the student have completed before reading this document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What type of environment should the student have completed before reading this document?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000403	What is the name of the machine virtual Linux Mint provided in the document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What is the name of the machine virtual Linux Mint provided in the document?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000404	How many documents should the student have read before starting the examples in this document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'How many documents should the student have read before starting the examples in this document?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000405	What is the title of the second document mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What is the title of the second document mentioned in the paragraph?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000406	In which language is the second document written?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'In which language is the second document written?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000407	What is the main topic of the second document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What is the main topic of the second document?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000408	Can the student start the examples in this document without completing the tasks mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'Can the student start the examples in this document without completing the tasks mentioned in the paragraph?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000409	What is the purpose of the tasks mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What is the purpose of the tasks mentioned in the paragraph?'  
C004400004	Cassandra 2_ Tutorial de CQL	pág 2.  Requisitos previos	synthetic_question	Se recomienda que, previamente a la puesta en práctica de los ejemplos expuestos en el presente documento, el alumno haya completado las siguientes tareas: Lectura del documento “Máquina virtual Linux Mint (Manual)” ● Instalación y arranque de la Máquina virtual Linux Mint suministrada. ● Lectura del documento de “Cassandra: entorno de desarrollo e introducción” Bases de datos NoSQL Cassandra: tutorial	C00440000410	What is the name of the present document?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 2.  Requisitos previos'; content: 'What is the name of the present document?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000501	What is the purpose of creating a database in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'What is the purpose of creating a database in Cassandra?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000502	What is the default value for the replication strategy in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'What is the default value for the replication strategy in Cassandra?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000503	How many replicas are created for each row in Cassandra with a replication factor of 1?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'How many replicas are created for each row in Cassandra with a replication factor of 1?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000504	"What is the meaning of ""Replication placement strategy"" in Cassandra?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'What is the meaning of ""Replication placement strategy"" in Cassandra?'  "
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000505	In which node does the first replica of a row reside in Cassandra with a simple strategy?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'In which node does the first replica of a row reside in Cassandra with a simple strategy?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000506	How do nodes manage replicas according to the replication strategy in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'How do nodes manage replicas according to the replication strategy in Cassandra?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000507	Can we have multiple replication strategies in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'Can we have multiple replication strategies in Cassandra?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000508	Is it possible to create a key space without specifying a replication strategy in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'Is it possible to create a key space without specifying a replication strategy in Cassandra?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000509	What happens if there is no replication factor specified for a key space in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'What happens if there is no replication factor specified for a key space in Cassandra?'  
C004400005	Cassandra 2_ Tutorial de CQL	pág 3.  Creación de una base de datos	synthetic_question	Al crear la base de datos (o definen la estratégica de replicación de la base de datos. En particular: ) se deben establecer valores para los atributos que keyspace : este atributo permite indicar la manera en que se ● Replica placement strategy deben gestionar las réplicas. Para el tutorial utilizaremos el valor , SimpleStrategy que aloja la primera réplica en el nodo indicado y las siguientes en los nodos colindantes del anillo siguiendo las agujas del reloj. : ● Replication factor indica el número de réplicas para cada fila. En el tutorial trabajaremos con un valor de replicación de 1, es decir, sin réplicas. CREATE KEYSPACE tweetssandra WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : '1' }; Podemos consultar que el KEYSPACE	C00440000510	How can we consult the creation of a key space in Cassandra using the CQL command?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 3.  Creación de una base de datos'; content: 'How can we consult the creation of a key space in Cassandra using the CQL command?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000601	What is the purpose of the DESCRIBE KEYSPACES statement in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'What is the purpose of the DESCRIBE KEYSPACES statement in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000602	How do we retrieve information about schema keyspaces in Cassandra using the SELECT statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'How do we retrieve information about schema keyspaces in Cassandra using the SELECT statement?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000603	What is the significance of the system.schema_keyspaces table in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'What is the significance of the system.schema_keyspaces table in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000604	Can we use the DELETE statement to drop a keyspace in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'Can we use the DELETE statement to drop a keyspace in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000605	Is there a way to list all the tables present in a particular keyspace in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'Is there a way to list all the tables present in a particular keyspace in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000606	How does one create a new column family in an existing keyspace in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'How does one create a new column family in an existing keyspace in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000607	What is the difference between a regular column family and a supercolumn family in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'What is the difference between a regular column family and a supercolumn family in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000608	Can we perform secondary indexing on a column family in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'Can we perform secondary indexing on a column family in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000609	How do we manage compactions in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'How do we manage compactions in Cassandra?'  
C004400006	Cassandra 2_ Tutorial de CQL	se ha creado correctamente: tweetssandra	synthetic_question	DESCRIBE KEYSPACES; SELECT * FROM system.schema_keyspaces; Indicamos que queremos usar la base de datos	C00440000610	What is the optimal way to backup and restore data in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'se ha creado correctamente: tweetssandra'; content: 'What is the optimal way to backup and restore data in Cassandra?'  
C004400007	Cassandra 2_ Tutorial de CQL	: tweetssandra	synthetic_question	USE tweetssandra; Comprobamos que la base de datos está vacía: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440000701	What is the purpose of the `DESCRIBE TABLES` command in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweetssandra'; content: 'What is the purpose of the `DESCRIBE TABLES` command in Cassandra?'  
C004400007	Cassandra 2_ Tutorial de CQL	: tweetssandra	synthetic_question	USE tweetssandra; Comprobamos que la base de datos está vacía: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440000702	According to the paragraph, what is the current state of the database before running any queries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweetssandra'; content: 'According to the paragraph, what is the current state of the database before running any queries?'  
C004400007	Cassandra 2_ Tutorial de CQL	: tweetssandra	synthetic_question	USE tweetssandra; Comprobamos que la base de datos está vacía: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440000703	What is the name of the tutorial being discussed in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweetssandra'; content: 'What is the name of the tutorial being discussed in the paragraph?'  
C004400007	Cassandra 2_ Tutorial de CQL	: tweetssandra	synthetic_question	USE tweetssandra; Comprobamos que la base de datos está vacía: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440000704	In which language is the tutorial written?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweetssandra'; content: 'In which language is the tutorial written?'  
C004400007	Cassandra 2_ Tutorial de CQL	: tweetssandra	synthetic_question	USE tweetssandra; Comprobamos que la base de datos está vacía: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440000705	What is the main topic of the tutorial, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweetssandra'; content: 'What is the main topic of the tutorial, according to the paragraph?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000801	What is the purpose of the command described in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'What is the purpose of the command described in the paragraph?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000802	What is the name of the keyspace being dropped?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'What is the name of the keyspace being dropped?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000803	What type of database is being referred to in the paragraph (NoSQL or relational)?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'What type of database is being referred to in the paragraph (NoSQL or relational)?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000804	Can this command be executed without dropping the entire keyspace?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'Can this command be executed without dropping the entire keyspace?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000805	What is the significance of the semicolon at the end of the command?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'What is the significance of the semicolon at the end of the command?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000806	How does the Drop statement differ from the Truncate statement in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'How does the Drop statement differ from the Truncate statement in Cassandra?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000807	Is it possible to drop a column family within a keyspace using this command?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'Is it possible to drop a column family within a keyspace using this command?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000808	Can this command be used to drop all databases in a cluster?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'Can this command be used to drop all databases in a cluster?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000809	Are there any best practices or considerations when executing this command in a production environment?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'Are there any best practices or considerations when executing this command in a production environment?'  
C004400008	Cassandra 2_ Tutorial de CQL	pág 4.  Eliminación de una base de datos	synthetic_question	Para eliminar la base de datos podemos ejecutar el siguiente comando: DROP KEYSPACE tweetssandra; Bases de datos NoSQL Cassandra: tutorial	C00440000810	What happens if the specified keyspace does not exist before attempting to drop it?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 4.  Eliminación de una base de datos'; content: 'What happens if the specified keyspace does not exist before attempting to drop it?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000901	What is the purpose of creating families of columns in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'What is the purpose of creating families of columns in Cassandra?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000902	How many tables does the example database have, according to the given paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'How many tables does the example database have, according to the given paragraph?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000903	What is the primary key for the users table in the example database?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'What is the primary key for the users table in the example database?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000904	How many columns are there in the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'How many columns are there in the users table?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000905	What type of data is stored in the password column of the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'What type of data is stored in the password column of the users table?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000906	According to the paragraph, what is the default partition key for the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'According to the paragraph, what is the default partition key for the users table?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000907	Can you describe the structure of the followers table in the example database?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'Can you describe the structure of the followers table in the example database?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000908	How many columns are there in the followers table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'How many columns are there in the followers table?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000909	What type of data is stored in the screen_name column of the followers table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'What type of data is stored in the screen_name column of the followers table?'  
C004400009	Cassandra 2_ Tutorial de CQL	pág 5.  Familias de columnas	synthetic_question	Crear familias de columnas Para ejemplificar el uso de Cassandra vamos a crear una base de datos que contenga información de Twitter. Para simplificar el ejemplo, supondremos que estamos interesados en almacenar información sobre usuarios de Twitter y, para cada usuario, sus seguidores, los tweets realizados y el número de veces que ha sido retweeteado. Lo primero que haremos será crear una tabla (o familia de columnas) de usuarios para almacenar los datos de los usuarios de Twitter. La clave primaria de la tabla será el nombre ( ) de usuario. Por defecto la clave primaria se utilizará en Cassandra como login clave de partición, es decir, para identificar en qué partición deberá almacenarse cada registro. CREATE TABLE users ( username text PRIMARY KEY, password text ); A continuación definimos una tabla para indicar los seguidores. Definiremos la siguiente estructura donde, para cada usuario (	C00440000910	Based on the given paragraph, how would you define the relationship between the users and followers tables?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 5.  Familias de columnas'; content: 'Based on the given paragraph, how would you define the relationship between the users and followers tables?'  
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001001	"What is the purpose of creating a table called ""followers"" in the given tutorial?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'What is the purpose of creating a table called ""followers"" in the given tutorial?'  "
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001002	According to the tutorial, what is the default behavior of Cassandra when it comes to partitioning and grouping data?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'According to the tutorial, what is the default behavior of Cassandra when it comes to partitioning and grouping data?'  
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001003	"Can you identify the primary key of the ""followers"" table based on the given content?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'Can you identify the primary key of the ""followers"" table based on the given content?'  "
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001004	"How does the ""since"" timestamp field contribute to the overall structure of the ""followers"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'How does the ""since"" timestamp field contribute to the overall structure of the ""followers"" table?'  "
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001005	"In the context of this tutorial, what is the significance of the ""username"" and ""follower"" fields in the ""followers"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'In the context of this tutorial, what is the significance of the ""username"" and ""follower"" fields in the ""followers"" table?'  "
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001006	"What is the difference between a ""clause composta"" and a ""particion""?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'What is the difference between a ""clause composta"" and a ""particion""?'  "
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001007	Why might a user have more than one follower according to the given content?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'Why might a user have more than one follower according to the given content?'  
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001008	"How does the ""since"" timestamp field affect the organization of data within each partition of the ""followers"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'How does the ""since"" timestamp field affect the organization of data within each partition of the ""followers"" table?'  "
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001009	Based on the given content, what is the main focus of the tutorial - Cassandra or CQL?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'Based on the given content, what is the main focus of the tutorial - Cassandra or CQL?'  
C004400010	Cassandra 2_ Tutorial de CQL	), se indican sus seguidores ( username.  ). follower	synthetic_question	CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower) ); Podemos observar que la tabla follower tiene una clave compuesta, ya que un usuario tendrá, en el caso general, más de un seguidor. Una clave compuesta en Cassandra está formada por una clave de partición y una clave de agrupación. Por defecto, el primer campo de una clave primaria se utilizará como clave de partición y el resto como clave de agrupación. La clave de partición se utiliza para ubicar la partición donde se almacenará el registro y la clave de agrupación indica cómo se ordenarán los datos en disco dentro de cada partición. Bases de datos NoSQL Cassandra: tutorial	C00440001010	What is the title of the given document according to the provided content?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '), se indican sus seguidores ( username.  ). follower'; content: 'What is the title of the given document according to the provided content?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001101	What is the default ordering mechanism for values in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'What is the default ordering mechanism for values in Cassandra?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001102	How can we specify explicit sorting for values in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'How can we specify explicit sorting for values in Cassandra?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001103	What is an example use case where we might want to sort values in Cassandra descendingly?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'What is an example use case where we might want to sort values in Cassandra descendingly?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001104	In which column would we need to specify the clustering order by clause to achieve descending sorting in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'In which column would we need to specify the clustering order by clause to achieve descending sorting in Cassandra?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001105	Can we create a table in Cassandra with multiple columns and specify different clustering orders for each column?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'Can we create a table in Cassandra with multiple columns and specify different clustering orders for each column?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001106	Is there a limit to the number of columns we can specify in a single table with different clustering orders in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'Is there a limit to the number of columns we can specify in a single table with different clustering orders in Cassandra?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001107	How does the WITH CLUSTERING ORDER BY clause affect the performance of queries in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'How does the WITH CLUSTERING ORDER BY clause affect the performance of queries in Cassandra?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001108	Are there any best practices or considerations we should keep in mind when using the WITH CLUSTERING ORDER BY clause in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'Are there any best practices or considerations we should keep in mind when using the WITH CLUSTERING ORDER BY clause in Cassandra?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001109	Can we use the WITH CLUSTERING ORDER BY clause in conjunction with other indexing strategies in Cassandra, such as composite indexes?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'Can we use the WITH CLUSTERING ORDER BY clause in conjunction with other indexing strategies in Cassandra, such as composite indexes?'  
C004400011	Cassandra 2_ Tutorial de CQL	pág 6	synthetic_question	Por defecto los valores se ordenan de forma ascendente por el valor de la clave de agrupamiento. Sin embargo, si por ejemplo se quisiera que todos los seguidores de un mismo usuario estuvieran almacenados juntos y ordenados de acuerdo con el nombre del seguidor de manera descendente se usaría la cláusula WITH CLUSTERING ORDER BY. Mediante esta clàusula se puede indicar explícitamente que los valores se almacenen ordenados de manera descendente como en el siguiente ejemplo: CREATE TABLE followers ( username text, follower text, since timestamp, PRIMARY KEY (username, follower)) WITH CLUSTERING ORDER BY (follower DESC ) Posteriormente podríamos crear una tabla para almacenar los	C00440001110	How does the choice of clustering order impact the scalability and availability of our Cassandra application?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 6'; content: 'How does the choice of clustering order impact the scalability and availability of our Cassandra application?'  
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001201	What is the purpose of creating a table for storing tweets?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'What is the purpose of creating a table for storing tweets?'  
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001202	"What is the primary key of the ""tweets"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'What is the primary key of the ""tweets"" table?'  "
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001203	"How does the ""timeline"" table differ from the ""tweets"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'How does the ""timeline"" table differ from the ""tweets"" table?'  "
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001204	Can multiple columns be used as the partition key in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'Can multiple columns be used as the partition key in Cassandra?'  
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001205	"What is an example of a possible design for the ""timeline"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'What is an example of a possible design for the ""timeline"" table?'  "
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001206	"How can the ""author"" column in the ""tweets"" table be defined?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'How can the ""author"" column in the ""tweets"" table be defined?'  "
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001207	Is it possible to have more than one clustering column in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'Is it possible to have more than one clustering column in Cassandra?'  
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001208	What is the difference between a clustering column and a partition key in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'What is the difference between a clustering column and a partition key in Cassandra?'  
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001209	"Can the ""body"" column in the ""tweets"" table contain empty values?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'Can the ""body"" column in the ""tweets"" table contain empty values?'  "
C004400012	Cassandra 2_ Tutorial de CQL	: tweets	synthetic_question	CREATE TABLE tweets ( tweet_id uuid PRIMARY KEY, username text, body text ); Un posible diseño de la tabla que permite almacenar el siguiente: timeline de Twitter podría ser el CREATE TABLE timeline ( user_id text, tweet_id uuid, author text, body text, PRIMARY KEY (user_id, tweet_id) ); Tanto la clave de partición como la clave de agrupamiento puede estar formada por más de una columna. Para representarlo, si hubiera más de una clave de partición se encierran entre paréntesis y separadas por comas, y si hubiera más de un clave agrupamiento, simplemente se listan separadas por comas. Por ejemplo, considerar el siguiente ejemplo: PRIMARY date-tweet) KEY ((username, id-tweet), location-tweet,	C00440001210	"How can the ""location"" column in the ""tweets"" table be defined if it is not a numerical value?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: ': tweets'; content: 'How can the ""location"" column in the ""tweets"" table be defined if it is not a numerical value?'  "
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001301	What is the primary key of the table in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'What is the primary key of the table in the example?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001302	What are the partition keys in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'What are the partition keys in the example?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001303	What are the clustering columns in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'What are the clustering columns in the example?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001304	How many tables are used in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'How many tables are used in the example?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001305	What is the purpose of using composite keys in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'What is the purpose of using composite keys in the example?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001306	Can you describe the relationship between the tables in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'Can you describe the relationship between the tables in the example?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001307	What is the difference between a partition key and a clustering column?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'What is the difference between a partition key and a clustering column?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001308	How does Cassandra use the partition keys and clustering columns to organize data?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'How does Cassandra use the partition keys and clustering columns to organize data?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001309	What is the significance of using NoSQL databases like Cassandra for big data applications?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'What is the significance of using NoSQL databases like Cassandra for big data applications?'  
C004400013	Cassandra 2_ Tutorial de CQL	En el ejemplo mientras que	synthetic_question	, username ) constituyen las claves de partición de la clave primaria id-tweet constituyen las claves de agrupamiento. date-tweet y location-tweet Bases de datos NoSQL Cassandra: tutorial	C00440001310	Can you explain how Cassandra's architecture supports handling large amounts of distributed data?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'En el ejemplo mientras que'; content: 'Can you explain how Cassandra's architecture supports handling large amounts of distributed data?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001401	What is the main topic discussed in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'What is the main topic discussed in the paragraph?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001402	According to the paragraph, what is Cassandra's data model?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'According to the paragraph, what is Cassandra's data model?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001403	How does Cassandra differ from traditional relational databases?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'How does Cassandra differ from traditional relational databases?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001404	"What is the purpose of the ""Bases de datos NoSQL Cassandra"" section in the tutorial?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'What is the purpose of the ""Bases de datos NoSQL Cassandra"" section in the tutorial?'  "
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001405	In which year was Cassandra first released?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'In which year was Cassandra first released?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001406	Who developed Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'Who developed Cassandra?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001407	What is the difference between a column family and a table in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'What is the difference between a column family and a table in Cassandra?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001408	Can you describe the process of creating a new column family in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'Can you describe the process of creating a new column family in Cassandra?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001409	How do you insert data into a column family in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'How do you insert data into a column family in Cassandra?'  
C004400014	Cassandra 2_ Tutorial de CQL	pág 7	synthetic_question	Bases de datos NoSQL Cassandra: tutorial	C00440001410	What is the advantage of using Cassandra over a traditional relational database, according to the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 7'; content: 'What is the advantage of using Cassandra over a traditional relational database, according to the paragraph?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001501	What is the purpose of dropping tables in Cassandra, according to the given paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'What is the purpose of dropping tables in Cassandra, according to the given paragraph?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001502	How do we eliminate families of columns in Cassandra, as mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'How do we eliminate families of columns in Cassandra, as mentioned in the paragraph?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001503	What command do we use to drop all tables in a database in Cassandra, as stated in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'What command do we use to drop all tables in a database in Cassandra, as stated in the paragraph?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001504	What is the result of running the DESCRIBE TABLES command after dropping all tables, as described in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'What is the result of running the DESCRIBE TABLES command after dropping all tables, as described in the paragraph?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001505	What is the name of the tutorial being discussed in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'What is the name of the tutorial being discussed in the paragraph?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001506	What is the page number where the paragraph appears in the tutorial, as specified in the paragraph name?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'What is the page number where the paragraph appears in the tutorial, as specified in the paragraph name?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001507	What is the main topic of the paragraph, as inferred from the content?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'What is the main topic of the paragraph, as inferred from the content?'  
C004400015	Cassandra 2_ Tutorial de CQL	pág 8	synthetic_question	Eliminar familias de columnas Para eliminar eliminamos todas las tablas de la base de datos: tablas podemos utilizar la sentencia DROP TABLE. A Continuación DESCRIBE TABLES; DROP TABLE users; DROP TABLE tweets; DROP TABLE followers; DROP TABLE user_retweeted_counts; Comprobamos que no queda ninguna tabla mediante: DESCRIBE TABLES; Bases de datos NoSQL Cassandra: tutorial	C00440001508	Can we conclude from the paragraph that Cassandra supports dropped tables, based on the description of dropping tables?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 8'; content: 'Can we conclude from the paragraph that Cassandra supports dropped tables, based on the description of dropping tables?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001601	What is the purpose of adding a new column to the table users?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'What is the purpose of adding a new column to the table users?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001602	What is the name of the new column added to the table users?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'What is the name of the new column added to the table users?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001603	Who is the first user to have their data inserted into the table users using the INSERT statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'Who is the first user to have their data inserted into the table users using the INSERT statement?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001604	When was the last time Conchita followed Federacion Nacional de Cafeteros according to the followers table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'When was the last time Conchita followed Federacion Nacional de Cafeteros according to the followers table?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001605	How many rows were inserted into the followers table using the INSERT statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'How many rows were inserted into the followers table using the INSERT statement?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001606	What is the value of the name column for Juan Valdez in the users table after running the UPDATE statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'What is the value of the name column for Juan Valdez in the users table after running the UPDATE statement?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001607	Which statement is used to modify the families of columns in the table users?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'Which statement is used to modify the families of columns in the table users?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001608	What is the name of the database management system being used in the tutorial?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'What is the name of the database management system being used in the tutorial?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001609	In which year did Conchita start following Federacion Nacional de Cafeteros according to the followers table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'In which year did Conchita start following Federacion Nacional de Cafeteros according to the followers table?'  
C004400016	Cassandra 2_ Tutorial de CQL	pág 9	synthetic_question	Modificar familias de columnas Supongamos que descubrimos que nos hemos olvidado de la columna en la tabla users . Podemos añadirla mediante la sentencia ALTER TABLE y luego insertar sus datos mediante sentencias de INSERT y UPDATE, como se ve a continuación. ALTER TABLE users ADD name text; UPDATE users SET name = 'Juan Valdez' WHERE username='jvaldez'; INSERT INTO users (username, password, name) VALUES ('FNC', 'federacion', 'Federación Nacional de Cafeteros'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'FNC', '2013-01-28 15:30'); INSERT INTO followers (username, follower, since) VALUES ('conchita', 'FNC', '2013-01-28 15:30'); Bases de datos NoSQL Cassandra: tutorial	C00440001610	How many columns does the table users have before modifying it using the ALTER TABLE statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 9'; content: 'How many columns does the table users have before modifying it using the ALTER TABLE statement?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001701	What is the purpose of the INSERT statement in CQL?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'What is the purpose of the INSERT statement in CQL?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001702	How do we create a new user in Cassandra using CQL?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'How do we create a new user in Cassandra using CQL?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001703	What is the difference between the username and password columns in the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'What is the difference between the username and password columns in the users table?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001704	Who is the follower of whom in the example given in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'Who is the follower of whom in the example given in the paragraph?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001705	When was the last time Conchita followed JValdez according to the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'When was the last time Conchita followed JValdez according to the example?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001706	What is the value of the since column for the row where the follower is JValdez and the followed is Conchita?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'What is the value of the since column for the row where the follower is JValdez and the followed is Conchita?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001707	What is the body of the first tweet inserted into the tweets table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'What is the body of the first tweet inserted into the tweets table?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001708	Who posted the second tweet according to the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'Who posted the second tweet according to the example?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001709	What is the value of the tweet_id column for the second tweet?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'What is the value of the tweet_id column for the second tweet?'  
C004400017	Cassandra 2_ Tutorial de CQL	pág 10.  Inserción de datos	synthetic_question	Para insertar datos se puede utilizar la sentencia INSERT, parecido a como hacemos con SQL. Para ejemplificarlo creamos un par de usuarios, e indicamos que uno es seguidor del otro y creamos un par de tweets: INSERT INTO users (username, password) VALUES ('jvaldez', 'cafe'); INSERT INTO users (username, password) VALUES ('conchita', 'colombia'); INSERT INTO followers (username, follower, since) VALUES ('jvaldez', 'conchita', '2013-01-28 15:30'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789ab, 'jvaldez', 'El sabor de un buen café'); INSERT INTO tweets(tweet_id, username, body) VALUES (01234567-0123-0123-0123-0123456789bc, 'conchita', 'El mejor café del mundo'); Bases de datos NoSQL Cassandra: tutorial	C00440001710	What is the topic of the second tweet according to the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 10.  Inserción de datos'; content: 'What is the topic of the second tweet according to the example?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001801	What is the purpose of the DELETE statement in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'What is the purpose of the DELETE statement in Cassandra?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001802	How do we eliminate data using the DELETE statement in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'How do we eliminate data using the DELETE statement in Cassandra?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001803	What is the syntax for deleting a user in Cassandra using the DELETE statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'What is the syntax for deleting a user in Cassandra using the DELETE statement?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001804	Can we delete fields from a row in Cassandra using the DELETE statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'Can we delete fields from a row in Cassandra using the DELETE statement?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001805	What is an example of deleting a field from a row in Cassandra using the DELETE statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'What is an example of deleting a field from a row in Cassandra using the DELETE statement?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001806	Is it possible to delete multiple rows at once using the DELETE statement in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'Is it possible to delete multiple rows at once using the DELETE statement in Cassandra?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001807	How does the DELETE statement handle conflicts when trying to delete a row that has been modified by another user simultaneously?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'How does the DELETE statement handle conflicts when trying to delete a row that has been modified by another user simultaneously?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001808	What happens if we try to delete a non-existent row in Cassandra using the DELETE statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'What happens if we try to delete a non-existent row in Cassandra using the DELETE statement?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001809	Can we use the DELETE statement to delete data from a specific column only in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'Can we use the DELETE statement to delete data from a specific column only in Cassandra?'  
C004400018	Cassandra 2_ Tutorial de CQL	pág 11.  Eliminación de datos	synthetic_question	Se pueden eliminar datos mediante la consulta DELETE. A continuación eliminamos el usuario DELETE FROM users WHERE username='FNC'; También podemos eliminar campos de una fila, como por ejemplo los lugares ( donde ha vivido la usuario con nombre	C00440001810	Are there any performance considerations or best practices to keep in mind when using the DELETE statement in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 11.  Eliminación de datos'; content: 'Are there any performance considerations or best practices to keep in mind when using the DELETE statement in Cassandra?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001901	What is the purpose of the DELETE statement in the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'What is the purpose of the DELETE statement in the given SQL query?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001902	Which table does the DELETE statement target in the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'Which table does the DELETE statement target in the given SQL query?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001903	What is the condition specified in the WHERE clause of the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'What is the condition specified in the WHERE clause of the given SQL query?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001904	What is the value of the username parameter in the WHERE clause of the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'What is the value of the username parameter in the WHERE clause of the given SQL query?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001905	In which database management system (DBMS) is the given SQL query written?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'In which database management system (DBMS) is the given SQL query written?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001906	What type of data storage does the DBMS support, as suggested by the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'What type of data storage does the DBMS support, as suggested by the given SQL query?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001907	Can the given SQL query be executed in a distributed database environment, such as a cloud-based solution?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'Can the given SQL query be executed in a distributed database environment, such as a cloud-based solution?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001908	How many columns does the DELETE statement affect in the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'How many columns does the DELETE statement affect in the given SQL query?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001909	Does the given SQL query include any aggregate functions or subqueries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'Does the given SQL query include any aggregate functions or subqueries?'  
C004400019	Cassandra 2_ Tutorial de CQL	. conchita	synthetic_question	DELETE lived_in FROM users WHERE username='conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440001910	Can the given SQL query be used to delete multiple rows at once, or is it designed to delete only one row at a time?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '. conchita'; content: 'Can the given SQL query be used to delete multiple rows at once, or is it designed to delete only one row at a time?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002001	What is the purpose of queries in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'What is the purpose of queries in Cassandra?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002002	How do queries in Cassandra differ from SQL?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'How do queries in Cassandra differ from SQL?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002003	What is an example of a query that could be used to retrieve all users in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'What is an example of a query that could be used to retrieve all users in Cassandra?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002004	Can you execute a query to retrieve only the followers of a specific user in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'Can you execute a query to retrieve only the followers of a specific user in Cassandra?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002005	What is the syntax for executing a query in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'What is the syntax for executing a query in Cassandra?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002006	How does Cassandra handle null values in queries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'How does Cassandra handle null values in queries?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002007	Can you use wildcards in Cassandra queries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'Can you use wildcards in Cassandra queries?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002008	Are aggregation functions available in Cassandra queries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'Are aggregation functions available in Cassandra queries?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002009	Can you perform subqueries in Cassandra queries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'Can you perform subqueries in Cassandra queries?'  
C004400020	Cassandra 2_ Tutorial de CQL	pág 12.  Consultas	synthetic_question	Las consultas se usan de forma parecida a SQL. Podríamos obtener todos los usuarios mediante la siguiente sentencia: SELECT * FROM users; Para obtener los seguidores de Juan Valdez podríamos ejecutar la siguiente sentencia:	C00440002010	How can you optimize slow-performing Cassandra queries?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 12.  Consultas'; content: 'How can you optimize slow-performing Cassandra queries?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002101	What is the purpose of the WHERE clause in the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'What is the purpose of the WHERE clause in the given SQL query?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002102	Which field is used to filter the rows in the given SQL query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'Which field is used to filter the rows in the given SQL query?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002103	What type of data does the lived_in field contain in the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'What type of data does the lived_in field contain in the users table?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002104	Why would the previous query return an error according to the text?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'Why would the previous query return an error according to the text?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002105	How can we modify the previous query to retrieve the desired results?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'How can we modify the previous query to retrieve the desired results?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002106	What is the minimum required version of Cassandra to perform the modified query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'What is the minimum required version of Cassandra to perform the modified query?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002107	What is the purpose of creating an index on the lived_in field in the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'What is the purpose of creating an index on the lived_in field in the users table?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002108	Can we use the CONTAINS keyword in the WHERE clause to search for multiple cities in the lived_in field?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'Can we use the CONTAINS keyword in the WHERE clause to search for multiple cities in the lived_in field?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002109	How do we need to modify the created index to support searching for multiple cities?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'How do we need to modify the created index to support searching for multiple cities?'  
C004400021	Cassandra 2_ Tutorial de CQL	SELECT follower FROM followers WHERE username = 'jvaldez';	synthetic_question	La cláusula WHERE se utiliza para filtrar las filas. Se puede aplicar sólo sobre columnas que forman parte de la clave partición o que están indexadas. En caso de que queramos consultar filas en columnas de un tipo “colección” se puede utilizar la condición CONTAINS en la cláusula WHERE. La siguiente consulta nos devolvería los usuarios que han vivido en Bogotá. SELECT username FROM users WHERE lived_in CONTAINS 'Bogota'; No obstante, la sentencia anterior nos dará un error porque el campo no forma parte de la clave principal ni está indexado. Por tanto, habrá que indexarlo y después preguntar de nuevo. Para ello necesitaremos una versión posterior a 2.1 de Cassandra, ya que las versiones anteriores no permiten indexar campos de tipo colección. CREATE INDEX ON users (lived_in);	C00440002110	What is the benefit of indexing the lived_in field in the users table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT follower FROM followers WHERE username = 'jvaldez';'; content: 'What is the benefit of indexing the lived_in field in the users table?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002201	What is the purpose of the example given in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the purpose of the example given in the paragraph?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002202	What is the name of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the name of the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002203	What is the primary key of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the primary key of the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002204	What is the name of the first column in the primary key of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the name of the first column in the primary key of the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002205	What is the data type of the first column in the primary key of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the data type of the first column in the primary key of the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002206	What is the name of the second column in the primary key of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the name of the second column in the primary key of the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002207	What is the data type of the second column in the primary key of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the data type of the second column in the primary key of the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002208	What is the name of the third column in the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the name of the third column in the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002209	What is the data type of the third column in the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'What is the data type of the third column in the table created in the example?'  
C004400022	Cassandra 2_ Tutorial de CQL	SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';	synthetic_question	Un caso particular que hay que tener en cuenta en las consultas es cuando es necesario representar condiciones en la cláusula WHERE sobre columnas que no forman parte de la clave de partición o no están indexadas. En estos casos es posible evitar esta restricción si se usa la cláusula ALLOW FILTERING. Por ejemplo, considerar la siguiente familia de columnas: CREATE TABLE Imagenes-Tweets ( username text, id-tweet text, id-imagen text, año int) PRIMARY KEY(username,id-imagen, id-tweet) CREATE TABLE Imagenes-Tweets ( Bases de datos NoSQL Cassandra: tutorial	C00440002210	How many columns are there in the primary key of the table created in the example?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username FROM users WHERE lived_in CONTAINS 'Bogota';'; content: 'How many columns are there in the primary key of the table created in the example?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002301	What is the purpose of the search query mentioned in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'What is the purpose of the search query mentioned in the paragraph?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002302	Which field does the search query target in the Cassandra database?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'Which field does the search query target in the Cassandra database?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002303	What type of data is being searched for using this query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'What type of data is being searched for using this query?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002304	What is the time range for which the search query retrieves data (based on the given year 2010)?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'What is the time range for which the search query retrieves data (based on the given year 2010)?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002305	How does the search query filter the data retrieved from the Cassandra database?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'How does the search query filter the data retrieved from the Cassandra database?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002306	Can you identify the partition key used in the search query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'Can you identify the partition key used in the search query?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002307	Are there any additional filters or constraints applied to the search query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'Are there any additional filters or constraints applied to the search query?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002308	What is the expected result set returned by the search query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'What is the expected result set returned by the search query?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002309	Does the search query retrieve all images sent through tweets since 2010, or only those related to specific users or hashtags?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'Does the search query retrieve all images sent through tweets since 2010, or only those related to specific users or hashtags?'  
C004400023	Cassandra 2_ Tutorial de CQL	pág 13	synthetic_question	La siguiente sentencia busca toda la información sobre imágenes que fueron enviadas en tweets por diferentes usuarios a partir del año 2010.La búsqueda se realiza sobre el campo año aunque no forme parte de la clave de partición.	C00440002310	Can you explain how the search query utilizes the Cassandra database to store and manage large amounts of image data?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 13'; content: 'Can you explain how the search query utilizes the Cassandra database to store and manage large amounts of image data?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002401	What is the purpose of the SELECT statement in the given query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'What is the purpose of the SELECT statement in the given query?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002402	"Which column(s) does the query select from the table ""Imagenes-Tweets""?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'Which column(s) does the query select from the table ""Imagenes-Tweets""?'  "
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002403	What is the condition specified in the WHERE clause of the query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'What is the condition specified in the WHERE clause of the query?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002404	According to the query, which year do the tweets need to have been posted in order to be included in the result set?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'According to the query, which year do the tweets need to have been posted in order to be included in the result set?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002405	"How many columns are there in the table ""Imagenes-Tweets"" based on the given query?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'How many columns are there in the table ""Imagenes-Tweets"" based on the given query?'  "
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002406	Can we use the filter function in this query to narrow down the results further?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'Can we use the filter function in this query to narrow down the results further?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002407	Is it possible to retrieve only specific columns from the table using this query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'Is it possible to retrieve only specific columns from the table using this query?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002408	Does the query allow us to sort the results in ascending or descending order?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'Does the query allow us to sort the results in ascending or descending order?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002409	Can we use aggregate functions like SUM, AVG, MIN, MAX, etc. in this query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'Can we use aggregate functions like SUM, AVG, MIN, MAX, etc. in this query?'  
C004400024	Cassandra 2_ Tutorial de CQL	SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING	synthetic_question	En el caso de la máquina virtual, la versión es posterior a la 2.1, por tanto podremos ejecutar la consulta. Se puede consultar la versión de Cassandra mediante CQL utilizando la siguiente sentencia: SHOW VERSION Bases de datos NoSQL Cassandra: tutorial	C00440002410	Are there any subqueries used in this query?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'SELECT username, id-tweet,id-imagen, año FROM Imagenes-Tweets WHERE año>2010 ALLOW FILTERING'; content: 'Are there any subqueries used in this query?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002501	What type of index is created on the body field of the tweets table in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'What type of index is created on the body field of the tweets table in Cassandra?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002502	"How do we create an index on the tweets table in Cassandra using the sentence ""CREATE INDEX ON""?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'How do we create an index on the tweets table in Cassandra using the sentence ""CREATE INDEX ON""?'  "
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002503	What is the purpose of creating an index on the tweets table in Cassandra, according to the given paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'What is the purpose of creating an index on the tweets table in Cassandra, according to the given paragraph?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002504	Can we create multiple indexes on the same column in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'Can we create multiple indexes on the same column in Cassandra?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002505	Is there a limit to the number of indexes that can be created on a single table in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'Is there a limit to the number of indexes that can be created on a single table in Cassandra?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002506	"How does Cassandra determine which columns to include in an index when creating one using the ""CREATE INDEX ON"" statement?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'How does Cassandra determine which columns to include in an index when creating one using the ""CREATE INDEX ON"" statement?'  "
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002507	Can we drop an index on a column in Cassandra if we no longer need it?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'Can we drop an index on a column in Cassandra if we no longer need it?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002508	Does Cassandra support full-text search or only allows searching based on indexed columns?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'Does Cassandra support full-text search or only allows searching based on indexed columns?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002509	Can we use wildcards in the index names in Cassandra like we do in SQL?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'Can we use wildcards in the index names in Cassandra like we do in SQL?'  
C004400025	Cassandra 2_ Tutorial de CQL	pág 14.  Índices	synthetic_question	En Cassandra se puede crear índices mediante la sentencia CREATE INDEX ON. A continuación indexamos el cuerpo de los tweets. CREATE INDEX ON tweets (body); Bases de datos NoSQL Cassandra: tutorial	C00440002510	Are there any best practices or considerations that should be taken into account when creating indices in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 14.  Índices'; content: 'Are there any best practices or considerations that should be taken into account when creating indices in Cassandra?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002601	What type of data can be stored in a Cassandra table using columns of type counter?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'What type of data can be stored in a Cassandra table using columns of type counter?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002602	Can you create a dedicated table for storing counts in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'Can you create a dedicated table for storing counts in Cassandra?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002603	How can you use a counter column to store numbers that only change incrementally in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'How can you use a counter column to store numbers that only change incrementally in Cassandra?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002604	Is it possible to have multiple columns of type counter in a single Cassandra table?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'Is it possible to have multiple columns of type counter in a single Cassandra table?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002605	Can you provide an example scenario where using a counter column in Cassandra would be beneficial?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'Can you provide an example scenario where using a counter column in Cassandra would be beneficial?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002606	Are there any restrictions or limitations when using counter columns in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'Are there any restrictions or limitations when using counter columns in Cassandra?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002607	How does Cassandra handle concurrent updates to a counter column?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'How does Cassandra handle concurrent updates to a counter column?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002608	Can you create a composite key in Cassandra that includes a counter column?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'Can you create a composite key in Cassandra that includes a counter column?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002609	How does Cassandra optimize queries involving counter columns?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'How does Cassandra optimize queries involving counter columns?'  
C004400026	Cassandra 2_ Tutorial de CQL	pág 15.  Tipos de datos especiales	synthetic_question	Contadores En Cassandra pueden utilizarse columnas de tipo contador para almacenar números que sólo pueden cambiarse incrementalmente. Por ejemplo, podríamos utilizar un contador para contar el número de veces que un usuario es retweeteado. Para ello debemos crear el contador en una tabla dedicada, donde hay como mínimo una columna de tipo contador. Todas las columnas de la tabla que no sean de tipo contador deberán formar parte de la clave primaria.	C00440002610	Are there any best practices or guidelines for using counter columns in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 15.  Tipos de datos especiales'; content: 'Are there any best practices or guidelines for using counter columns in Cassandra?'  
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002701	"What is the purpose of creating the table ""user_retweeted_counts"" according to the given paragraph?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'What is the purpose of creating the table ""user_retweeted_counts"" according to the given paragraph?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002702	"What is the primary key of the ""user_retweeted_counts"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'What is the primary key of the ""user_retweeted_counts"" table?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002703	"Which column stores the unique identifier for each user in the ""user_retweeted_counts"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'Which column stores the unique identifier for each user in the ""user_retweeted_counts"" table?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002704	"How does the paragraph suggest we could update the ""counter_value"" for a specific user if their tweet is retweeted?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'How does the paragraph suggest we could update the ""counter_value"" for a specific user if their tweet is retweeted?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002705	What is the name of the database management system being used in the example provided in the paragraph?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'What is the name of the database management system being used in the example provided in the paragraph?'  
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002706	According to the paragraph, what is the effect of running the given SQL statement?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'According to the paragraph, what is the effect of running the given SQL statement?'  
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002707	"Can we infer from the paragraph that the ""counter_value"" column represents the number of times a user's tweet has been retweeted?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'Can we infer from the paragraph that the ""counter_value"" column represents the number of times a user's tweet has been retweeted?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002708	"What is the significance of the ""WHERE"" clause in the given SQL statement?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'What is the significance of the ""WHERE"" clause in the given SQL statement?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002709	"How does the paragraph describe the relationship between the ""user_id"" column and the ""counter_value"" column in the ""user_retweeted_counts"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'How does the paragraph describe the relationship between the ""user_id"" column and the ""counter_value"" column in the ""user_retweeted_counts"" table?'  "
C004400027	Cassandra 2_ Tutorial de CQL	CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);	synthetic_question	Si el siguiente sentencia: tweet de un usuario es retweeteado podríamos incrementar el contador con la UPDATE user_retweeted_counts SET counter_value = counter_value + 1 WHERE user_id ='jvaldez'; Bases de datos NoSQL Cassandra: tutorial	C00440002710	Based on the paragraph, what is the main topic or focus of the given tutorial?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'CREATE TABLE user_retweeted_counts (counter_value counter, user_id text PRIMARY KEY);'; content: 'Based on the paragraph, what is the main topic or focus of the given tutorial?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002801	What type of data is stored in collections in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'What type of data is stored in collections in Cassandra?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002802	What is the purpose of using collections in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'What is the purpose of using collections in Cassandra?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002803	How do collection types differ from sets in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'How do collection types differ from sets in Cassandra?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002804	Can values in a collection be repeated or not?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'Can values in a collection be repeated or not?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002805	"How can we modify the table ""users"" to include email addresses for each user?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'How can we modify the table ""users"" to include email addresses for each user?'  "
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002806	"What command would we use to add a new column to the ""users"" table to store email addresses?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'What command would we use to add a new column to the ""users"" table to store email addresses?'  "
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002807	"How can we update the ""users"" table to include email addresses for each user?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'How can we update the ""users"" table to include email addresses for each user?'  "
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002808	Is it possible to have multiple columns of the same data type in a single table in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'Is it possible to have multiple columns of the same data type in a single table in Cassandra?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002809	Can we use collections to store different data types in a single column?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'Can we use collections to store different data types in a single column?'  
C004400028	Cassandra 2_ Tutorial de CQL	pág 16	synthetic_question	Colecciones Las columnas de tipo colección permiten almacenar diferentes valores en una sola columna y son útiles para cuando queremos desnormalizar una pequeña cantidad de datos. Básicamente list y . map Las colecciones de tipo set nos permiten definir un conjunto de valores, por tanto, los valores no estarán ordenados ni permitirán repetición. Como ejemplo, podríamos modificar la tabla users para añadir las direcciones de correo de cada usuario: ALTER TABLE users ADD emails set<text>; UPDATE users SET emails = emails +	C00440002810	Are there any limitations to using collections in Cassandra?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: 'pág 16'; content: 'Are there any limitations to using collections in Cassandra?'  
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002901	"What is the purpose of modifying the table ""users"" in the example given?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'What is the purpose of modifying the table ""users"" in the example given?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002902	"How does the addition of the ""lived_in"" list column affect the data stored in the ""users"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'How does the addition of the ""lived_in"" list column affect the data stored in the ""users"" table?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002903	What type of collection is used to store the list of cities where each user has lived?	passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'What type of collection is used to store the list of cities where each user has lived?'  
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002904	"How do the modifications made to the ""users"" table using the ALTER statement affect existing data in the table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'How do the modifications made to the ""users"" table using the ALTER statement affect existing data in the table?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002905	"What is the purpose of adding the ""social_net"" map column to the ""users"" table?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'What is the purpose of adding the ""social_net"" map column to the ""users"" table?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002906	"How does the update statement affect the data stored in the ""social_net"" column?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'How does the update statement affect the data stored in the ""social_net"" column?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002907	"What is the difference between a ""list"" and a ""map"" collection in Cassandra?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'What is the difference between a ""list"" and a ""map"" collection in Cassandra?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002908	"Can you explain the purpose of the comma separated values in the ""lived_in"" list column?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'Can you explain the purpose of the comma separated values in the ""lived_in"" list column?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002909	"How would you modify the ""users"" table to include additional information about each user, such as their age or gender?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'How would you modify the ""users"" table to include additional information about each user, such as their age or gender?'  "
C004400029	Cassandra 2_ Tutorial de CQL	{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';	synthetic_question	Las colecciones de tipo list nos permiten definir un conjunto ordenado de valores, que pueden estar repetidos. Como ejemplo, podríamos modificar la tabla users para añadir la lista de ciudades donde ha vivido cada usuario. ALTER TABLE users ADD lived_in list<text>; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'jvaldez'; UPDATE users SET lived_in=[ 'Bogota', 'Medellin', 'Bogota' ] WHERE username = 'conchita'; Las colecciones de tipo map nos permiten definir pares de datos. Como ejemplo, podríamos modificar la tabla users para añadir una colección donde aparezcan las cuentas que aparecen en otras redes sociales: ALTER TABLE users ADD social_net map<text,text>; UPDATE users SET social_net= social_net+{'Facebook': 'jvaldezito', 'Instagram': 'jvaldezito@instagram.es'} WHERE username = 'jvaldez'; UPDATE users SET social_net= social_net+{'Facebook': 'conchita', 'Instagram': 'conchita@instagram.es'} WHERE username = 'conchita'; Bases de datos NoSQL Cassandra: tutorial	C00440002910	"Can you describe how the modifications made to the ""users"" table in this tutorial relate to real-world use cases for Cassandra?"	"passage: document 'Cassandra 2_ Tutorial de CQL'; paragraph: '{'jv@cafeAdictos.org','jvaldez@FNC.org'}.  WHERE username = 'jvaldez';'; content: 'Can you describe how the modifications made to the ""users"" table in this tutorial relate to real-world use cases for Cassandra?'  "
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000101	What is the main topic of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'What is the main topic of the paragraph?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000102	Who is mentioned in the paragraph as the author of the publication?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'Who is mentioned in the paragraph as the author of the publication?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000103	What is the title of the publication according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'What is the title of the publication according to the paragraph?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000104	What type of content cannot be copied or reproduced without permission according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'What type of content cannot be copied or reproduced without permission according to the paragraph?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000105	Is the content of the publication only available in electronic form or does it also exist in physical form?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'Is the content of the publication only available in electronic form or does it also exist in physical form?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000106	"How many times has the word ""gestió"" been used in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'How many times has the word ""gestió"" been used in the paragraph?'  "
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000107	Can the content of the publication be stored or transmitted through various media such as electric, chemical, mechanical, optical, recording, photocopying, or other methods?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'Can the content of the publication be stored or transmitted through various media such as electric, chemical, mechanical, optical, recording, photocopying, or other methods?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000108	Does the paragraph mention any specific requirements or restrictions for using the content of the publication?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'Does the paragraph mention any specific requirements or restrictions for using the content of the publication?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000109	Are there any penalties or consequences for violating the copyright laws stated in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'Are there any penalties or consequences for violating the copyright laws stated in the paragraph?'  
C001500001	Gestio╠ü de transaccions	Gestió de transaccions	synthetic_question	M. Elena Rodríguez González PID_00171647 Cap part d'aquesta publicació, incloent-hi el disseny general i la coberta, no pot ser copiada, reproduïda, emmagatzemada o transmesa de cap manera ni per cap mitjà, tant si és elèctric com químic, mecànic, òptic, de gravació, de fotocòpia o per altres mètodes, sense l'autorització prèvia per escrit dels titulars del copyright. Gestió de transaccions	C00150000110	According to the paragraph, what is the purpose of the publication's copyright notice?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de transaccions'; content: 'According to the paragraph, what is the purpose of the publication's copyright notice?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000301	What is one of the main objectives of systems of database management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'What is one of the main objectives of systems of database management?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000302	"What does ""data integrity"" refer to in this context?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'What does ""data integrity"" refer to in this context?'  "
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000303	What are some possible causes of compromising data integrity in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'What are some possible causes of compromising data integrity in SGBD?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000304	How might SGBD address the issue of simultaneous access to the same database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'How might SGBD address the issue of simultaneous access to the same database?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000305	What is the purpose of transactions in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'What is the purpose of transactions in SGBD?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000306	How do transactions ensure data integrity in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'How do transactions ensure data integrity in SGBD?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000307	What happens if an error occurs during the execution of a transaction in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'What happens if an error occurs during the execution of a transaction in SGBD?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000308	Can you describe a scenario where SGBD would need to handle an unexpected failure or disaster?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'Can you describe a scenario where SGBD would need to handle an unexpected failure or disaster?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000309	How might SGBD achieve high availability in the face of such challenges?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'How might SGBD achieve high availability in the face of such challenges?'  
C001500003	Gestio╠ü de transaccions	Introducció	synthetic_question	Un dels objectius més importants dels sistemes de gestió de bases de dades (SGBD) és garantir la integritat de les dades emmagatzemades a les bases de dades (BD) que gestionen. La integritat té a veure amb la consistència i la qualitat de les dades. Hi ha diverses causes que poden comprometre la integritat de les dades: l'accés simultani de d'usuaris diferents a una mateixa BD, una situació d'avaria, el fet que s'hagi decidit tenir dades reproduïdes per a millorar el rendiment en l'accés a la BD o que una operació pugui comprometre una regla d'integritat definida sobre la BD. En aquest mòdul estem interessats en les possibles anomalies que es derivin de l'accés simultani de diversos usuaris a la mateixa BD i en el fet d'assegurar la disponibilitat de la BD davant de fallades o desastres, com seria el cas d'una avaria en els dispositius d'emmagatzematge extern, una apagada o un incendi. Cal tenir present que les dades d'una organització gairebé sempre en són un dels actius principals, una eina indispensable per al desenvolupament normal de les activitats que duu a terme. L'SGBD ha d'afrontar totes aquestes possibles anomalies i, per fer-ho, es fonamenta en el concepte de transacció i en una sèrie de mecanismes per a gestionar aquestes transaccions.	C00150000310	In what ways could SGBD improve its ability to handle concurrency and ensure data integrity in the presence of multiple users and potential failures?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Introducció'; content: 'In what ways could SGBD improve its ability to handle concurrency and ensure data integrity in the presence of multiple users and potential failures?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000401	What are the two main problems that arise from multiple users accessing the same database simultaneously?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What are the two main problems that arise from multiple users accessing the same database simultaneously?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000402	What is a transaction, and what properties must it have according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What is a transaction, and what properties must it have according to the paragraph?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000403	How does a system manage transactions in terms of controlling user access and handling failures or disasters that threaten data availability?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'How does a system manage transactions in terms of controlling user access and handling failures or disasters that threaten data availability?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000404	What is the simplest technique for managing concurrency, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What is the simplest technique for managing concurrency, according to the paragraph?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000405	What are some basic knowledge areas mentioned in the paragraph regarding data loss prevention and recovery?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What are some basic knowledge areas mentioned in the paragraph regarding data loss prevention and recovery?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000406	Can you describe how a system should use services like backups and snapshots to avoid losing or corrupting data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'Can you describe how a system should use services like backups and snapshots to avoid losing or corrupting data?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000407	In what ways can an application developer use the management of transactions correctly and efficiently, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'In what ways can an application developer use the management of transactions correctly and efficiently, according to the paragraph?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000408	What are the six objectives listed in the paragraph that an educator might find useful when creating a teaching module about this topic?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What are the six objectives listed in the paragraph that an educator might find useful when creating a teaching module about this topic?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000409	What is the name of the teaching module described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What is the name of the teaching module described in the paragraph?'  
C001500004	Gestio╠ü de transaccions	Objectius	synthetic_question	En el material didàctic d'aquest mòdul, l'estudiant trobarà les eines bàsiques per a assolir els objectius següents: 1. Comprendre els problemes que es deriven de l'accés concurrent de diversos usuaris a una mateixa base de dades. 2. Saber què és una transacció, quines propietats ha de tenir i com s'utilitza. 3. Comprendre les funcions que ha d'acomplir un sistema de gestió de bases de dades en la gestió de transaccions, tant pel que fa al control de l'accés concurrent per part dels usuaris com en el cas de fallades o desastres que posin en perill la disponibilitat de les dades. 4. Conèixer el funcionament de les reserves, la tècnica més senzilla per al control de la concurrència. 5. Tenir coneixements bàsics de com pot evitar un sistema de gestió de bases de dades que es perdin o malmetin dades, mitjançant còpies de seguretat i dietaris. 6. Ser capaç de desenvolupar aplicacions que utilitzin d'una manera correcta i eficient els serveis de gestió de transaccions que ofereixen els sistemes de gestió de bases de dades.	C00150000410	What is the name of the document containing this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Objectius'; content: 'What is the name of the document containing this paragraph?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000501	What is the main concern associated with managing transactions in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What is the main concern associated with managing transactions in SGBD?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000502	What happens if an user initiates a transfer of funds and then experiences an power outage during the third step?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What happens if an user initiates a transfer of funds and then experiences an power outage during the third step?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000503	Why is it important for applications to ensure that transferences are completed entirely or not at all?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'Why is it important for applications to ensure that transferences are completed entirely or not at all?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000504	What potential danger could arise if two different users attempt to make simultaneous transfers to the same destination account?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What potential danger could arise if two different users attempt to make simultaneous transfers to the same destination account?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000505	How would the final balance of the destination account change if both users successfully transferred their intended amounts?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'How would the final balance of the destination account change if both users successfully transferred their intended amounts?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000506	Can you explain why the example given in the passage represents a serious risk?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'Can you explain why the example given in the passage represents a serious risk?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000507	In what way does the absence of control over concurrent transactions in SGBD pose a threat to application functionality?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'In what way does the absence of control over concurrent transactions in SGBD pose a threat to application functionality?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000508	How might an application protect itself against the anomalies described in the passage when executing transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'How might an application protect itself against the anomalies described in the passage when executing transactions?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000509	What specific action should be taken to avoid the issue depicted in the table in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What specific action should be taken to avoid the issue depicted in the table in the passage?'  
C001500005	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	En els SGBD, el concepte de transacció representa la unitat de treball a l'efecte de control de concurrència i recuperació. La gestió de transaccions que executa l'SGBD protegeix les aplicacions de les anomalies importants que es poden produir si no es duu a terme. A continuació veurem, amb exemples, els problemes que poden sorgir quan s'executen d'una manera concurrent, i sense cap control per part de l'SGBD, diferents transaccions. Suposem que una aplicació d'una entitat bancària ofereix als usuaris una funció que permet transferir una certa quantitat de diners d'un compte d'origen a un compte de destinació. Aquesta funció podria executar els passos que mostrem en la taula següent (en pseudocodi). Cal considerar les anomalies que es produiran si no es pren cap precaució: 1) Suposem que un usuari comença a executar una d'aquestes transferències i, just després del tercer pas, una apagada fa que el procés no acabi. En aquest cas, s'haurà restat la quantitat transferida al saldo del compte d'origen, però no s'haurà sumat al del compte de destinació. Aquesta possibilitat representa un perill greu. Des del punt de vista de l'aplicació, les operacions que s'executen quan es fa la transferència s'han de dur a terme completament o no s'han d'efectuar en absolut; és a dir, la transferència no pot quedar a mitges. 2) Suposem que dos usuaris diferents (A i B) intenten fer dues transferències, al mateix temps, des de comptes origen diferents i cap al mateix compte de destinació. Analitzem què pot passar si per qualsevol motiu, i sense cap control per part de l'SGBD, els passos de les transaccions s'executen concurrentment en l'ordre següent: El resultat final és que el compte de destinació té com a saldo l'inicial més 40, en comptes de més 60. Això és incorrecte, ja que s'ha perdut la quantitat que ha transferit l'usuari A.	C00150000510	What lesson can be learned from the example given in the passage about the importance of proper transaction management in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What lesson can be learned from the example given in the passage about the importance of proper transaction management in SGBD?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000601	What is the main problem associated with managing transactions in a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What is the main problem associated with managing transactions in a database?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000602	How does the example given in the passage illustrate this problem?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'How does the example given in the passage illustrate this problem?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000603	What would happen if an error in programming the transfer function caused the balance of the destination account to be reset to zero instead of adding the transferred amount to the previous balance?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What would happen if an error in programming the transfer function caused the balance of the destination account to be reset to zero instead of adding the transferred amount to the previous balance?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000604	Why do users need to verify that their transactions meet their requirements?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'Why do users need to verify that their transactions meet their requirements?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000605	What would happen if there was an error fatal to the storage device where the database was stored, causing it to become unavailable?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What would happen if there was an error fatal to the storage device where the database was stored, causing it to become unavailable?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000606	How could mechanisms be put in place to prevent data loss due to both old data and recent updates being lost?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'How could mechanisms be put in place to prevent data loss due to both old data and recent updates being lost?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000607	In what way did the execution of the transfer function by user B affect the execution of the transfer function by user A?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'In what way did the execution of the transfer function by user B affect the execution of the transfer function by user A?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000608	If all users had to work individually with the database without knowing how others were working, how could they ensure that their transactions met their requirements?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'If all users had to work individually with the database without knowing how others were working, how could they ensure that their transactions met their requirements?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000609	How might the behavior described in the passage be corrected or improved upon?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'How might the behavior described in the passage be corrected or improved upon?'  
C001500006	Gestio╠ü de transaccions	1. Problemàtica associada a la gestió de transaccions	synthetic_question	Cal impedir d'alguna manera que l'accés concurrent de diversos usuaris produeixi resultats anòmals. Cada usuari, individualment, ha de tenir la percepció que només ell treballa amb la BD. En l'exemple que hem plantejat, l'execució de la transferència que efectua l'usuari B ha interferit en l'execució de la transferència que duu a ter- me l'usuari A. Si totes dues transferències s'haguessin executat correctament aïllades l'una de l'altra, el saldo total del compte de destinació hauria estat el saldo inicial més 60. 3) Imaginem que un error de programació de la funció de transferència fa que el saldo del compte de destinació rebi com a nou valor la quantitat que s'ha transferit, en comptes de sumar-la al saldo anterior. Naturalment, aquest comportament serà incorrecte, ja que no es correspon amb el desig dels usuaris, i deixarà la BD en un estat inconsistent: els saldos que haurien de tenir els comptes d'acord amb els moviments registrats (en el cinquè pas) no coincidirien amb els que s'han emmagatzemat realment. En conclusió, és missió dels dissenyadors i programadors que les transaccions verifiquin els requisits dels usuaris. 4) Plantegem-nos què passaria si, després d'utilitzar l'aplicació durant uns quants dies, i en un moment de plena activitat, es produeix un error fatal del dispositiu d'emmagatzematge extern en què es guarda la BD, de manera que la BD deixa d'estar disponible. En definitiva, cal que hi hagi mecanismes per a evitar la pèrdua tant de les dades més antigues com de les actualitzacions més recents.	C00150000610	What lesson can be learned from this passage about the importance of considering the needs of multiple users when designing a system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1. Problemàtica associada a la gestió de transaccions'; content: 'What lesson can be learned from this passage about the importance of considering the needs of multiple users when designing a system?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000701	What is the purpose of transactions in a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'What is the purpose of transactions in a database?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000702	How do programs interact with a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'How do programs interact with a database?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000703	What is the difference between an atomic transaction and a non-atomic one?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'What is the difference between an atomic transaction and a non-atomic one?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000704	What is the purpose of the COMMIT sentence in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'What is the purpose of the COMMIT sentence in SQL?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000705	What happens if a transaction is interrupted or aborted?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'What happens if a transaction is interrupted or aborted?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000706	Can you describe the four properties of a transaction according to ACID?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'Can you describe the four properties of a transaction according to ACID?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000707	What is the purpose of the ROLLBACK sentence in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'What is the purpose of the ROLLBACK sentence in SQL?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000708	How does an SGBD ensure atomicity in a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'How does an SGBD ensure atomicity in a transaction?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000709	What is the significance of a transaction being treated as a single, indivisible unit of work?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'What is the significance of a transaction being treated as a single, indivisible unit of work?'  
C001500007	Gestio╠ü de transaccions	2. Definició i propietats de les transaccions	synthetic_question	L'accés a la dades que hi ha en una BD es fa mitjançant l'execució d'operacions a l'SGBD corresponent. Atès que estem interessats en SGBD relacionals, aquestes operacions, a un alt nivell, seran sentències SQL. A més, amb vista a resoldre el tipus de problemes que hem plantejat en l'apartat anterior, aquestes operacions s'agrupen en transaccions. Una transaccióés un conjunt d'operacions (de lectura i actualització) sobre la BD que s'executen com una unitat indivisible de treball. La transacció acaba la seva execució confirmant o cancel·lant els canvis que s'han dut a terme sobre la BD. Un programa comença a treballar amb una BD connectant-s'hi d'una manera adequada i establint una sessió de treball que permet efectuar operacions de lectura i actualització (insercions, esborraments, modificacions) de la BD. Per a fer una operació hi ha d'haver una transacció activa (o en execució), que sempre és única. La transacció activa es pot iniciar mitjançant una instrucció especial o automàticament quan es fa la primera operació a l'SGBD. Tota transacció hauria de complir quatre propietats, conegudes com a propietatsACID: 1)Atomicitat. El conjunt d'operacions que constitueixen la transacció és la unitat atòmica, indivisible, d'execució. Això vol dir que, o bé s'executen totes les operacions de la transacció (i, en aquest cas, la transacció confirma els resultats) o bé no se n'executa cap ni una (i, en aquest cas, la transacció cancel·la els resultats). En definitiva, l'SGBD ha de garantir el tot o res per a cada transacció: a) Per a confirmar els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de COMMIT. b) En cas contrari, sia perquè alguna cosa impedeix que s'acabi d'executar la transacció (per exemple, un tall de llum) sia perquè la transacció acaba amb una petició explícita de cancel·lació per part del programa d'aplicació, l'SGBD ha de desfer tots els canvis que la transacció hagi fet sobre la BD fins aquest moment, com si la transacció mai no hagués existit. En tots dos casos es diu que la transacció ha avortat (en anglès, abort) l'execució. Per a cancel·lar d'una manera explícita els resultats produïts per l'execució d'una transacció, disposem de la sentència SQL de ROLLBACK.	C00150000710	In what situations might a program explicitly request a rollback of a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2. Definició i propietats de les transaccions'; content: 'In what situations might a program explicitly request a rollback of a transaction?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000801	What is the meaning of ACID in the context of database transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'What is the meaning of ACID in the context of database transactions?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000802	What is the purpose of consistency in database transactions according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'What is the purpose of consistency in database transactions according to the paragraph?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000803	How does the isolation property ensure that transactions are executed independently?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'How does the isolation property ensure that transactions are executed independently?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000804	What happens to the results produced by a transaction if it aborts during execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'What happens to the results produced by a transaction if it aborts during execution?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000805	Can the properties of atomicity, consistency, isolation, and definitiveness be achieved simultaneously in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'Can the properties of atomicity, consistency, isolation, and definitiveness be achieved simultaneously in a database system?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000806	Why is it important to guarantee the ACID properties of transactions in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'Why is it important to guarantee the ACID properties of transactions in a database system?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000807	How do the properties of atomicity and definitiveness relate to each other in the context of database transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'How do the properties of atomicity and definitiveness relate to each other in the context of database transactions?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000808	What is the difference between a committed transaction and an aborted transaction in terms of their impact on the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'What is the difference between a committed transaction and an aborted transaction in terms of their impact on the database?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000809	Can a transaction be both atomic and isolated at the same time?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'Can a transaction be both atomic and isolated at the same time?'  
C001500008	Gestio╠ü de transaccions	ACID	synthetic_question	ACID és una sigla que es forma a partir de les inicials de les paraules atomicitat, consistència, isolament i definitivitat. 2)Consistència. L'execució d'una transacció ha de preservar la consistència de la BD. En altres paraules, si abans d'executar-se una transacció la BD es troba en un estat consistent (és a dir, en un estat en què es verifiquen totes les regles d'integritat definides sobre la BD), en acabar l'execució de la transacció la BD ha de quedar també en un estat consistent, si bé, mentre la transacció estigui activa, la BD podria caure momentàniament en un estat inconsistent. 3)Isolament. Una transacció no pot veure interferida l'execució per cap altra transacció que s'estigui executant concurrentment amb aquesta. En definitiva, l'SGBD ha de garantir l'aïllament correcte de les transaccions. 4)Definitivitat. Els resultats produïts per una transacció que confirma (és a dir, que executa l'operació de COMMIT) han de ser definitius en la BD, mai no es poden perdre, independentment que es produeixin fallades o desastres, fins que una altra transacció canviï aquests resultats i els confirmi. Per contra, els resultats produïts per una transacció que avorta l'execució s'han de descartar de la BD. Les propietats que acabem de presentar no són independents entre elles; per exemple, les propietats d'atomicitat i definitivitat estan estretament interrelacionades. A més, el fet de garantir les propietats ACID de les transaccions no és solament una missió de l'SGBD, sinó també de les aplicacions que l'utilitzen i, per consegüent, del seu desenvolupador.	C00150000810	According to the paragraph, what is the responsibility of the application developer when using a database system that guarantees the ACID properties of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'ACID'; content: 'According to the paragraph, what is the responsibility of the application developer when using a database system that guarantees the ACID properties of transactions?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000901	What are the two types of interference that can occur when transactions execute concurrently?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What are the two types of interference that can occur when transactions execute concurrently?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000902	What is the reason why one transaction may interfere with another if they access the same portion of the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the reason why one transaction may interfere with another if they access the same portion of the database?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000903	Can two transactions that only perform reads interfere with each other?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can two transactions that only perform reads interfere with each other?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000904	If two transactions update different parts of the database, can they still interfere with each other?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'If two transactions update different parts of the database, can they still interfere with each other?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000905	What is an example of interference that can occur between two transactions that both perform updates?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is an example of interference that can occur between two transactions that both perform updates?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000906	How does the loss of a change occur due to interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the loss of a change occur due to interference between transactions?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000907	In what situation might interference between transactions result in a lost change?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'In what situation might interference between transactions result in a lost change?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000908	Can interference between transactions cause a situation where a transaction overwrites changes made by another transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can interference between transactions cause a situation where a transaction overwrites changes made by another transaction?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000909	Is it possible for two transactions to interfere with each other even if they do not access the same part of the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Is it possible for two transactions to interfere with each other even if they do not access the same part of the database?'  
C001500009	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest apartat presentarem els tipus d'interferències que es poden produir si les transaccions que s'executen d'una manera concurrent no verfiquen la propietat d'isolament. Abans d'entrar en aquestes interferències, és important destacar que, si hi ha dues transaccions que s'executen concurrentment, una d'aquestes transaccions només pot interferir en l'execució de l'altra si s'esdevenen les circumstàncies següents: a) Les dues transaccions accedeixen a una mateixa porció de la BD. b) Com a mínim una de les dues transaccions, sobre aquesta porció comuna de la BD a la qual estan accedint, efectua operacions d'actualització. Dit d'una altra manera, quan les transaccions que s'executen concurrentment només fan lectures, no es produiran mai interferències. D'una manera similar, en cas que les transaccions facin actualitzacions, si aquestes són sobre porcions diferents, no relacionades amb la BD, tampoc no es poden produir interferències. A continuació presentem, mitjançant exemples, els tipus d'interferències que hi pot haver entre dues transaccions T1 i T2 que es processen concurrentment, si no estan aïllades d'una manera adient entre elles: 1)Actualitzacióperduda. Aquesta interferència s'esdevé quan es perd un canvi efectuat per una transacció sobre una dada a causa de la presència d'una altra transacció que també canvia la mateixa dada. Això podria succeir en una situació com la que es mostra a continuació: Les dues transaccions, T1 i T2, executen un mateix tipus de transacció; en aquest cas, un reintegrament d'un mateix compte bancari. Totes dues transaccions llegeixen el mateix valor del saldo del compte, l'actualitzen d'una manera independent (assumim que hi ha saldo suficient en el compte per a fer els reintegraments) i resten a aquest saldo la quantitat que se n'ha sostret.	C00150000910	What is the main point of the paragraph regarding interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the main point of the paragraph regarding interference between transactions?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001001	What is the main cause of interference between transactions in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the main cause of interference between transactions in the example given?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001002	How does the presence of transaction T2 affect the execution of transaction T1?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the presence of transaction T2 affect the execution of transaction T1?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001003	Why does the saldo of account 1 decrease by 40 instead of 60 in the first scenario?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Why does the saldo of account 1 decrease by 40 instead of 60 in the first scenario?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001004	In what way does the order of operations impact the outcome of the transactions in this scenario?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'In what way does the order of operations impact the outcome of the transactions in this scenario?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001005	Can you explain why there would be no interference if the sequence of operations were different, according to the example shown later in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can you explain why there would be no interference if the sequence of operations were different, according to the example shown later in the paragraph?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001006	What is the effect of reading a provisional value of saldo during a transaction, as described in point 2 of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the effect of reading a provisional value of saldo during a transaction, as described in point 2 of the paragraph?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001007	How does the recovery of the saldo value by T2 prevent interference in the second scenario?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the recovery of the saldo value by T2 prevent interference in the second scenario?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001008	"What is the significance of the phrase ""lectura no confirmada"" in the context of this paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the significance of the phrase ""lectura no confirmada"" in the context of this paragraph?'  "
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001009	Can you provide an example of a situation where interference might occur due to a pending confirmation of a data modification made by another transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can you provide an example of a situation where interference might occur due to a pending confirmation of a data modification made by another transaction?'  
C001500010	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Suposant que l'SGBD executa les operacions que constitueixen cada transacció sense cap control i en l'ordre que es proposa en l'exemple, el canvi corresponent a la subtracció de T1 es perd. En conseqüència, el saldo disminueix només de 40, en comptes de 60. En definitiva, T1 ha vist la seva execució interferida a causa de la presència de T2. Si l'ordre d'execució de les operacions de cada transacció hagués estat el següent: s'hauria produït igualment la interferència. En aquest cas, s'hauria perdut el canvi efectuat per T2. En conseqüència, el saldo disminueix només de 20, en comptes de 60. En aquest cas, T2 ha vist la seva execució interferida a causa de la presència de T1. En definitiva, la interferència s'esdevé perquè es produeixen dues lectures consecutives d'una mateixa dada (el saldo d'un mateix compte) seguides de dos canvis consecutius de la mateixa dada (de nou, el saldo d'un mateix compte). Simplement, si la seqüència d'operacions hagués estat, per exemple, la que es mostra a continuació, llavors la interferència no s'hauria produït. En aquest cas, T2 recupera el valor del saldo de compte que deixa T1 i, tenint en compte aquest nou valor de saldo per al compte, efectua el seu propi reintegrament. En conseqüència, el saldo del compte disminueix en 60. 2) Lectura no confirmada. Aquesta interferència es pot produir quan una transacció recupera una dada pendent de confirmació que ha estat modificada per una altra transacció que s'executa concurrentment amb la transacció que recupera la dada. Això podria succeir en diverses situacions com les que es mostren a continuació: Primerament, la transacció T2 llegeix el saldo del compte i el disminueix en la quantitat que es vol reintegrar. A continuació, la transacció T1 efectua una consulta de saldo del mateix compte sobre el qual T2 fa el reintegrament. El valor de saldo que obté T1 està pendent de confirmar, és una dada provisional, ja que T2 encara no ha confirmat els seus resultats. Tot seguit, la transacció T1 finalitza l'execució, i confirma els resultats. Finalment, T2 cancel·la l'execució.	C00150001010	How do the concepts of interference and pending confirmations relate to each other in the context of this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How do the concepts of interference and pending confirmations relate to each other in the context of this paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001101	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the purpose of the example given in the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001102	What are the two types of interference mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What are the two types of interference mentioned in the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001103	How does the first type of interference occur according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the first type of interference occur according to the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001104	How does the second type of interference occur according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the second type of interference occur according to the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001105	Why does the transaction T1 recover a provisional value in the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Why does the transaction T1 recover a provisional value in the example given in the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001106	What is the effect of the interference on the execution of the transactions according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the effect of the interference on the execution of the transactions according to the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001107	Can the interference between transactions be avoided according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can the interference between transactions be avoided according to the paragraph?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001108	What is the significance of the example given in the paragraph in relation to the topic of the document?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the significance of the example given in the paragraph in relation to the topic of the document?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001109	How does the concept of interference between transactions apply to real-world scenarios in database management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the concept of interference between transactions apply to real-world scenarios in database management?'  
C001500011	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	Aquesta cancel·lació fa que els resultats produïts per T2 siguin descartats de la BD, de manera que el saldo del compte sigui el que hi havia abans de començar l'execució de T2. En conseqüència, T1 ha recuperat un valor que oficialment mai no ha existit i ha vist interferida la seva execució per la transacció T2. Si les transaccions T1 i T2 haguessin estat aïllades correctament, T1 mai no hauria recuperat el valor provisional deixat per T2 i que finalment ha estat descartat. En l'exemple previ, la interferència de lectura no confirmada s'esdevé a causa de la cancel·lació de la transacció que modifica les dades. Tanmateix, la interferència es pot produir igualment en cas que la transacció que modifica dades confirmi els resultats. Imaginem ara que tenim dues transaccions, T1 i T2. La transacció T1 fa la consulta d'un saldo d'un compte corrent, mentre que T2 efectua un parell de reintegraments del mateix compte corrent. Suposem que l'ordre d'execució de les operacions és el que es mostra a continuació i que l'SGBD no efectua cap control sobre l'ordre d'execució d'aquestes operacions: En aquest cas, i malgrat que la transacció T2 confirma els resultats, T1 veu interferida la seva execució per T2, i recupera una dada provisional, pendent de confirmació. Aquesta dada correspon a un saldo provisional per al compte corrent, que correspon al saldo que queda després del primer reintegrament. 3)Lecturanorepetible. Aquesta interferència es produeix quan una transacció, pels motius que sigui, necessita llegir dos cops una mateixa dada i en cada lectura recupera un valor diferent, pel fet que hi ha una altra transacció que s'executa simultàniament que efectua una modificació de la dada llegida. Això podria passar en diverses situacions, com la que es mostra a continuació: La transacció T2, que consulta dos cops el saldo d'un mateix compte corrent, recupera en cada lectura un valor diferent, pel fet que la transacció T1 entre totes dues lectures efectua un reintegrament, i interfereix en l'execució de la transacció T2. Si les transaccions s'haguessin aïllat correctament entre elles, T2 hauria recuperat el mateix valor per al saldo de compte corrent en totes dues lectures; o bé, hauria recuperat el valor que correspon al saldo del compte abans d'efectuar-se el reintegrament de T1, o bé, el saldo que queda després d'efectuar-se el reintegrament de T1.	C00150001110	In what ways can database systems mitigate or prevent interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'In what ways can database systems mitigate or prevent interference between transactions?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001201	What are the three types of interferences that can occur between transactions, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What are the three types of interferences that can occur between transactions, according to the passage?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001202	How does analysis inconsistent (and the specific case of ghosts) affect transaction execution, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does analysis inconsistent (and the specific case of ghosts) affect transaction execution, according to the passage?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001203	Can you explain the example given in the passage about how interference can occur when two transactions access the same data item?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can you explain the example given in the passage about how interference can occur when two transactions access the same data item?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001204	What is the cause of interference in the scenario described in the passage where one transaction reads a set of data while another transaction updates a part of it?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the cause of interference in the scenario described in the passage where one transaction reads a set of data while another transaction updates a part of it?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001205	How do ghosts arise in the context of database transactions, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How do ghosts arise in the context of database transactions, according to the passage?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001206	What is the effect of interference on transaction execution, as stated in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the effect of interference on transaction execution, as stated in the passage?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001207	Can you provide an example of how interference can occur when a transaction reads a set of data related to another transaction's update?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can you provide an example of how interference can occur when a transaction reads a set of data related to another transaction's update?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001208	According to the passage, what is the consequence of not handling interference properly in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'According to the passage, what is the consequence of not handling interference properly in a database system?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001209	How does the passage describe the impact of interference on the consistency of a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the passage describe the impact of interference on the consistency of a database system?'  
C001500012	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	4) Anàlisi inconsistent (i el cas particular dels fantasmes). Els tres tipus d'interferències anteriors es produeixen respecte a una única dada de la BD, és a dir, s'esdevenen quan dues transaccions intenten accedir a un mateix ítem de dades i, com a mínim, una de les dues transaccions modifiquen aquest ítem de dades. Però també hi pot haver interferències respecte a la visió que dues transaccions tenen d'un conjunt de dades que estan interrelacionades. Això pot passar, per exemple, quan una transacció T1 llegeix unes dades mentre que una altra T2 n'actualitza una part. T1 pot obtenir un estat de les dades incorrecte, com succeeix amb les transaccions següents: Els saldos que llegeix T1 no són correctes. No es corresponen ni als d'abans de la transferència entre els dos comptes ni als de després, sinó a un estat intermedi de T2 que no s'hauria d'haver vist mai fora de l'àmbit de T2. En conseqüència, T1 ha vist interferida l'execució per T2. Un cas particular força freqüent d'aquesta interferència són els fantasmes. Aquesta interferència es pot produir quan una transacció llegeix un conjunt de dades relacionat i hi ha una altra transacció que dinàmicament li canvia aquest conjunt de dades d'interès, afegint-hi dades noves. Bàsicament, la interferència ocorre quan es produeix la seqüència d'esdeveniments següent: • Una transacció T1 llegeix una sèrie de dades que compleixen una condició C determinada. • Una transacció T2 insereix noves dades que compleixen la condició C, o bé, actualitza dades que no satisfeien la condició C i que ara sí que ho fan. • La transacció T1 torna a llegir les dades que satisfan la condició C o bé alguna informació que depèn d'aquestes dades. La conseqüència d'això és que T1 veu l'execució interferida per T2 i troba un fantasma, és a dir, unes dades que abans no complien la condició i ara sí que ho fan. O, també, podria passar que T1 no veiés el fantasma directament, sinó l'efecte que té en altres dades, tal com mostren els exemples següents:	C00150001210	In what ways can interference be handled or prevented in a database system, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'In what ways can interference be handled or prevented in a database system, according to the passage?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001301	What is the issue described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the issue described in the paragraph?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001302	What is the example given in the paragraph to illustrate the issue?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the example given in the paragraph to illustrate the issue?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001303	How does the issue affect the balance of the accounts involved?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How does the issue affect the balance of the accounts involved?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001304	Why is the account 4 considered a ghost according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Why is the account 4 considered a ghost according to the paragraph?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001305	What is the effect of the interference between transactions on the balance of the accounts involved?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the effect of the interference between transactions on the balance of the accounts involved?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001306	Can you explain why the account 4 is a ghost from T1's perspective?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'Can you explain why the account 4 is a ghost from T1's perspective?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001307	How would isolating T1 correctly prevent the issue described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How would isolating T1 correctly prevent the issue described in the paragraph?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001308	In the second example given in the paragraph, what causes the ghost to appear?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'In the second example given in the paragraph, what causes the ghost to appear?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001309	How do the locations of the owners of the accounts 1, 2, and 3 relate to the issue described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'How do the locations of the owners of the accounts 1, 2, and 3 relate to the issue described in the paragraph?'  
C001500013	Gestio╠ü de transaccions	3. Interferències entre transaccions	synthetic_question	En aquest primer exemple, el compte 4 és un fantasma des del punt de vista de T1. Encara més, T1 veu l'efecte que té en la suma de saldos que es produeix i que, des del seu punt de vista, dóna un resultat incoherent. Si T1 hagués estat aïllada correctament de la transacció T2, un cop executada la primera consulta, mai no hauria d'haver trobat les dades corresponents al compte 4. Finalment, l'exemple següent mostra un fantasma que es produeix a conseqüència d'una actualització de dades per part de la transacció T2. Imaginem que els propietaris dels comptes 1 i 2 viuen a Barcelona; els propietaris del compte 3 resideixen a Madrid, i els titulars del compte 4 que vivien a Tarragona notifiquen que ara residiran a Barcelona. En l'exemple previ, novament, el compte 4 és un fantasma des del punt de	C00150001310	What is the conclusion reached at the end of the paragraph regarding the issue?	passage: document 'Gestio╠ü de transaccions'; paragraph: '3. Interferències entre transaccions'; content: 'What is the conclusion reached at the end of the paragraph regarding the issue?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001401	What are two ways an SGBD can resolve problems caused by interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'What are two ways an SGBD can resolve problems caused by interference between transactions?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001402	What is the objective of an SGBD regarding transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'What is the objective of an SGBD regarding transaction management?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001403	How does an SGBD aim to minimize negative effects on performance caused by interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'How does an SGBD aim to minimize negative effects on performance caused by interference between transactions?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001404	"What is the meaning of ""nivell de concurrència"" in the context of SGBD?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'What is the meaning of ""nivell de concurrència"" in the context of SGBD?'  "
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001405	Why is it challenging to achieve the optimal level of concurrency in SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'Why is it challenging to achieve the optimal level of concurrency in SGBD?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001406	How do suspending the execution of transactions temporarily and canceling them affect the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'How do suspending the execution of transactions temporarily and canceling them affect the database?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001407	"What is the difference between ""feina efectiva"" and ""feina realment útil"" in the context of SGBD?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'What is the difference between ""feina efectiva"" and ""feina realment útil"" in the context of SGBD?'  "
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001408	How does an SGBD determine which transactions should be prioritized over others?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'How does an SGBD determine which transactions should be prioritized over others?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001409	What is the main goal of an SGBD when managing transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'What is the main goal of an SGBD when managing transactions?'  
C001500014	Gestio╠ü de transaccions	vista de la transacció T1. 4. Nivell de concurrència	synthetic_question	Un SGBD pot resoldre els problemes d'interferències entre transaccions que hem vist anteriorment de dues maneres: 1) Cancel·lar automàticament (abort) les transaccions problemàtiques i desfer els canvis que han pogut produir sobre la BD. 2) Suspendre l'execució d'una les transaccions problemàtiques temporalment i reprendre-la quan hagi desaparegut el perill d'interferència. En alguns casos, aquesta situació també pot comportar la cancel·lació de transaccions. Totes dues solucions impliquen un cost en termes de disminució del rendiment de la BD. Precisament, a l'efecte de gestió de transaccions, un dels objectius dels SGBD és minimitzar aquests efectes negatius. S'anomena nivelldeconcurrència el grau d'aprofitament dels recursos de procés disponibles, segons l'encavalcament de l'execució de les transaccions que accedeixen concurrentment a la BD i es confirmen. L'objectiu de l'SGBD és augmentar la feina efectiva (és a dir, la feina realment útil per als usuaris) efectuada per unitat de temps. Sens dubte, les transaccions que suspenen la seva execució no fan feina efectiva i encara menys ho fan les transaccions que finalment cancel·len l'execució. Un dels grans reptes de la gestió de transaccions és assolir el nivell de concurrència adequat. Això s'aconsegueix intentant que no es produeixin cancel·lacions o suspensions d'execució de les transaccions quan no és realment necessari per a impedir una interferència. Malauradament, aquest objectiu mai no se satisfà del tot, ja que implicaria un esforç excessiu i seria perjudicial per al rendiment global per altres motius. Els SGBD intenten obtenir un compromís òptim entre el nivell de concurrència que permeten i el cost que això comporta en termes de tasques de control.	C00150001410	In what way(s) can an SGBD improve the work effectiveness of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'vista de la transacció T1. 4. Nivell de concurrència'; content: 'In what way(s) can an SGBD improve the work effectiveness of transactions?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001501	What is the main purpose of defining seriabilidad and recoverability criteria according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'What is the main purpose of defining seriabilidad and recoverability criteria according to the paragraph?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001502	How do the criteria of seriabilidad ensure that transactions are isolated from each other correctly?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'How do the criteria of seriabilidad ensure that transactions are isolated from each other correctly?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001503	Can you explain the difference between seriabilidad and recoverability in the context of transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'Can you explain the difference between seriabilidad and recoverability in the context of transaction management?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001504	According to the paragraph, what assumptions does the theory of seriabilidad make about transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'According to the paragraph, what assumptions does the theory of seriabilidad make about transactions?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001505	How might ignoring the possibility of transaction cancellations affect the accuracy of the results in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'How might ignoring the possibility of transaction cancellations affect the accuracy of the results in a database system?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001506	In what ways could the theory of recoverability provide additional criteria to avoid interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'In what ways could the theory of recoverability provide additional criteria to avoid interference between transactions?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001507	Can you give an example of how the principles of seriabilidad and recoverability might be applied in a real-world scenario?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'Can you give an example of how the principles of seriabilidad and recoverability might be applied in a real-world scenario?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001508	How do the concepts of seriabilidad and recoverability relate to the overall goal of ensuring data consistency and integrity in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'How do the concepts of seriabilidad and recoverability relate to the overall goal of ensuring data consistency and integrity in a database system?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001509	What implications might the use of seriabilidad and recoverability have on the performance and efficiency of a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'What implications might the use of seriabilidad and recoverability have on the performance and efficiency of a database system?'  
C001500015	Gestio╠ü de transaccions	5. Fonaments teòrics: seriabilitat i recuperabilitat	synthetic_question	Abans de descriure les tècniques que els SGBD poden implementar per a evitar les interferències que hem presentat anteriorment, cal definir d'una manera precisa els criteris que, des d'un punt de vista teòric, s'han de complir per a considerar que les transaccions estan aïllades entre elles correctament. Aquests criteris queden recollits dins la teoria de la seriabilitat i de la recuperabilitat. La seriabilitat assumeix que totes les transaccions confirmen els resultats. Per tant, la seriabilitat ens dóna els criteris que s'han de complir per garantir que no es produeixen interferències entre les transaccions quan aquestes confirmen els resultats. En altres paraules, la seriabilitat ignora la possibilitat que es puguin produir cancel·lacions de les transaccions. Per la seva banda, la teoria de la recuperabilitat ens dóna els criteris addicionals que s'han de complir per a evitar interferències en cas que es puguin produir cancel·lacions de les transaccions.	C00150001510	How might the implementation of seriabilidad and recoverability vary depending on the specific requirements and constraints of a given database application?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5. Fonaments teòrics: seriabilitat i recuperabilitat'; content: 'How might the implementation of seriabilidad and recoverability vary depending on the specific requirements and constraints of a given database application?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001601	What are the two types of actions (or operations) considered in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'What are the two types of actions (or operations) considered in transaction management?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001602	What is the symbol used to represent reading (lectura) an elemental data in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'What is the symbol used to represent reading (lectura) an elemental data in transaction management?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001603	What is the symbol used to represent writing (escritura) an elemental data in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'What is the symbol used to represent writing (escritura) an elemental data in transaction management?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001604	What are the elementary data units upon which transactions operate, according to the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'What are the elementary data units upon which transactions operate, according to the given paragraph?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001605	Can you identify the term used to describe the action of reading elemental data in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'Can you identify the term used to describe the action of reading elemental data in transaction management?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001606	Can you identify the term used to describe the action of writing elemental data in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'Can you identify the term used to describe the action of writing elemental data in transaction management?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001607	According to the paragraph, what type of data are involved in transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'According to the paragraph, what type of data are involved in transactions?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001608	How do transactions involve elemental data, as described in the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'How do transactions involve elemental data, as described in the given paragraph?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001609	In transaction management, what is the purpose of considering seriabilitat?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'In transaction management, what is the purpose of considering seriabilitat?'  
C001500016	Gestio╠ü de transaccions	5.1. Seriabilitat	synthetic_question	La seriabilitat considera que les transaccions són formades per dos tipus molt senzills d'accions (o operacions) sobre dades elementals. Aquestes accions són operacions de lectura (simbolitzades R(G), en què G designa la dada elemental que s'està llegint) i d'escriptura (representades W(G)). Aquestes dades elementals sobre les quals actuen les operacions de lectura i d'escriptura s'anomenen grànuls.	C00150001610	"What does the term ""grànuls"" refer to in the context of transaction management, according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '5.1. Seriabilitat'; content: 'What does the term ""grànuls"" refer to in the context of transaction management, according to the given paragraph?'  "
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001701	What is the main purpose of the operations described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'What is the main purpose of the operations described in the paragraph?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001702	According to the paragraph, which actions are executed when a SELECT statement is issued?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'According to the paragraph, which actions are executed when a SELECT statement is issued?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001703	How does the execution of INSERT, DELETE, and UPDATE statements differ, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'How does the execution of INSERT, DELETE, and UPDATE statements differ, according to the paragraph?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001704	"What is the meaning of ""grànul"" in the context of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'What is the meaning of ""grànul"" in the context of the paragraph?'  "
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001705	Can you identify the type of data control used by the SGBD, as mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'Can you identify the type of data control used by the SGBD, as mentioned in the paragraph?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001706	What is the relationship between the operations of READ (R) and WRITE (W), as stated in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'What is the relationship between the operations of READ (R) and WRITE (W), as stated in the paragraph?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001707	In what way do the actions of READ and WRITE affect the granules, as described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'In what way do the actions of READ and WRITE affect the granules, as described in the paragraph?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001708	How does the paragraph describe the effect of concurrent access to the database on the granules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'How does the paragraph describe the effect of concurrent access to the database on the granules?'  
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001709	"Based on the paragraph, what is the significance of the term ""SGBD"" in the context of database management?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'Based on the paragraph, what is the significance of the term ""SGBD"" in the context of database management?'  "
C001500017	Gestio╠ü de transaccions	Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).	synthetic_question	Per la seva banda, les operacions d'INSERT, DELETE i UPDATE desencadenen l'execució d'accions de lectura (R(G)) seguides d'accions d'escriptura (W(G)). Un grànul és la unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència.	C00150001710	In summary, what is the primary focus of the paragraph, and what key points does it convey about database management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Execució d'accions de lectura i d'escriptura.  Les operacions de SELECT desencadenen l'execució d'accions de lectura (R(G)).'; content: 'In summary, what is the primary focus of the paragraph, and what key points does it convey about database management?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001801	What is the main topic discussed in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'What is the main topic discussed in the paragraph?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001802	According to the passage, what are the two types of operations that can be performed during the finalization of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'According to the passage, what are the two types of operations that can be performed during the finalization of transactions?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001803	How does the granularity level affect the probability of interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'How does the granularity level affect the probability of interference between transactions?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001804	What is the advantage of using a finer granularity level in an SQL database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'What is the advantage of using a finer granularity level in an SQL database?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001805	What is the potential drawback of using a finer granularity level in an SQL database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'What is the potential drawback of using a finer granularity level in an SQL database?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001806	How does the overhead of an SQL database increase or decrease depending on the granularity level used?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'How does the overhead of an SQL database increase or decrease depending on the granularity level used?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001807	"Can you explain the term ""overhead"" as it relates to an SQL database?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'Can you explain the term ""overhead"" as it relates to an SQL database?'  "
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001808	In which situations might it be beneficial to use a coarser granularity level in an SQL database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'In which situations might it be beneficial to use a coarser granularity level in an SQL database?'  
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001809	"How do the concepts of ""COMMIT"" and ""ROLLBACK"" relate to the finalization of transactions?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'How do the concepts of ""COMMIT"" and ""ROLLBACK"" relate to the finalization of transactions?'  "
C001500018	Gestio╠ü de transaccions	Finalització de les transaccions	synthetic_question	També considerarem accions les operacions de finalització de les transaccions, és a dir, les operacions de COMMIT i ROLLBACK. La mida del grànul pot variar segons l'SGBD. Les mides de grànul més freqüents són la pàgina (o bloc) de disc i el registre (o fila) d'una taula. Hi ha altres possibilitats, per exemple, que el grànul sigui una taula sencera de la BD. De fet, en general, un mateix SGBD és capaç de treballar amb diferents nivells de granularitat (fila, pàgina, taula etc.), segons les demandes dels usuaris de la BD. Potencialment, com més fina és la granularitat, més alt és el nivell de concurrència que es pot assolir, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul disminueix. Com a desavantatge d'això, la sobrecàrrega (en anglès, overhead) de l'SGBD serà més gran, atès que caldrà executar més accions i s'hauran de mantenir moltes més dades de control per a garantir l'aïllament correcte de les transaccions. Per contra, com més basta és la granularitat, més alt és el risc que es puguin produir problemes d'interferències, ja que la probabilitat que dues transaccions vulguin accedir a un mateix grànul augmenta. Com a avantatge d'això, la sobrecàrrega de l'SGBD serà més petita, atès que caldrà executar menys accions i s'hauran de mantenir menys dades de control per a garantir l'aïllament correcte de les transaccions. Partint d'aquesta versió simplificada de les transaccions, l'execució concurrent d'un conjunt de transaccions (en què es preserva l'ordre d'accions dins de cada transacció) rep el nom d'horari o història.	C00150001810	"What is the purpose of the ""historia"" or ""horario"" mentioned in the passage?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Finalització de les transaccions'; content: 'What is the purpose of the ""historia"" or ""horario"" mentioned in the passage?'  "
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001901	What are the two transactions (T1 and T2) that need to execute actions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'What are the two transactions (T1 and T2) that need to execute actions?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001902	What is the purpose of the two transactions (T1 and T2)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'What is the purpose of the two transactions (T1 and T2)?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001903	What is the possible schedule for T1 and T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'What is the possible schedule for T1 and T2?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001904	How do the actions executed by T1 and T2 differ?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'How do the actions executed by T1 and T2 differ?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001905	When should T1 and T2 be executed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'When should T1 and T2 be executed?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001906	What is the outcome of executing T1 and T2 according to the given example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'What is the outcome of executing T1 and T2 according to the given example?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001907	Can T1 and T2 be executed simultaneously?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'Can T1 and T2 be executed simultaneously?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001908	Is there any specific order required for executing T1 and T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'Is there any specific order required for executing T1 and T2?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001909	Are there any prerequisites or dependencies for executing T1 and T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'Are there any prerequisites or dependencies for executing T1 and T2?'  
C001500019	Gestio╠ü de transaccions	Exemple d'horari	synthetic_question	Donades dues transaccions T1 i T2 que volen executar les accions següents: Un horari possible per a T1 i T2 podria ser:	C00150001910	How does the proposed schedule for T1 and T2 align with the overall goals of the transaction management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari'; content: 'How does the proposed schedule for T1 and T2 align with the overall goals of the transaction management system?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002001	What is the main topic discussed in this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the main topic discussed in this paragraph?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002002	According to the paragraph, what is the definition of an horizon series?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'According to the paragraph, what is the definition of an horizon series?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002003	How many possible horarios en serie are there for a set of n transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How many possible horarios en serie are there for a set of n transactions?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002004	Can interference occur between actions of different transactions in an horizon series?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can interference occur between actions of different transactions in an horizon series?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002005	Is it explicitly stated in the paragraph that there will be no encavalcment between the actions of the transactions involved in an horizon series?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Is it explicitly stated in the paragraph that there will be no encavalcment between the actions of the transactions involved in an horizon series?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002006	What is the purpose of discussing horizon series in this module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of discussing horizon series in this module?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002007	In which situation might it be relevant to use horizon series in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'In which situation might it be relevant to use horizon series in transaction management?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002008	How does the number of possible horarios en serie depend on the number of transactions involved?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the number of possible horarios en serie depend on the number of transactions involved?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002009	Does the paragraph provide any examples or illustrations of how horizon series work in practice?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Does the paragraph provide any examples or illustrations of how horizon series work in practice?'  
C001500020	Gestio╠ü de transaccions	Nota	synthetic_question	En aquest mòdul didàctic i mentre no es digui explícitament el contrari, treballarem amb grànuls d'una mida equivalent a la pàgina. Un horariensèrie és un horari en què no hi ha encavalcament entre les accions de les transaccions implicades. Els horaris en sèrie mai no tenen interferències. Donat un conjunt de n transaccions, tindrem n! horaris en sèrie possibles.	C00150002010	What is the key takeaway message regarding horizon series from this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the key takeaway message regarding horizon series from this paragraph?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002101	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'What is the purpose of the example given in the paragraph?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002102	How many horarios en serie are mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'How many horarios en serie are mentioned in the paragraph?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002103	What is the difference between the values of the granul A recovered by T1 in each horizon?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'What is the difference between the values of the granul A recovered by T1 in each horizon?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002104	Why do the situations of conflict appear only when the transactions act on the same grain?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'Why do the situations of conflict appear only when the transactions act on the same grain?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002105	"Can you explain the meaning of ""no commutative"" actions in the context of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'Can you explain the meaning of ""no commutative"" actions in the context of the paragraph?'  "
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002106	In which cases does the order of execution of non-commutative actions matter?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'In which cases does the order of execution of non-commutative actions matter?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002107	What is the relationship between the two horarios en serie mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'What is the relationship between the two horarios en serie mentioned in the paragraph?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002108	How does the value of the granul A recovered by T1 change in each horizon?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'How does the value of the granul A recovered by T1 change in each horizon?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002109	Can you give an example of a situation where the order of execution of non-commutative actions matters?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'Can you give an example of a situation where the order of execution of non-commutative actions matters?'  
C001500021	Gestio╠ü de transaccions	Exemple d'horaris en sèrie	synthetic_question	Les transaccions T1 i T2 de l'exemple anterior tindran associats dos horaris en sèrie (n = 2, 2! = 2), que, d'una manera simplificada, designem T1; T2 i T2; T1. En forma de taula, cadascun d'aquests horaris quedaria de la manera següent: Cal destacar que els horaris en sèrie previs produeixen resultats diferents. En concret, el valor del grànul A que recupera T1 en fer l'acció R(A) és diferent en cada horari. En el cas del primer horari, T1 recupera (acció número 1) el valor de A que hi ha en la BD abans que T2 faci el canvi (acció número 6). En el cas del segon horari en sèrie, T1 recupera (acció número 4) com a valor de A el que deixa T2 (acció número 2). En un horari, dues accions es consideren conflictives (o nocommutables) si pertanyen a transaccions diferents, i l'ordre en què s'executen aquestes accions pot afectar el valor del grànul que hagi llegit una de les transaccions o el valor final del grànul. Les situacions de conflicte entre transaccions només poden aparèixer quan les transaccions actuen (com a mínim) sobre un mateix grànul, i almenys una de les dues accions és una acció d'escriptura.	C00150002110	According to the paragraph, what is the main difference between the first and second horarios en serie?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horaris en sèrie'; content: 'According to the paragraph, what is the main difference between the first and second horarios en serie?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002201	What are the two types of actions described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'What are the two types of actions described in the paragraph?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002202	How do conflicting actions differ from non-conflicting actions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'How do conflicting actions differ from non-conflicting actions?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002203	What is the criteria for determining if an action is conflictive or not?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'What is the criteria for determining if an action is conflictive or not?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002204	"Can you explain the concept of ""seriabilitat de conflictes""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'Can you explain the concept of ""seriabilitat de conflictes""?'  "
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002205	How does the seriability of conflicts relate to the correctness of an horizon?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'How does the seriability of conflicts relate to the correctness of an horizon?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002206	What is the purpose of considering the order of conflicting actions relative to each other?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'What is the purpose of considering the order of conflicting actions relative to each other?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002207	Why is it important to ensure that all conflicting actions have the same order in an horizon?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'Why is it important to ensure that all conflicting actions have the same order in an horizon?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002208	Can you provide an example of a situation where conflicting actions would produce different results without being in the same horizon?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'Can you provide an example of a situation where conflicting actions would produce different results without being in the same horizon?'  
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002209	"How does the concept of ""horari equivalent"" apply to serializability?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'How does the concept of ""horari equivalent"" apply to serializability?'  "
C001500022	Gestio╠ü de transaccions	Exemples d'accions conflictives i no conflictives	synthetic_question	Donades les dues transaccions T1 i T2 d'exemple i l'horari següents: Les accions número 1 i número 4 són accions conflictives, el valor recuperat per T1 per al grànul A serà diferent segons si la lectura s'executa abans o després que l'escriptura realitzada per T2. En canvi, les accions 1 i 2, per exemple, no són conflictives, encara que treballin sobre el mateix grànul, ja que són dues accions de lectura. D'una manera similar, les accions 4 i 5, per exemple, tampoc no són conflictives, encara que una d'aquestes (l'acció número 4) sigui una escriptura, atès que les accions operen sobre grànuls diferents. Un horari es considera correcte –és a dir, senseinterferències– quan l'ordre relatiu de tots els parells d'accions conflictives és el mateix que en algun horari en sèrie. Els horaris correctes s'anomenen horarisseriables i sempre produeixen el mateix resultat que algun horari en sèrie. Aquest horari en sèrie que dóna resultats equivalents es coneix per horariensèrieequivalent. El criteri que acabem de presentar, anomenat seriabilitatdeconflictes, ens indica les condicions precises que ha de tenir un horari per a poder-lo considerar correcte, suposant que totes les transaccions confirmen els seus resultats. La idea darrera d'aquest criteri és força simple. Els horaris en sèrie (sense encavalcaments de les operacions efectuades per les transaccions) per definició no presenten interferències, atès que no treballen amb valors provisionals deixats	C00150002210	In what way does the criterion of seriability of conflicts simplify the analysis of transactional systems?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'accions conflictives i no conflictives'; content: 'In what way does the criterion of seriability of conflicts simplify the analysis of transactional systems?'  
C001500023	Gestio╠ü de transaccions	Seriabilitat d'un horari	synthetic_question	A vegades, un horari seriable pot tenir associats diversos horaris en sèrie equivalents. Naturalment, els horaris en sèrie són també seriables. per altres transaccions. Si tenim un horari H amb encavalcaments que dóna els mateixos resultats que un horari sense encavalcaments HS (és a dir, que un horari en sèrie), podrem afirmar que l'horari H és correcte i que, en conseqüència, no té interferències. Encara més, podrem afirmar que l'horari HS és un horari en sèrie equivalent (HSE) a l'horari H.	C00150002301	What is the main idea of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Seriabilitat d'un horari'; content: 'What is the main idea of the paragraph?'  
C001500023	Gestio╠ü de transaccions	Seriabilitat d'un horari	synthetic_question	A vegades, un horari seriable pot tenir associats diversos horaris en sèrie equivalents. Naturalment, els horaris en sèrie són també seriables. per altres transaccions. Si tenim un horari H amb encavalcaments que dóna els mateixos resultats que un horari sense encavalcaments HS (és a dir, que un horari en sèrie), podrem afirmar que l'horari H és correcte i que, en conseqüència, no té interferències. Encara més, podrem afirmar que l'horari HS és un horari en sèrie equivalent (HSE) a l'horari H.	C00150002302	According to the paragraph, what is an example of a seriable schedule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Seriabilitat d'un horari'; content: 'According to the paragraph, what is an example of a seriable schedule?'  
C001500023	Gestio╠ü de transaccions	Seriabilitat d'un horari	synthetic_question	A vegades, un horari seriable pot tenir associats diversos horaris en sèrie equivalents. Naturalment, els horaris en sèrie són també seriables. per altres transaccions. Si tenim un horari H amb encavalcaments que dóna els mateixos resultats que un horari sense encavalcaments HS (és a dir, que un horari en sèrie), podrem afirmar que l'horari H és correcte i que, en conseqüència, no té interferències. Encara més, podrem afirmar que l'horari HS és un horari en sèrie equivalent (HSE) a l'horari H.	C00150002303	"How do the author's statements about ""horaris en sèrie"" relate to the topic of this document?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Seriabilitat d'un horari'; content: 'How do the author's statements about ""horaris en sèrie"" relate to the topic of this document?'  "
C001500023	Gestio╠ü de transaccions	Seriabilitat d'un horari	synthetic_question	A vegades, un horari seriable pot tenir associats diversos horaris en sèrie equivalents. Naturalment, els horaris en sèrie són també seriables. per altres transaccions. Si tenim un horari H amb encavalcaments que dóna els mateixos resultats que un horari sense encavalcaments HS (és a dir, que un horari en sèrie), podrem afirmar que l'horari H és correcte i que, en conseqüència, no té interferències. Encara més, podrem afirmar que l'horari HS és un horari en sèrie equivalent (HSE) a l'horari H.	C00150002304	"Can you explain the difference between an ""horari seriable"" and an ""horari en sèrie""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Seriabilitat d'un horari'; content: 'Can you explain the difference between an ""horari seriable"" and an ""horari en sèrie""?'  "
C001500023	Gestio╠ü de transaccions	Seriabilitat d'un horari	synthetic_question	A vegades, un horari seriable pot tenir associats diversos horaris en sèrie equivalents. Naturalment, els horaris en sèrie són també seriables. per altres transaccions. Si tenim un horari H amb encavalcaments que dóna els mateixos resultats que un horari sense encavalcaments HS (és a dir, que un horari en sèrie), podrem afirmar que l'horari H és correcte i que, en conseqüència, no té interferències. Encara més, podrem afirmar que l'horari HS és un horari en sèrie equivalent (HSE) a l'horari H.	C00150002305	"In what context might it be important to determine whether an hour is ""correct"" or not?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Seriabilitat d'un horari'; content: 'In what context might it be important to determine whether an hour is ""correct"" or not?'  "
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002401	What is the purpose of the graph of precedences in the example of serializable schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'What is the purpose of the graph of precedences in the example of serializable schedules?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002402	How does the graph of precedences help find serializable schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'How does the graph of precedences help find serializable schedules?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002403	What is an acyclic graph, and how does it relate to serializable schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'What is an acyclic graph, and how does it relate to serializable schedules?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002404	In the example of serializable schedules, what is the relationship between the transactions T1 and T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'In the example of serializable schedules, what is the relationship between the transactions T1 and T2?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002405	How do the actions of transactions T1 and T2 conflict in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'How do the actions of transactions T1 and T2 conflict in the example?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002406	"What is the meaning of ""granularity"" in the context of the graph of precedences?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'What is the meaning of ""granularity"" in the context of the graph of precedences?'  "
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002407	How does the elimination of nodes from the graph of precedences help find serializable schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'How does the elimination of nodes from the graph of precedences help find serializable schedules?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002408	"Can you explain the concept of ""interferences"" in the context of the graph of precedences?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'Can you explain the concept of ""interferences"" in the context of the graph of precedences?'  "
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002409	How do serializable schedules differ from non-serializable schedules in terms of the graph of precedences?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'How do serializable schedules differ from non-serializable schedules in terms of the graph of precedences?'  
C001500024	Gestio╠ü de transaccions	Exemple d'horari seriable	synthetic_question	Donades les transaccions T1 i T2 d'exemple, l'horari H següent: és seriable, és a dir, correcte, sense interferències. Addicionalment, l'horari en sèrie equivalent (HSE) a l'horari H proposat seria el que vindria donat per T1; T2. Aquest HSE quedaria representat en forma de taula de la manera següent: Per a saber si un horari és seriable o si no ho és, utilitzarem el graf de precedències. El grafdeprecedències és una estructura de dades conceptual (no implementada en els SGBD) amb forma de graf dirigit etiquetat, de manera que: 1) Els nodes representen transaccions. 2) Les etiquetes dels arcs designen grànuls. 3) Els arcs indiquen les relacions de precedència establertes en l'horari, segons els parells d'accions conflictives que presenta l'horari. Més concretament, si el graf de precedències té un arc etiquetat amb un grànul G amb origen Ti i destinació Tj com el que es mostra a continuació: significa que, en l'horari, les transaccions Ti i Tj han executat un parell d'accions conflictives sobre el grànul G i, a més, en el temps, en primer lloc s'executa l'acció que realitza la transacció Ti. Els grafs de precedències associats a horaris seriables (és a dir, els horaris correctes, sense interferències) són acíclics. Per contra, els horaris amb interferències tenen cicles en el graf de precedències. Suposant que el graf de precedències associat a un horari és acíclic (horari seriable), el graf de precedències ens ajuda a trobar els horaris en sèrie equivalents. Per a trobar aquests horaris, simplement cal fer un recorregut del graf (basat en ordenació topològica), de la manera següent: 1) Escollir un node del graf on no arribi cap arc i apuntar la transacció que s'hi representa. 2) Eliminar el node del graf i tots els arcs que tenen com a origen aquest node. Els passos 1 i 2 s'han de repetir fins que el graf de precedències estigui buit.	C00150002410	What is the main idea behind using the graph of precedences to determine serializability of schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari seriable'; content: 'What is the main idea behind using the graph of precedences to determine serializability of schedules?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002501	What is the purpose of the example given in the paragraph about transactions T1 and T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'What is the purpose of the example given in the paragraph about transactions T1 and T2?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002502	According to the graph of precedences, which transaction should be executed first when both T1 and T2 have actions that can be executed simultaneously?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'According to the graph of precedences, which transaction should be executed first when both T1 and T2 have actions that can be executed simultaneously?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002503	Why does the graph of precedences have an arc between T1 and T2 but not between T1 and T3 or T2 and T4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Why does the graph of precedences have an arc between T1 and T2 but not between T1 and T3 or T2 and T4?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002504	How would you describe the relationship between the horizon H and the graph of precedences associated with it?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'How would you describe the relationship between the horizon H and the graph of precedences associated with it?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002505	Can you explain why the graph of precedences is acyclic?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Can you explain why the graph of precedences is acyclic?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002506	If we assume that all four transactions (T1, T2, T3, and T4) occur concurrently, how would the graph of precedences change?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'If we assume that all four transactions (T1, T2, T3, and T4) occur concurrently, how would the graph of precedences change?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002507	Based on the provided paragraph content, what is the difference between the horizon H and the horizon HSE?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Based on the provided paragraph content, what is the difference between the horizon H and the horizon HSE?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002508	"In the last sentence of the paragraph, what does the author mean by ""un altre arc idèntic""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'In the last sentence of the paragraph, what does the author mean by ""un altre arc idèntic""?'  "
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002509	How does the order of transactions in the graph of precedences affect the outcome of the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'How does the order of transactions in the graph of precedences affect the outcome of the system?'  
C001500025	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	Donades les transaccions T1 i T2 d'exemple i l'horari H següent: El graf de precedències associat a l'horari H és el següent: Atès que l'única parella d'accions conflictives que executen les transaccions T1 i T2 són les accions número 1 i número 4 i, seguint l'ordre, de primer s'executa l'acció efectuada per la transacció T1; això dóna lloc a un arc (etiquetat amb el grànul A) en el graf de precedències amb origen T1 i destinació T2. Com que el graf de precedències és acíclic, podem afirmar que l'horari H és seriable (sense interferències) i com a mínim hi ha un HSE que dóna els mateixos resultats que l'horari H. Si fem un recorregut basat en ordenació topològica del graf de precedències, el node que representa la transacció T1 és l'únic on no arriba cap arc. Aquesta transacció serà la primera en l'horari en sèrie equivalent HSE associat a l'horari H. Eliminem del graf de precedències el node que representa T1 i els arcs que surten d'aquest node. Ens quedem amb un graf de precedències que només té un node que representa la transacció T2: Si continuem amb el procediment descrit, ara només podem escollir el node que correspon a T2. Eliminem el node i el graf queda buit. Per tant, l'horari seriable H té com a horari en sèrie equivalent HSE T1;T2. Suposem ara que tenim quatre transaccions (T1, T2, T3 i T4) i que es produeix l'horari H següent: El graf de precedències associat a l'horari H és el que es mostra a continuació: Els arcs corresponen a les parelles d'accions conflictives següents: • Arc entre T1 i T2 sobre A: accions número 2 i número 3. • Arc entre T1 i T3 sobre A: correspon a les accions 2 i 4. També podria correspondre a la parella d'accions 2 i 12, que donaria lloc a un altre arc idèntic. Un mateix arc (és a dir, node origen i destinació idèntic, i etiqueta igual) només s'introduirà un cop al graf de precedències, ja que no aporta informació nova.	C00150002510	Can you provide an example of a situation where the graph of precedences might not accurately reflect the actual behavior of the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Can you provide an example of a situation where the graph of precedences might not accurately reflect the actual behavior of the system?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002601	What are the two HSEs associated with the seriable horizon H in the graph of precedences?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'What are the two HSEs associated with the seriable horizon H in the graph of precedences?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002602	Why do we have two HSEs in this case?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Why do we have two HSEs in this case?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002603	Which transactions access different granules of the BD, leading to the presence of multiple HSEs?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Which transactions access different granules of the BD, leading to the presence of multiple HSEs?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002604	Can you describe the possible interference scenarios and their corresponding horizons in this example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'Can you describe the possible interference scenarios and their corresponding horizons in this example?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002605	How does the lack of conflicts between transactions T2 and T3 contribute to the existence of multiple HSEs?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'How does the lack of conflicts between transactions T2 and T3 contribute to the existence of multiple HSEs?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002606	In what way is the graph of precedences acicular in this case?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'In what way is the graph of precedences acicular in this case?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002607	How does the ordering of the graph of precedences affect the determination of the seriable horizon H?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'How does the ordering of the graph of precedences affect the determination of the seriable horizon H?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002608	What is the purpose of identifying HSEs in the context of transaction scheduling?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'What is the purpose of identifying HSEs in the context of transaction scheduling?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002609	How might understanding the concept of HSEs help in resolving potential interferences between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'How might understanding the concept of HSEs help in resolving potential interferences between transactions?'  
C001500026	Gestio╠ü de transaccions	Exemples d'horaris seriables i els grafs de precedències corresponents	synthetic_question	• Arc entre T2 i T4 sobre B: accions número 8 i número 9. • Arc entre T3 i T4: accions número 6 i número 10. Com que el graf de precedències és acíclic, l'horari H és seriable i ha de tenir associat algun HSE. Fent el recorregut basat en ordenació topològica del graf de precedències, trobem dos HSE. HSE 1: T1; T2; T3; T4 HSE 2: T1; T3; T2; T4 El motiu pel qual hi ha dos HSE està relacionat amb el fet que les transaccions T2 i T3 accedeixen a grànuls diferents de la BD i, per tant, no hi ha cap parella d'accions conflictives entre elles. Per finalitzar aquest subapartat, a continuació es mostren possibles horaris (i els grafs de precedències associats) que corresponen a les interferències que hem estudiat anteriorment: 1)Actualitzacióperduda. Un possible horari per a aquesta interferència és el següent: el següent:	C00150002610	In what ways could knowledge of HSEs inform the design of more efficient transaction scheduling algorithms?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'horaris seriables i els grafs de precedències corresponents'; content: 'In what ways could knowledge of HSEs inform the design of more efficient transaction scheduling algorithms?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002701	What is the issue described in the paragraph related to transactional consistency?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the issue described in the paragraph related to transactional consistency?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002702	How do the transactions T1 and T2 interact with each other according to the graph shown in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How do the transactions T1 and T2 interact with each other according to the graph shown in the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002703	What is the effect of T1's action number 3 on the grid, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the effect of T1's action number 3 on the grid, according to the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002704	Why does T1's change not stick even though it confirms results, as stated in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Why does T1's change not stick even though it confirms results, as stated in the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002705	What is the difference between T1 and T2's behavior regarding the value left in the grid, as mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the difference between T1 and T2's behavior regarding the value left in the grid, as mentioned in the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002706	Can you explain why this issue would never occur in a serializable horizon, as suggested in the last sentence of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you explain why this issue would never occur in a serializable horizon, as suggested in the last sentence of the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002707	According to the graph shown in the paragraph, what is the order of events for T1 and T2's actions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'According to the graph shown in the paragraph, what is the order of events for T1 and T2's actions?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002708	How does the proposed solution address the issue described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the proposed solution address the issue described in the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002709	In which part of the module did the study of interference between transactions take place, as mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In which part of the module did the study of interference between transactions take place, as mentioned in the paragraph?'  
C001500027	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat les interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Les transaccions T1 i T2 llegeixen el mateix grànul, i recuperen el mateix valor. A continuació, totes dues transaccions modifiquen el grànul. En el nostre exemple, el canvi efectuat per T1 en l'acció número 3 es perd, malgrat que T1 confirma resultats (no es compleix la propietat de definitivitat per la transacció T1; de fet, és com si T1 mai no hagués existit). El valor que finalment queda com a definitiu en la BD és el que deixa la transacció T2. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 2)Lecturanoconfirmada. Un possible horari per a aquesta interferència és el següent: La transacció T1 recupera un valor provisional, pendent de confirmació, i proposat per T2 que mai no serà definitiu sobre la BD, atès que T2 sobreescriu el valor. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació:	C00150002710	What is the name of the document being referred to in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the name of the document being referred to in the paragraph?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002801	"What is the main idea expressed in the sentence ""Els horaris seriables siempre donen el mateix resultat que algun horari en sèrie""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the main idea expressed in the sentence ""Els horaris seriables siempre donen el mateix resultat que algun horari en sèrie""?'  "
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002802	According to the paragraph, what is the common outcome of serializable schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'According to the paragraph, what is the common outcome of serializable schedules?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002803	Can you identify the type of schedule being referred to in the paragraph (e.g., meeting, event, appointment)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can you identify the type of schedule being referred to in the paragraph (e.g., meeting, event, appointment)?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002804	How does the author describe the result obtained from using serializable schedules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How does the author describe the result obtained from using serializable schedules?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002805	In which context might one encounter serializable schedules (e.g., business, education, healthcare)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'In which context might one encounter serializable schedules (e.g., business, education, healthcare)?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002806	What is the purpose of using serializable schedules, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the purpose of using serializable schedules, according to the paragraph?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002807	Does the use of serializable schedules guarantee consistent results, and if so, why?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Does the use of serializable schedules guarantee consistent results, and if so, why?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002808	Are there any limitations or drawbacks associated with relying on serializable schedules, as mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Are there any limitations or drawbacks associated with relying on serializable schedules, as mentioned in the paragraph?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002809	How do serializable schedules differ from non-serializable ones, as described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How do serializable schedules differ from non-serializable ones, as described in the paragraph?'  
C001500028	Gestio╠ü de transaccions	Recordeu	synthetic_question	Els horaris seriables sempre donen el mateix resultat que algun horari en sèrie.	C00150002810	Based on the paragraph, would you expect serializable schedules to be more or less reliable than non-serializable ones, and why?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Based on the paragraph, would you expect serializable schedules to be more or less reliable than non-serializable ones, and why?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002901	What is the name of the document being discussed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'What is the name of the document being discussed?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002902	"What is the purpose of the subsection ""Cancel·lació de les transaccions"" in the document?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'What is the purpose of the subsection ""Cancel·lació de les transaccions"" in the document?'  "
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002903	According to the passage, what is the difference between the first and second readings of the value of grànul A?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'According to the passage, what is the difference between the first and second readings of the value of grànul A?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002904	How does the theory of seriability ignore the possibility of cancellations of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'How does the theory of seriability ignore the possibility of cancellations of transactions?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002905	What is an example of an inconsistent analysis given in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'What is an example of an inconsistent analysis given in the passage?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002906	What is the relationship between interference caused by ghosts and seriability, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'What is the relationship between interference caused by ghosts and seriability, according to the passage?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002907	In the example presented in the passage, which grànuls store data for accounts 1, 2, 3, and 4, respectively?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'In the example presented in the passage, which grànuls store data for accounts 1, 2, 3, and 4, respectively?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002908	What is the equivalence of the horarium presented in the passage to a serial horizon?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'What is the equivalence of the horarium presented in the passage to a serial horizon?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002909	What is the purpose of the graph of precedences associated with the hourly schedule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'What is the purpose of the graph of precedences associated with the hourly schedule?'  
C001500029	Gestio╠ü de transaccions	Cancel·lació de les transaccions	synthetic_question	En aquest subapartat no es tracta la interferència de lectura no confirmada quan es produeix la cancel·lació d'una de les transaccions implicades. Recordeu que la teoria de la seriabilitat ignora la possibilitat de cancel·lacions de les transaccions. 3)Lecturanorepetible. Un possible horari per a aquesta interferència és el següent: La transacció T2 troba dos valors diferents per al grànul A; la primera lectura troba el valor original de A en la BD, mentre que la segona lectura troba el valor proposat per la transacció T1. Això no hauria passat mai en un horari seriable. El graf de precedències (amb un cicle sobre el grànul A) associat a l'horari és el que es mostra a continuació: 4)Anàlisiinconsistent. Un possible horari per a aquesta interferència és el següent: La transacció T1 no troba valors correctes per als grànuls A i B. En el cas del grànul B troba els valors que hi ha en la BD abans de començar l'execució de la transacció T2. En canvi, en el cas del grànul A, la transacció T1 troba els valors que proposa la transacció T2 per al grànul A. Això mai no hauria passat en un horari seriable. El graf de precedències (amb un cicle entre els grànuls A i B) associat a l'horari és el que es mostra a continuació: Si ho recordeu, entre les interferències d'anàlisi inconsistent teníem el cas particular dels fantasmes. És especialment interessant la relació entre les interferències de fantasmes i la seriabilitat. Si intentem representar d'una manera simplificada l'exemple primer que vam presentar en veure les interferències provocades per un fantasma, obtindrem: C1, C2, C3 i C4 són els grànuls que emmagatzemen les dades dels comptes 1, 2, 3 i 4, respectivament. L'horari és seriable, ja que és equivalent a un horari en sèrie en què s'executa de primer la transacció T2 i després la transacció T1. Si fem el graf de precedències veurem que és acíclic:	C00150002910	How do the interferences caused by ghosts relate to the seriability of the system, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació de les transaccions'; content: 'How do the interferences caused by ghosts relate to the seriability of the system, according to the passage?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003001	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of the example given in the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003002	What is the issue with the initial horizon presented in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the issue with the initial horizon presented in the example?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003003	How does the SGBD handle the creation of a new account (C4) in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD handle the creation of a new account (C4) in the example?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003004	What is the reason for the confusion in the initial horizon, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the reason for the confusion in the initial horizon, according to the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003005	How does the SGBD store internal information about control, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD store internal information about control, according to the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003006	What is the relationship between IC and C4 in terms of precedence, according to the graph shown in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the relationship between IC and C4 in terms of precedence, according to the graph shown in the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003007	Why is it necessary to consider all registries when satisfying a condition C, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Why is it necessary to consider all registries when satisfying a condition C, according to the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003008	What is the consequence of not considering all registries when satisfying a condition C, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the consequence of not considering all registries when satisfying a condition C, according to the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003009	How does the criterion of seriability relate to the consideration of all registries, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the criterion of seriability relate to the consideration of all registries, according to the paragraph?'  
C001500030	Gestio╠ü de transaccions	Nota	synthetic_question	En l'exemple suposem que les dades de cada compte corrent són en una pàgina diferent (recordeu que, per defecte, considerem que la mida del grànul és la pàgina). Per a crear un nou compte corrent (el compte 4), cal llegir una pàgina amb espai lliure suficient (representada pel grànul C4) i afegir el nou compte a la pàgina triada (això queda representat per l'acció W(C4) en l'exemple). A primer cop d'ull, aquest resultat és confús, ja que l'horari sembla correcte i, no obstant això, correspon a una interferència que volem impedir. L'origen d'aquesta confusió és bastant subtil. Cal tenir en compte que l'SGBD, per llegir tots els registres de la taula de comptes ha de consultar algun tipus d'informació de control interna, oculta a l'usuari, que li permeti recórrer aquests registres i saber quan ja no en queda cap més. A més a més, per a crear un nou registre cal actualitzar aquesta mateixa informació de control. Si suposem, simplificant-ho, que tota aquesta informació de control està emmagatzemada en un grànul IC, obtindrem l'horari següent, més ajustat a la realitat que l'anterior: Aquest horari no és seriable, ja que les accions sobre IC i C4 forcen relacions de precedència incompatibles entre les transaccions, tal com mostra el graf de precedències següent associat a l'horari: També cal tenir present que, sempre que una transacció demana a l'SGBD que accedeixi als registres que compleixen una condició de cerca C s'han de considerar tots els registres, incloent-hi els que finalment es vegi que no satisfan C. Això és necessari per a preveure la possibilitat que altres transaccions concurrents els actualitzin de manera que compleixin C, cosa que donaria lloc també a una interferència de tipus fantasma. Així doncs, perquè el criteri de seriabilitat, tal com s'ha descrit, sigui correcte, en els horaris s'han de considerar les accions de lectura i escriptura de tota la informació que utilitza l'SGBD per a dur a terme cerques de dades, tant si les aplicacions poden accedir a aquesta informació com si només és d'ús intern de l'SGBD.	C00150003010	What is the main point of the paragraph, in relation to the topic of seriability?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the main point of the paragraph, in relation to the topic of seriability?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003101	What is the purpose of canceling transactions in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'What is the purpose of canceling transactions in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003102	How does canceling a transaction affect the changes made to granules in the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'How does canceling a transaction affect the changes made to granules in the database?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003103	Why is seriability not considered a criterion for isolation in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'Why is seriability not considered a criterion for isolation in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003104	What is an example of an horizon that satisfies the recovery ability criterion in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'What is an example of an horizon that satisfies the recovery ability criterion in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003105	How do interferences occur when canceling transactions in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'How do interferences occur when canceling transactions in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003106	What is the difference between reading and writing granules in different transactions in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'What is the difference between reading and writing granules in different transactions in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003107	How does the recovery ability criterion ensure that there are no interferences when canceling transactions in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'How does the recovery ability criterion ensure that there are no interferences when canceling transactions in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003108	In what way does the proposed example horizon satisfy the recovery ability criterion in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'In what way does the proposed example horizon satisfy the recovery ability criterion in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003109	What would happen if a transaction Ti reads or writes a granule written by another transaction Tj without confirming it first in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'What would happen if a transaction Ti reads or writes a granule written by another transaction Tj without confirming it first in Gestioedeut de transaccions?'  
C001500031	Gestio╠ü de transaccions	5.2. Recuperabilitat	synthetic_question	Ja hem vist que algunes interferències es produeixen en cancel·lar les transaccions. Cancel·lar una transacció representa desfer-ne tots els canvis i recuperar el valor anterior que hi havia en la BD dels grànuls que ha modificat la transacció que cancel·la l'execució. Això pot provocar interferències si aquests mateixos grànuls han estat llegits o escrits per altres transaccions. La seriabilitat és un criteri d'aïllament que ignora la possibilitat que es produeixin cancel·lacions. Per tant, per evitar les interferències que provoquen, hem d'exigir noves condicions a l'execució de les transaccions. Un horari compleix el criteri de recuperabilitat si cap transacció Ti que llegeix o escriu un grànul escrit per una altra transacció Tj confirma sense que abans ho hagi fet Tj. L'horari d'exemple que proposem tot seguit no verifica el criteri de recuperabilitat:	C00150003110	How does the recovery ability criterion prevent interferences caused by canceling transactions in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '5.2. Recuperabilitat'; content: 'How does the recovery ability criterion prevent interferences caused by canceling transactions in Gestioedeut de transaccions?'  
C001500032	Gestio╠ü de transaccions	Nota	synthetic_question	En l'horari d'exemple, si T2, en comptes de cancel·lar els resultats, els hagués confirmat (executant com a acció número 5 una operació de COMMIT), la interferència de lectura no confirmada no s'hauria produït (en aquest supòsit, l'horari en sèrie equivalent seria T2;T1). Malgrat això, l'horari tampoc no verificaria el criteri de recuperabilitat, ja que T1 recupera dades no confirmades i confirma els resultats abans que ho faci T2. De fet, l'horari presenta una interferència de lectura no confirmada. T1 llegeix una dada modificada per T2 i que està pendent de confirmació. A més a més, T1 finalitza l'execució (confirmant resultats) abans que s'acabi l'execució de la transacció T2. Atès que la transacció T2 no confirma els resultats, la interferència de lectura no confirmada al final es produeix, ja que la transacció T1 ha recuperat un valor que mai no hauria d'haver recuperat. La situació encara podria ser pitjor si la transacció que recupera dades pendents de confirmació les intenta modificar, tal com mostra l'horari següent: En aquest cas, la transacció T1 recupera una dada pendent de confirmació i, basant-se en la lectura feta, realitza una modificació (acció número 4). Quan la transacció T2 cancel·la l'execució, l'SGBD restaura el valor que hi havia del grànul A en la BD abans d'iniciar-se l'execució de la transacció T2. Per tant, a conseqüència d'aquesta cancel·lació, es perd el canvi que ha efectuat la transacció T1 sobre A. Això fa que no es verifiqui la propietat de definitivitat per a la transacció T1. L'SGBD pot tractar el problema que mostren els exemples previs de dues maneres possibles: 1) Impedir que les transaccions treballin amb dades pendents de confirmació. Això es pot aconseguir, per exemple, bloquejant l'execució de la transacció que vol treballar amb aquestes dades fins que la transacció que hagi fet les modificacions finalitzi l'execució. En el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003201	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of the example given in the paragraph?'  
C001500032	Gestio╠ü de transaccions	Nota	synthetic_question	En l'horari d'exemple, si T2, en comptes de cancel·lar els resultats, els hagués confirmat (executant com a acció número 5 una operació de COMMIT), la interferència de lectura no confirmada no s'hauria produït (en aquest supòsit, l'horari en sèrie equivalent seria T2;T1). Malgrat això, l'horari tampoc no verificaria el criteri de recuperabilitat, ja que T1 recupera dades no confirmades i confirma els resultats abans que ho faci T2. De fet, l'horari presenta una interferència de lectura no confirmada. T1 llegeix una dada modificada per T2 i que està pendent de confirmació. A més a més, T1 finalitza l'execució (confirmant resultats) abans que s'acabi l'execució de la transacció T2. Atès que la transacció T2 no confirma els resultats, la interferència de lectura no confirmada al final es produeix, ja que la transacció T1 ha recuperat un valor que mai no hauria d'haver recuperat. La situació encara podria ser pitjor si la transacció que recupera dades pendents de confirmació les intenta modificar, tal com mostra l'horari següent: En aquest cas, la transacció T1 recupera una dada pendent de confirmació i, basant-se en la lectura feta, realitza una modificació (acció número 4). Quan la transacció T2 cancel·la l'execució, l'SGBD restaura el valor que hi havia del grànul A en la BD abans d'iniciar-se l'execució de la transacció T2. Per tant, a conseqüència d'aquesta cancel·lació, es perd el canvi que ha efectuat la transacció T1 sobre A. Això fa que no es verifiqui la propietat de definitivitat per a la transacció T1. L'SGBD pot tractar el problema que mostren els exemples previs de dues maneres possibles: 1) Impedir que les transaccions treballin amb dades pendents de confirmació. Això es pot aconseguir, per exemple, bloquejant l'execució de la transacció que vol treballar amb aquestes dades fins que la transacció que hagi fet les modificacions finalitzi l'execució. En el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003202	How does the SGBD restore the value of the granule A before initiating the execution of Transaction T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD restore the value of the granule A before initiating the execution of Transaction T2?'  
C001500032	Gestio╠ü de transaccions	Nota	synthetic_question	En l'horari d'exemple, si T2, en comptes de cancel·lar els resultats, els hagués confirmat (executant com a acció número 5 una operació de COMMIT), la interferència de lectura no confirmada no s'hauria produït (en aquest supòsit, l'horari en sèrie equivalent seria T2;T1). Malgrat això, l'horari tampoc no verificaria el criteri de recuperabilitat, ja que T1 recupera dades no confirmades i confirma els resultats abans que ho faci T2. De fet, l'horari presenta una interferència de lectura no confirmada. T1 llegeix una dada modificada per T2 i que està pendent de confirmació. A més a més, T1 finalitza l'execució (confirmant resultats) abans que s'acabi l'execució de la transacció T2. Atès que la transacció T2 no confirma els resultats, la interferència de lectura no confirmada al final es produeix, ja que la transacció T1 ha recuperat un valor que mai no hauria d'haver recuperat. La situació encara podria ser pitjor si la transacció que recupera dades pendents de confirmació les intenta modificar, tal com mostra l'horari següent: En aquest cas, la transacció T1 recupera una dada pendent de confirmació i, basant-se en la lectura feta, realitza una modificació (acció número 4). Quan la transacció T2 cancel·la l'execució, l'SGBD restaura el valor que hi havia del grànul A en la BD abans d'iniciar-se l'execució de la transacció T2. Per tant, a conseqüència d'aquesta cancel·lació, es perd el canvi que ha efectuat la transacció T1 sobre A. Això fa que no es verifiqui la propietat de definitivitat per a la transacció T1. L'SGBD pot tractar el problema que mostren els exemples previs de dues maneres possibles: 1) Impedir que les transaccions treballin amb dades pendents de confirmació. Això es pot aconseguir, per exemple, bloquejant l'execució de la transacció que vol treballar amb aquestes dades fins que la transacció que hagi fet les modificacions finalitzi l'execució. En el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003203	Why is it important to verify the property of definitiveness for each transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Why is it important to verify the property of definitiveness for each transaction?'  
C001500032	Gestio╠ü de transaccions	Nota	synthetic_question	En l'horari d'exemple, si T2, en comptes de cancel·lar els resultats, els hagués confirmat (executant com a acció número 5 una operació de COMMIT), la interferència de lectura no confirmada no s'hauria produït (en aquest supòsit, l'horari en sèrie equivalent seria T2;T1). Malgrat això, l'horari tampoc no verificaria el criteri de recuperabilitat, ja que T1 recupera dades no confirmades i confirma els resultats abans que ho faci T2. De fet, l'horari presenta una interferència de lectura no confirmada. T1 llegeix una dada modificada per T2 i que està pendent de confirmació. A més a més, T1 finalitza l'execució (confirmant resultats) abans que s'acabi l'execució de la transacció T2. Atès que la transacció T2 no confirma els resultats, la interferència de lectura no confirmada al final es produeix, ja que la transacció T1 ha recuperat un valor que mai no hauria d'haver recuperat. La situació encara podria ser pitjor si la transacció que recupera dades pendents de confirmació les intenta modificar, tal com mostra l'horari següent: En aquest cas, la transacció T1 recupera una dada pendent de confirmació i, basant-se en la lectura feta, realitza una modificació (acció número 4). Quan la transacció T2 cancel·la l'execució, l'SGBD restaura el valor que hi havia del grànul A en la BD abans d'iniciar-se l'execució de la transacció T2. Per tant, a conseqüència d'aquesta cancel·lació, es perd el canvi que ha efectuat la transacció T1 sobre A. Això fa que no es verifiqui la propietat de definitivitat per a la transacció T1. L'SGBD pot tractar el problema que mostren els exemples previs de dues maneres possibles: 1) Impedir que les transaccions treballin amb dades pendents de confirmació. Això es pot aconseguir, per exemple, bloquejant l'execució de la transacció que vol treballar amb aquestes dades fins que la transacció que hagi fet les modificacions finalitzi l'execució. En el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003204	What is one possible way to treat the problem shown in the examples according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is one possible way to treat the problem shown in the examples according to the paragraph?'  
C001500032	Gestio╠ü de transaccions	Nota	synthetic_question	En l'horari d'exemple, si T2, en comptes de cancel·lar els resultats, els hagués confirmat (executant com a acció número 5 una operació de COMMIT), la interferència de lectura no confirmada no s'hauria produït (en aquest supòsit, l'horari en sèrie equivalent seria T2;T1). Malgrat això, l'horari tampoc no verificaria el criteri de recuperabilitat, ja que T1 recupera dades no confirmades i confirma els resultats abans que ho faci T2. De fet, l'horari presenta una interferència de lectura no confirmada. T1 llegeix una dada modificada per T2 i que està pendent de confirmació. A més a més, T1 finalitza l'execució (confirmant resultats) abans que s'acabi l'execució de la transacció T2. Atès que la transacció T2 no confirma els resultats, la interferència de lectura no confirmada al final es produeix, ja que la transacció T1 ha recuperat un valor que mai no hauria d'haver recuperat. La situació encara podria ser pitjor si la transacció que recupera dades pendents de confirmació les intenta modificar, tal com mostra l'horari següent: En aquest cas, la transacció T1 recupera una dada pendent de confirmació i, basant-se en la lectura feta, realitza una modificació (acció número 4). Quan la transacció T2 cancel·la l'execució, l'SGBD restaura el valor que hi havia del grànul A en la BD abans d'iniciar-se l'execució de la transacció T2. Per tant, a conseqüència d'aquesta cancel·lació, es perd el canvi que ha efectuat la transacció T1 sobre A. Això fa que no es verifiqui la propietat de definitivitat per a la transacció T1. L'SGBD pot tractar el problema que mostren els exemples previs de dues maneres possibles: 1) Impedir que les transaccions treballin amb dades pendents de confirmació. Això es pot aconseguir, per exemple, bloquejant l'execució de la transacció que vol treballar amb aquestes dades fins que la transacció que hagi fet les modificacions finalitzi l'execució. En el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003205	What is an example of a modification made by Transaction T1 in the second horarium given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is an example of a modification made by Transaction T1 in the second horarium given in the paragraph?'  
C001500032	Gestio╠ü de transaccions	Nota	synthetic_question	En l'horari d'exemple, si T2, en comptes de cancel·lar els resultats, els hagués confirmat (executant com a acció número 5 una operació de COMMIT), la interferència de lectura no confirmada no s'hauria produït (en aquest supòsit, l'horari en sèrie equivalent seria T2;T1). Malgrat això, l'horari tampoc no verificaria el criteri de recuperabilitat, ja que T1 recupera dades no confirmades i confirma els resultats abans que ho faci T2. De fet, l'horari presenta una interferència de lectura no confirmada. T1 llegeix una dada modificada per T2 i que està pendent de confirmació. A més a més, T1 finalitza l'execució (confirmant resultats) abans que s'acabi l'execució de la transacció T2. Atès que la transacció T2 no confirma els resultats, la interferència de lectura no confirmada al final es produeix, ja que la transacció T1 ha recuperat un valor que mai no hauria d'haver recuperat. La situació encara podria ser pitjor si la transacció que recupera dades pendents de confirmació les intenta modificar, tal com mostra l'horari següent: En aquest cas, la transacció T1 recupera una dada pendent de confirmació i, basant-se en la lectura feta, realitza una modificació (acció número 4). Quan la transacció T2 cancel·la l'execució, l'SGBD restaura el valor que hi havia del grànul A en la BD abans d'iniciar-se l'execució de la transacció T2. Per tant, a conseqüència d'aquesta cancel·lació, es perd el canvi que ha efectuat la transacció T1 sobre A. Això fa que no es verifiqui la propietat de definitivitat per a la transacció T1. L'SGBD pot tractar el problema que mostren els exemples previs de dues maneres possibles: 1) Impedir que les transaccions treballin amb dades pendents de confirmació. Això es pot aconseguir, per exemple, bloquejant l'execució de la transacció que vol treballar amb aquestes dades fins que la transacció que hagi fet les modificacions finalitzi l'execució. En el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003206	How does the cancellation of Transaction T2 affect the change made by Transaction T1?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the cancellation of Transaction T2 affect the change made by Transaction T1?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003301	What is the main purpose of the rule described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the main purpose of the rule described in the paragraph?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003302	What type of transactions should not attempt to confirm results before the end of the transaction that modified the data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What type of transactions should not attempt to confirm results before the end of the transaction that modified the data?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003303	How will the SGBD block the execution if a transaction attempts to confirm results before the end of the transaction that modified the data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How will the SGBD block the execution if a transaction attempts to confirm results before the end of the transaction that modified the data?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003304	What happens to the ending of the transaction that worked with unconfirmed data when the transaction that modified the data ends?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What happens to the ending of the transaction that worked with unconfirmed data when the transaction that modified the data ends?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003305	Can the transaction that worked with unconfirmed data confirm its results after the end of the transaction that modified the data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can the transaction that worked with unconfirmed data confirm its results after the end of the transaction that modified the data?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003306	How does the ending of the transaction that worked with unconfirmed data depend on the completion of the transaction that modified the data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the ending of the transaction that worked with unconfirmed data depend on the completion of the transaction that modified the data?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003307	In what way does the first example given in the paragraph illustrate the rule described?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'In what way does the first example given in the paragraph illustrate the rule described?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003308	What is the name of the rule described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the name of the rule described in the paragraph?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003309	What is the main idea behind the rule described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the main idea behind the rule described in the paragraph?'  
C001500033	Gestio╠ü de transaccions	Nota	synthetic_question	2) Permetre a les transaccions que treballin amb dades no confirmades, sempre que aquestes transaccions no intentin confirmar els resultats abans de l'acabament de la transacció que ha modificat les dades. En cas que una transacció que hagi treballat amb dades no confirmades vulgui confirmar resultats, l'SGBD bloquejarà l'execució. És més, l'acabament de la transacció que ha treballat amb dades no confirmades queda supeditat a la finalització de la transacció que ha modificat les dades i acabaran l'execució de la mateixa manera. De nou, en el nostre primer exemple, l'horari quedaria de la manera següent:	C00150003310	Why is it important to follow this rule in database management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Why is it important to follow this rule in database management?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003401	What is the purpose of using the ABORT action to represent a cancelled transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'What is the purpose of using the ABORT action to represent a cancelled transaction?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003402	How does the execution of an ABORT affect the outcome of a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'How does the execution of an ABORT affect the outcome of a transaction?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003403	What is the consequence of cancelling a transaction that has written granules to the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'What is the consequence of cancelling a transaction that has written granules to the database?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003404	Why might cancelling transactions be a costly process?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'Why might cancelling transactions be a costly process?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003405	In what way do SGBDs tend to prevent this type of behaviour?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'In what way do SGBDs tend to prevent this type of behaviour?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003406	What is the main idea behind the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'What is the main idea behind the example given in the paragraph?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003407	How does the cascade of cancellations work in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'How does the cascade of cancellations work in the example?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003408	"What is the significance of the phrase ""des del punt de vista teórico""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'What is the significance of the phrase ""des del punt de vista teórico""?'  "
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003409	According to the passage, how does the recovery of pending confirmation depend on the type of system being used?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'According to the passage, how does the recovery of pending confirmation depend on the type of system being used?'  
C001500034	Gestio╠ü de transaccions	Cancel·lació involuntària	synthetic_question	Usarem l'acció d'ABORT per a representar la cancel·lació involuntària (és a dir, induïda per l'SGBD) d'una transacció. Les conseqüències de la seva execució són idèntiques a la cancel·lació voluntària d'una transacció (acció de ROLLBACK). La conseqüència d'aquesta manera de treballar és que, tal com es pot observar en l'exemple anterior, la cancel·lació d'una transacció T implica l'avortament de totes les transaccions que hagin treballat amb algun grànul que hagi escrit la transacció T. Aquesta situació pot provocar una cascadadecancel·lacions, tal com mostra l'exemple següent: Cancel·lar transaccions és un procés costós (i més encara si aquestes transaccions estaven disposades a confirmar els seus resultats). Per això, en general, els SGBD no permeten aquest tipus de comportament i tendeixen a impedir que les transaccions recuperin dades pendents de confirmació.	C00150003410	"In what sense might the term ""grànul"" be considered misleading in the context of this passage?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Cancel·lació involuntària'; content: 'In what sense might the term ""grànul"" be considered misleading in the context of this passage?'  "
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003501	What is the main point stated in the first sentence of the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'What is the main point stated in the first sentence of the given paragraph?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003502	According to the paragraph, what is the purpose of an SQL statement when connecting to a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'According to the paragraph, what is the purpose of an SQL statement when connecting to a database?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003503	Can you identify the type of transaction described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'Can you identify the type of transaction described in the paragraph?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003504	How does one explicitly end a transaction, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'How does one explicitly end a transaction, according to the paragraph?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003505	What happens if one fails to explicitly end a transaction, as mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'What happens if one fails to explicitly end a transaction, as mentioned in the paragraph?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003506	In which situation might an SQL statement automatically initiate a transaction, as per the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'In which situation might an SQL statement automatically initiate a transaction, as per the paragraph?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003507	"What is the significance of the phrase ""implícitament inicia la execució d'una transacción"" in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'What is the significance of the phrase ""implícitament inicia la execució d'una transacción"" in the paragraph?'  "
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003508	Why must one use explicit commit or rollback statements to end a transaction, as suggested in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'Why must one use explicit commit or rollback statements to end a transaction, as suggested in the paragraph?'  
C001500035	Gestio╠ü de transaccions	6. Visió externa de les transaccions	synthetic_question	SQL estàndard força que, un cop s'hagi establert una connexió amb la BD, la primera sentència SQL que vulguem executar mitjançant l'SQL interactiu, implícitament inicia l'execució d'una transacció. Un cop iniciada la transacció, romandrà activa fins que explícitament i d'una manera obligatòria, n'indiquem l'acabament.	C00150003509	What would happen if one uses implicit commits without proper knowledge of their consequences, as warned against in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6. Visió externa de les transaccions'; content: 'What would happen if one uses implicit commits without proper knowledge of their consequences, as warned against in the paragraph?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003601	What is the current version of SQL standard referred to in the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'What is the current version of SQL standard referred to in the given paragraph?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003602	According to the paragraph, what is the default guarantee provided by the SGBD regarding transaction execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'According to the paragraph, what is the default guarantee provided by the SGBD regarding transaction execution?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003603	Can multiple transactions access the database concurrently without interference?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'Can multiple transactions access the database concurrently without interference?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003604	How does the SGBD ensure seriability and recoverability of the schedule produced?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'How does the SGBD ensure seriability and recoverability of the schedule produced?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003605	In which year was a specific contribution made to the SQL standard according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'In which year was a specific contribution made to the SQL standard according to the paragraph?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003606	What is the purpose of specifying the year of an SQL version when referring to it in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'What is the purpose of specifying the year of an SQL version when referring to it in the paragraph?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003607	What is the default behavior of the SGBD regarding transaction isolation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'What is the default behavior of the SGBD regarding transaction isolation?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003608	Does the SGBD guarantee the correctness of the aforementioned default behavior?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'Does the SGBD guarantee the correctness of the aforementioned default behavior?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003609	How does the SGBD ensure the recoverability of the horarium produced?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'How does the SGBD ensure the recoverability of the horarium produced?'  
C001500036	Gestio╠ü de transaccions	Versió d'SQL	synthetic_question	Quan parlem de les sentències SQL, sempre ens referirem a la darrera versió de l'SQL estàndard, ja que té com a subconjunt totes les anteriors i, per tant, tot el que era vàlid en l'anterior ho continuarà essent en la següent. Només especificarem l'any d'una versió de l'SQL quan vulguem emfatitzar que es va fer una aportació determinada concretament en aquesta versió. Per defecte, l'SQL estàndard força que aquesta transacció mai no vegi interferida la seva execució, i que tampoc pugui interferir en l'execució d'altres transaccions. En definitiva, per defecte, l'SGBD haurà de garantir l'aïllament correcte de totes les transaccions que accedeixin d'una manera concurrent a la BD. En altres paraules, l'SGBD haurà de garantir la seriabilitat i recuperabilitat de l'horari que es produeixi. Per a informar sobre les característiques associades a una transacció des de l'SQL:1992 disposem de la sentència següent:	C00150003610	What is the main idea conveyed in the last sentence of the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Versió d'SQL'; content: 'What is the main idea conveyed in the last sentence of the given paragraph?'  
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003701	What is the purpose of the notation described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'What is the purpose of the notation described in the paragraph?'  
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003702	What are the two types of sentences that can be used in the notation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'What are the two types of sentences that can be used in the notation?'  
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003703	What does the notation {A|...|B} mean?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'What does the notation {A|...|B} mean?'  
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003704	"What is the meaning of the word ""WORK"" in the notation?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'What is the meaning of the word ""WORK"" in the notation?'  "
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003705	"How many times can the sentence ""Mentre COMMIT confirmava..."" be executed during a session?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'How many times can the sentence ""Mentre COMMIT confirmava..."" be executed during a session?'  "
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003706	"What happens if there is an error in one of the transactions during the execution of the sentence ""Mentre COMMIT confirmava...""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'What happens if there is an error in one of the transactions during the execution of the sentence ""Mentre COMMIT confirmava...""?'  "
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003707	"What is the effect of using the sentence ""Mentre ROLLBACK desfaria..."" during a transaction?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'What is the effect of using the sentence ""Mentre ROLLBACK desfaria..."" during a transaction?'  "
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003708	"Can the sentence ""Mentre COMMIT confirmava..."" be used to confirm all changes made during multiple transactions?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'Can the sentence ""Mentre COMMIT confirmava..."" be used to confirm all changes made during multiple transactions?'  "
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003709	"Is it possible to use the sentence ""Mentre ROLLBACK desfaria..."" to undo only some of the changes made during a transaction?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'Is it possible to use the sentence ""Mentre ROLLBACK desfaria..."" to undo only some of the changes made during a transaction?'  "
C001500037	Gestio╠ü de transaccions	Notació	synthetic_question	La notació per presentar la sintaxi de les sentències SQL serà la següent: • • Les paraules en negreta són paraules reservades del llenguatge. La notació [...] vol dir que el que hi ha entre els claudàtors es opcional. La notació {A|...|B} vol dir que hem d'escollir entre totes les opcions que hi ha entre les claus, però hem de posar-ne una obligatòriament. en què <mode_accés> pot ser READ ONLY, en cas que la transacció només consulti la BD o READ WRITE, en cas que la transacció modifiqui la BD. La sentència prèvia només es pot executar en cas que no hi hagi cap transacció en execució a la sessió de treball establerta amb la BD; si n'hi ha alguna, l'SQL estàndard especifica que l'SGBD hauria de reportar una situació d'error. Addicionalment, les característiques especificades seran aplicables a la resta de transaccions que s'executin posteriorment durant la sessió de treball. Per indicar l'acabament d'una transacció, l'SQL estàndard ens ofereix la sentència següent. Mentre COMMIT confirma tots els canvis produïts contra la BD durant l'execució de la transacció, ROLLBACK els desfà i deixa la BD com estava abans d'iniciar-se la transacció. La paraula reservada WORK només serveix per a explicar què fa la sentència i és opcional.	C00150003710	How does the notation described in the paragraph differ from standard SQL syntax?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Notació'; content: 'How does the notation described in the paragraph differ from standard SQL syntax?'  
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003801	"What type of data is stored in the ""saldo"" column of the ""comptes"" table?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'What type of data is stored in the ""saldo"" column of the ""comptes"" table?'  "
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003802	Which statement is used to retrieve the balance of a savings account in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'Which statement is used to retrieve the balance of a savings account in the example given?'  
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003803	"What is the primary key of the ""comptes"" table?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'What is the primary key of the ""comptes"" table?'  "
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003804	How many tables are mentioned in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'How many tables are mentioned in the example given?'  
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003805	"What is the purpose of the ""SET TRANSACTION"" sentence in the example given?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'What is the purpose of the ""SET TRANSACTION"" sentence in the example given?'  "
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003806	Can multiple transactions be executed within a single session in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'Can multiple transactions be executed within a single session in the example given?'  
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003807	What is the difference between an explicit begin transaction and an implicit begin transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'What is the difference between an explicit begin transaction and an implicit begin transaction?'  
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003808	"How does the ""SELECT saldo FROM comptes WHERE tipus_compte='estalvi a termini'"" statement affect the current transaction in the example given?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'How does the ""SELECT saldo FROM comptes WHERE tipus_compte='estalvi a termini'"" statement affect the current transaction in the example given?'  "
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003809	Is it possible to roll back a transaction if it has already been committed in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'Is it possible to roll back a transaction if it has already been committed in the example given?'  
C001500038	Gestio╠ü de transaccions	Exemples d'ús de la sentència SET TRANSACTION	synthetic_question	"Suposem que tenim una BD d'un banc que guarda dades dels comptes dels clients. En concret, considerem que tenim la taula (clau primària subratllada) següent: Considerant que hem establert la connexió amb la BD, podem executar les sentències següents durant la nostra sessió de treball amb els efectes que es comenten: SELECT saldo FROM comptes WHERE tipus_compte=""estalvi a termini""; El començament implícit de transaccions, en un entorn d'aplicació real, pot crear confusions sobre l'abast de cada transacció, si aquest abast no es documenta correctament. Per això, l'SQL:1999 proposa fer servir la sentència següent."	C00150003810	What happens to any unsaved changes made during an active transaction when the connection is closed in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència SET TRANSACTION'; content: 'What happens to any unsaved changes made during an active transaction when the connection is closed in the example given?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003901	What is the purpose of the Begin statement in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'What is the purpose of the Begin statement in SQL?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003902	How does the Begin statement initiate transactions in most cases?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'How does the Begin statement initiate transactions in most cases?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003903	What are the two modes of access specified in the Begin statement?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'What are the two modes of access specified in the Begin statement?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003904	What happens if no characteristics are specified before the Begin statement?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'What happens if no characteristics are specified before the Begin statement?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003905	Can a transaction be considered as both READ ONLY and READ WRITE?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'Can a transaction be considered as both READ ONLY and READ WRITE?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003906	Is it mandatory to specify the mode of access in the Begin statement?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'Is it mandatory to specify the mode of access in the Begin statement?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003907	What is the default mode of access if no mode is specified in the Begin statement?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'What is the default mode of access if no mode is specified in the Begin statement?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003908	Can the Begin statement be used without specifying any characteristics or mode of access?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'Can the Begin statement be used without specifying any characteristics or mode of access?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003909	Will an error occur if no characteristic is specified before the Begin statement?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'Will an error occur if no characteristic is specified before the Begin statement?'  
C001500039	Gestio╠ü de transaccions	Inici de les transaccions	synthetic_question	Molts SGBD incorporen sentències pròpies per marcar d'una manera explícita l'inici de les transaccions. En la majoria dels casos, aquesta sentència és la sentència BEGIN WORK o, simplement, BEGIN perquè la paraula clau WORK és opcional. en què <mode_accés> pot ser READ ONLY o READ WRITE. Si no s'especifica el mode d'accés, la sentència simplement inicia l'execució d'una nova transacció, d'acord amb les característiques que s'hagin especificat prèviament. Si abans no se n'ha especificat cap característica, l'SQL estàndard enuncia que la transacció s'ha de considerar de tipus READ WRITE.	C00150003910	In what situation might the Begin statement be used without specifying any characteristics or mode of access?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Inici de les transaccions'; content: 'In what situation might the Begin statement be used without specifying any characteristics or mode of access?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004001	What is the purpose of the example sentences given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'What is the purpose of the example sentences given in the paragraph?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004002	How does the START TRANSACTION sentence affect the database connection established earlier?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'How does the START TRANSACTION sentence affect the database connection established earlier?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004003	What is the difference between executing the INSERT statement before or after starting a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'What is the difference between executing the INSERT statement before or after starting a transaction?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004004	Can you explain the significance of the auto-commit feature in the context of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'Can you explain the significance of the auto-commit feature in the context of transactions?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004005	How would you describe the effect of committing a transaction without first rolling back an error?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'How would you describe the effect of committing a transaction without first rolling back an error?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004006	In what scenario might it be beneficial to use the ROLLBACK statement instead of simply letting the transaction expire?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'In what scenario might it be beneficial to use the ROLLBACK statement instead of simply letting the transaction expire?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004007	What happens if multiple statements are executed within a single transaction, but only some of them produce errors?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'What happens if multiple statements are executed within a single transaction, but only some of them produce errors?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004008	Can you provide an example of how to use the SAVEPOINT command to save a specific point within a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'Can you provide an example of how to use the SAVEPOINT command to save a specific point within a transaction?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004009	How does the COMMIT statement differ from the SAVEPOINT command in terms of saving transaction progress?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'How does the COMMIT statement differ from the SAVEPOINT command in terms of saving transaction progress?'  
C001500040	Gestio╠ü de transaccions	Exemples d'ús de la sentència START TRANSACTION	synthetic_question	En la BD d'exemple anterior i assumint que hem establert la connexió amb la BD, podem executar les sentències següents amb els efectes que es comenten:	C00150004010	Under what circumstances might it be preferable to use the COMMIT statement over the SAVEPOING command when saving transaction progress?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples d'ús de la sentència START TRANSACTION'; content: 'Under what circumstances might it be preferable to use the COMMIT statement over the SAVEPOING command when saving transaction progress?'  
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004101	What is the main topic discussed in the paragraph?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'What is the main topic discussed in the paragraph?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004102	According to the paragraph, what was previously considered essential for transaction management?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'According to the paragraph, what was previously considered essential for transaction management?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004103	What is the new approach proposed in the paragraph for relaxing the level of isolation?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'What is the new approach proposed in the paragraph for relaxing the level of isolation?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004104	How does this new approach differ from the previous one in terms of managing transactions?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'How does this new approach differ from the previous one in terms of managing transactions?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004105	What is the reason given in the paragraph for why this new approach is possible?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'What is the reason given in the paragraph for why this new approach is possible?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004106	In which situation might this new approach not be appropriate, according to the paragraph?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'In which situation might this new approach not be appropriate, according to the paragraph?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004107	What is the author's opinion on the importance of guaranteeing seriability and recoverability in transaction management?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'What is the author's opinion on the importance of guaranteeing seriability and recoverability in transaction management?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004108	How does the author suggest improving the performance of the SGBD in terms of managing information control?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'How does the author suggest improving the performance of the SGBD in terms of managing information control?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004109	What is the effect of implementing this new approach, according to the paragraph?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'What is the effect of implementing this new approach, according to the paragraph?'  "
C001500041	Gestio╠ü de transaccions	"UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament"	synthetic_question	Fins ara havíem considerat que sempre calia garantir la seriabilitat i la recuperabilitat de les transaccions, per tal de garantir una protecció total davant qualsevol tipus d'interferències. No obstant això, aquesta protecció total exigeix una sobrecàrrega de l'SGBD en termes de gestió d'informació de control i una disminució del nivell de concurrència.	C00150004110	What is the conclusion reached by the author at the end of the paragraph?	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'UPDATE comptes SET saldo=saldo+500 WHERE num_compte=""987656574"";.  6.1. Relaxació del nivell d'aïllament'; content: 'What is the conclusion reached by the author at the end of the paragraph?'  "
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004201	What is the purpose of using transaction isolation levels in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of using transaction isolation levels in SQL?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004202	What are the four types of transaction isolation levels available in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What are the four types of transaction isolation levels available in SQL?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004203	What does the READ UNCOMMITTED isolation level allow other transactions to do during a read operation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What does the READ UNCOMMITTED isolation level allow other transactions to do during a read operation?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004204	How does the REPEATABLE READ isolation level differ from the READ COMMITTED isolation level?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the REPEATABLE READ isolation level differ from the READ COMMITTED isolation level?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004205	Can you describe an example scenario where it might be beneficial to use the SERIALIZABLE isolation level?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you describe an example scenario where it might be beneficial to use the SERIALIZABLE isolation level?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004206	"What is the difference between a ""read"" and a ""commit"" in the context of transaction isolation levels?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the difference between a ""read"" and a ""commit"" in the context of transaction isolation levels?'  "
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004207	How does the START TRANSACTION instruction relate to the transaction isolation levels discussed in this passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the START TRANSACTION instruction relate to the transaction isolation levels discussed in this passage?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004208	In what situations might it be appropriate to relax the transaction isolation level and permit interferences?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In what situations might it be appropriate to relax the transaction isolation level and permit interferences?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004209	Can you explain how the transaction isolation levels affect the ability of other transactions to intervene during a read or write operation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you explain how the transaction isolation levels affect the ability of other transactions to intervene during a read or write operation?'  
C001500042	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el nivell de concurrència en l'apartat 4 d'aquest mòdul didàctic. En unes circumstàncies determinades és convenient relaxar el nivell d'aïllament i possibilitar que es produeixin interferències. Això és correcte si se sap que aquestes interferències no s'esdevindran realment, o si en l'entorn d'aplicació en què ens trobem no és important que es produeixin. Si ens centrem en l'SQL estàndard, les instruccions SET TRANSACTION i START TRANSACTION permeten relaxar el nivell d'aïllament. Té la sintaxi següent. en què <nivell_aïllament> pot ser READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ o bé SERIALIZABLE. El nivell d'aïllament determina les interferències que poden desencadenar altres transaccions en la transacció que comença. D'acord amb els tipus d'interferència que hem descrit, la taula següent indica les que s'eviten amb cada nivell d'aïllament.	C00150004210	According to the passage, which transaction isolation level would you choose if you wanted to minimize the risk of interference from other transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'According to the passage, which transaction isolation level would you choose if you wanted to minimize the risk of interference from other transactions?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004301	What are the four levels of isolation studied in the apartat 3 of this module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What are the four levels of isolation studied in the apartat 3 of this module?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004302	What is the difference between the READ UNCOMMITTED and READ COMMITTED levels of isolation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the difference between the READ UNCOMMITTED and READ COMMITTED levels of isolation?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004303	How does the REPEATABLE READ level of isolation protect against interference from other transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the REPEATABLE READ level of isolation protect against interference from other transactions?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004304	What is the purpose of the SERIALIZABLE level of isolation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of the SERIALIZABLE level of isolation?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004305	According to the SQL standard, what is the minimum level of isolation that a database management system must guarantee?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'According to the SQL standard, what is the minimum level of isolation that a database management system must guarantee?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004306	Can a database management system offer a higher level of isolation than the one specified by the SQL standard?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can a database management system offer a higher level of isolation than the one specified by the SQL standard?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004307	What is the main advantage of using the SERIALIZABLE level of isolation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the main advantage of using the SERIALIZABLE level of isolation?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004308	How do the different levels of isolation affect the ability of transactions to access and modify data in a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How do the different levels of isolation affect the ability of transactions to access and modify data in a database?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004309	In which situations might it be desirable to use the highest level of isolation (SERIALIZABLE)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In which situations might it be desirable to use the highest level of isolation (SERIALIZABLE)?'  
C001500043	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els tipus d'interferències entre transaccions en l'apartat 3 d'aquest mòdul didàctic. Els nivells hi apareixen de menys a més estrictes i, per tant, de menys a més eficients: 1) El nivell READ UNCOMMITTED protegeix les dades actualitzades, i evita que cap altra transacció no les actualitzi, fins que no s'acaba la transacció. No ofereix cap garantia respecte a les dades que llegeixi la transacció. Poden ser dades actualitzades per una transacció que encara no ha confirmat i, a més, una altra transacció les pot actualitzar immediatament. 2) El nivell READ COMMITTED protegeix parcialment les lectures, i impedeix que la transacció llegeixi les dades actualitzades per una altra transacció que encara no s'han confirmat. 3) El nivell REPEATABLE READ impedeix que una altra transacció actualitzi una dada que ha llegit la transacció fins que aquesta no s'acaba. D'aquesta manera, la transacció pot tornar a llegir aquesta dada sense risc que l'hagin canviada. 4) El nivell SERIALIZABLE ofereix un aïllament total i evita qualsevol tipus d'interferències, incloent-hi els fantasmes. Això significa que no solament protegeix les dades que ha vist la transacció, sinó també qualsevol informació de control que s'hagi utilitzat per a fer cerques. La definició de l'SQL estàndard estableix que un SGBD concret té l'obligació de garantir com a mínim el nivell d'aïllament que la transacció hagi sol·licitat, tot i que pot optar per oferir un aïllament més elevat. Per tant, l'únic nivell que un SGBD té l'obligació d'implementar és el més alt, el SERIALIZABLE.	C00150004310	Can you explain how the REPEATABLE READ level of isolation works, and why it is useful in certain scenarios?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you explain how the REPEATABLE READ level of isolation works, and why it is useful in certain scenarios?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004401	What is the main purpose of transaction management in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'What is the main purpose of transaction management in a database system?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004402	According to the passage, what are the two key aspects of transaction management that depend on each other?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'According to the passage, what are the two key aspects of transaction management that depend on each other?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004403	What is the responsibility of the SGBD in ensuring transaction properties, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'What is the responsibility of the SGBD in ensuring transaction properties, according to the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004404	How does the SGBD contribute to guaranteeing transaction properties, as described in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'How does the SGBD contribute to guaranteeing transaction properties, as described in the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004405	What are some aspects of transaction management that depend on the developer of applications, as mentioned in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'What are some aspects of transaction management that depend on the developer of applications, as mentioned in the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004406	In which way do developers play a crucial role in ensuring transaction properties, as stated in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'In which way do developers play a crucial role in ensuring transaction properties, as stated in the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004407	Can you identify the specific responsibilities of the SGBD and developers in managing transactions, based on the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'Can you identify the specific responsibilities of the SGBD and developers in managing transactions, based on the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004408	How do transaction properties ensure data consistency and integrity within a database system, as discussed in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'How do transaction properties ensure data consistency and integrity within a database system, as discussed in the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004409	What is the significance of understanding transaction management concepts in the development of reliable and efficient database systems, as suggested in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'What is the significance of understanding transaction management concepts in the development of reliable and efficient database systems, as suggested in the passage?'  
C001500044	Gestio╠ü de transaccions	6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador	synthetic_question	Hem vist què és una transacció i quines propietats ha de complir. Examinem la contribució que ha de tenir l'SGBD per aconseguir garantir aquestes propietats i els aspectes que depenen del desenvolupador de les aplicacions:	C00150004410	In what ways can a thorough grasp of transaction management principles benefit software developers and database administrators, as implied in the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '6.2. Responsabilitats del sistema de gestió de bases de dades i del desenvolupador'; content: 'In what ways can a thorough grasp of transaction management principles benefit software developers and database administrators, as implied in the passage?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004501	What is the topic of the current module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the topic of the current module?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004502	What is the purpose of the previous section according to the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of the previous section according to the given paragraph?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004503	What concept has been presented in the previous section?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What concept has been presented in the previous section?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004504	What properties must the concept of transaction fulfill according to the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What properties must the concept of transaction fulfill according to the given paragraph?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004505	In which part of the module was the concept of transaction introduced?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In which part of the module was the concept of transaction introduced?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004506	"What does the phrase ""vegeu també"" mean in English?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What does the phrase ""vegeu també"" mean in English?'  "
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004507	According to the given paragraph, what is the relationship between the concept of transaction and the apartat 2 of the module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'According to the given paragraph, what is the relationship between the concept of transaction and the apartat 2 of the module?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004508	Can you summarize the main idea of the given paragraph in one sentence?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you summarize the main idea of the given paragraph in one sentence?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004509	What is the name of the current document?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the name of the current document?'  
C001500045	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat el concepte de transacció i les propietats que ha de complir en l'apartat 2 d'aquest mòdul didàctic.	C00150004510	What is the name of the previous section mentioned in the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the name of the previous section mentioned in the given paragraph?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004601	What is the main goal of the system described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'What is the main goal of the system described in the paragraph?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004602	How does the system achieve this goal?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'How does the system achieve this goal?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004603	What is the purpose of the control de concurència mechanism in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'What is the purpose of the control de concurència mechanism in the system?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004604	How does the system handle errors or failures during transaction execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'How does the system handle errors or failures during transaction execution?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004605	Can the system tolerate relaxation of isolation levels for certain transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'Can the system tolerate relaxation of isolation levels for certain transactions?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004606	How does the system provide transparency to developers using the SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'How does the system provide transparency to developers using the SGBD?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004607	What kind of changes do transactions make to the data in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'What kind of changes do transactions make to the data in the system?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004608	How does the system ensure that changes made by transactions comply with defined rules of integrity?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'How does the system ensure that changes made by transactions comply with defined rules of integrity?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004609	Can the system recover from errors or failures during transaction execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'Can the system recover from errors or failures during transaction execution?'  
C001500046	Gestio╠ü de transaccions	1)Responsabilitatsdelsistemadegestiódebasesdedades	synthetic_question	a) Aconseguir que l'horari que es produeixi a mesura que l'SGBD rep peticions de lectura o escriptura, i de COMMIT o ROLLBACK de les transaccions que s'executin d'una manera concurrent sobre la BD, sigui seriable i recuperable. Naturalment, en cas que s'hagi relaxat el nivell d'aïllament per a algunes transaccions, caldrà que l'SGBD consideri correctes més horaris. L'SGBD aconsegueix la seriabilitat i la recuperabilitat dels horaris sobretot de dues maneres (no necessàriament excloents entre elles): cancel·lant d'una manera automàtica les transaccions problemàtiques o suspenent l'execució de la transacció fins que la puguin reprendre sense problemes. El conjunt de mecanismes que fa aquestes tasques s'anomena controldeconcurrència. Cal que aquests mecanismes siguin tan transparents a la programació com sigui possible, de manera que no s'afegeixin dificultats innecessàries al desenvolupament. No obstant això, de vegades és necessari oferir serveis1 que modifiquin el comportament per defecte de l'SGBD, per a augmentar el nivell de concurrència. b) Comprovar que els canvis que ha fet una transacció verifiquen totes les regles d'integritat que s'han definit en la BD. Això es pot fer just abans d'acceptar el COMMIT de la transacció, rebutjant-lo si es viola alguna regla, o immediatament després d'executar-se cada petició dins la transacció. c) Impedir que hi romanguin canvis de transaccions que no s'arriben a confirmar i que es perdin els canvis que han dut a terme transaccions confirmades en cas que es produeixin cancel·lacions de transaccions, caigudes de l'SGBD o de les aplicacions, desastres (com ara incendis) o fallades dels dispositius externs d'emmagatzematge. En general, es parla de recuperacióper a referir-se al conjunt de mecanismes que s'encarreguen d'aquestes tasques.	C00150004610	What is the purpose of the recovery mechanisms in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Responsabilitatsdelsistemadegestiódebasesdedades'; content: 'What is the purpose of the recovery mechanisms in the system?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004701	What is the main goal of identifying transactions in an application?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'What is the main goal of identifying transactions in an application?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004702	What happens if an application has a transaction in execution while waiting for user input?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'What happens if an application has a transaction in execution while waiting for user input?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004703	How can relaxation of isolation levels help improve performance in applications?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'How can relaxation of isolation levels help improve performance in applications?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004704	What is one way to guarantee consistency of the database across all transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'What is one way to guarantee consistency of the database across all transactions?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004705	What should be considered when studying the performance of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'What should be considered when studying the performance of transactions?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004706	Can you describe a situation where it might be dangerous to have a long-running transaction in an application?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'Can you describe a situation where it might be dangerous to have a long-running transaction in an application?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004707	Why is it essential to understand the mechanisms of concurrency control in an SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'Why is it essential to understand the mechanisms of concurrency control in an SGBD?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004708	How does the SGBD provide support for transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'How does the SGBD provide support for transactions?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004709	What is one potential drawback of relaxing isolation levels in an application?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'What is one potential drawback of relaxing isolation levels in an application?'  
C001500047	Gestio╠ü de transaccions	2)Tasquesdeldesenvolupadord'aplicacions	synthetic_question	a) Identificar amb precisió les transaccions d'una aplicació, és a dir, el conjunt d'operacions que necessàriament s'han d'executar d'una manera atòmica sobre la BD, d'acord amb els requeriments dels usuaris. En aquest sentit, les transaccions haurien de durar el mínim imprescindible. En concret, pot ser molt perillós que una aplicació tingui una transacció en execució mentre s'espera l'entrada d'informació per part de l'usuari. A vegades, els usuaris poden trigar força estona a proporcionar unes certes dades o, simplement, a prémer el botó d'acceptació d'un missatge. Fins i tot, és possible que qualsevol circumstància els faci deixar a mitges el que feien i que l'aplicació es quedi força temps en espera que l'usuari s'hi torni a posar. Fins que l'usuari no permet que la transacció s'acabi, aquesta pot impedir l'actualització o fins i tot la lectura de les dades a les quals ja hagi accedit. Això significa més despesa de recursos i un fre important al nivell de concurrència possible. Per tant, (1)Per exemple, la possibilitat de relaxar el nivell d'aïllament de les transaccions. i sempre que sigui possible, se sol recomanar que durant una transacció no es pari mai l'execució de l'aplicació en espera que es produeixi una actuació determinada per part de l'usuari. b) Garantir que les transaccions mantenen la consistència de la BD, d'acord amb els requeriments dels usuaris, i tenint en compte les restriccions d'integritat i els disparadors definits en la BD. c) Considerar aspectes de rendiment. En particular, ha de ser capaç d'estudiar i millorar el nivell de concurrència d'acord amb els coneixements que tingui dels mecanismes de control de concurrència de l'SGBD i les possibilitats de modificar-ne el funcionament.	C00150004710	How can developers use the SGBD's built-in features to improve the performance of their transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Tasquesdeldesenvolupadord'aplicacions'; content: 'How can developers use the SGBD's built-in features to improve the performance of their transactions?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004801	What is one technique used for controlling concurrency in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'What is one technique used for controlling concurrency in databases?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004802	What are the most commonly used techniques for controlling concurrency in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'What are the most commonly used techniques for controlling concurrency in databases?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004803	What is the purpose of using reservations in controlling concurrency in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'What is the purpose of using reservations in controlling concurrency in databases?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004804	Can you describe the basic idea behind reservation-based techniques for controlling concurrency in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'Can you describe the basic idea behind reservation-based techniques for controlling concurrency in databases?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004805	How does the use of reservations help in avoiding conflicts during concurrent access to database resources?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'How does the use of reservations help in avoiding conflicts during concurrent access to database resources?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004806	In what way do reservations provide a more efficient approach to controlling concurrency in databases compared to other techniques?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'In what way do reservations provide a more efficient approach to controlling concurrency in databases compared to other techniques?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004807	What are some of the advantages of using reservations in controlling concurrency in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'What are some of the advantages of using reservations in controlling concurrency in databases?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004808	How do reservations help in ensuring data consistency and integrity when multiple transactions are accessing the same data simultaneously?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'How do reservations help in ensuring data consistency and integrity when multiple transactions are accessing the same data simultaneously?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004809	Can you explain how reservations work in practice to ensure successful transaction execution and prevent deadlocks?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'Can you explain how reservations work in practice to ensure successful transaction execution and prevent deadlocks?'  
C001500048	Gestio╠ü de transaccions	7. Control de concurrència mitjançant reserves	synthetic_question	Hi ha diverses tècniques de control de concurrència, cadascuna de les quals presenta múltiples variants. No obstant això, les tècniques basades amb reserves acostumen a ser les més utilitzades en els SGBD. Dins les tècniques basades en reserves, nosaltres veurem la més bàsica, les anomenades reserves S, X2.	C00150004810	How do reservations support the isolation of transactions in a database system, ensuring that each transaction operates independently without interference from other transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7. Control de concurrència mitjançant reserves'; content: 'How do reservations support the isolation of transactions in a database system, ensuring that each transaction operates independently without interference from other transactions?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004901	What are the two types of reserves in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'What are the two types of reserves in the system?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004902	What is the purpose of a reserve in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'What is the purpose of a reserve in the system?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004903	How does a transaction request a reserve in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'How does a transaction request a reserve in the system?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004904	What is the difference between a reserved grânul and an unreserved grânul?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'What is the difference between a reserved grânul and an unreserved grânul?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004905	Can multiple transactions request reserves for the same grânul at the same time?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'Can multiple transactions request reserves for the same grânul at the same time?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004906	Is it possible for a transaction to request a reserve for a grânul that is already reserved by another transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'Is it possible for a transaction to request a reserve for a grânul that is already reserved by another transaction?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004907	How does the SGBD determine whether to grant a reserve request or not?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'How does the SGBD determine whether to grant a reserve request or not?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004908	"What is the meaning of the term ""incompatible"" in the context of reserves?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'What is the meaning of the term ""incompatible"" in the context of reserves?'  "
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004909	Can a transaction request a reserve for a grânul using more than one modality (e.g., both S and X)?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'Can a transaction request a reserve for a grânul using more than one modality (e.g., both S and X)?'  
C001500049	Gestio╠ü de transaccions	7.1. Petició i alliberament de reserves	synthetic_question	reserva d'un grànul abans de poder-hi operar. Inicialment, hi ha dos tipus o modalitats de reserves: les reservescompartides3, o reserves S, que permeten dur a terme lectures del grànul, i les reservesexclusives4, o reserves X, que permeten fer lectures i escriptures. Per demanar una reserva d'un grànul G, amb modalitat m (S o X), una transacció ha d'executar una acció (o operació) d'adquisició de reserva, que anomenarem lock(G,m). Per a alliberar una reserva del grànul G, caldrà que la transacció executi una acció per alliberar la reserva, que anomenarem unlock(G). Quan una transacció demana una reserva sobre un grànul, l'SGBD decideix si la hi pot concedir, cosa que farà si el tipus de reserva que se li demana no és incompatible amb cap de les reserves que l'SGBD ja hagi concedit per al mateix grànul. La taula següent, coneguda com a matriudecompatibilitat, indica les modalitats de reserves que són compatibles entre elles i les modalitats que no ho són, en el cas de les reserves S, X: La taula prèvia ens mostra que, en un moment determinat, un grànul pot estar reservat per N transaccions amb modalitat S, o bé per una única transacció amb modalitat X. Més concretament, el significat de les accions lock(G,m) i unlock(G) executades per una transacció T queda descrit de la manera següent:	C00150004910	If a transaction requests a reserve for a grânul using modality X, but the SGBD does not have enough resources to fulfill the request, what happens to the reserve request?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.1. Petició i alliberament de reserves'; content: 'If a transaction requests a reserve for a grânul using modality X, but the SGBD does not have enough resources to fulfill the request, what happens to the reserve request?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005001	What is the purpose of the technique described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What is the purpose of the technique described in the paragraph?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005002	What is the difference between shared and exclusive reservation modes in the context of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What is the difference between shared and exclusive reservation modes in the context of the paragraph?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005003	How does the SGBD ensure that a reservation has been granted to a transaction T with the desired modality?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'How does the SGBD ensure that a reservation has been granted to a transaction T with the desired modality?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005004	What happens if a grânul G is reserved by multiple transactions with compatible reservation modes?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What happens if a grânul G is reserved by multiple transactions with compatible reservation modes?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005005	What is the result of attempting to grant a reservation to a transaction T when there are other transactions with incompatible reservation modes reserved on the same grânul G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What is the result of attempting to grant a reservation to a transaction T when there are other transactions with incompatible reservation modes reserved on the same grânul G?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005006	Can a transaction T execute if it requires a reservation but there are no available reservations with the desired modality?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'Can a transaction T execute if it requires a reservation but there are no available reservations with the desired modality?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005007	How does the SGBD maintain the list of transactions that have reservations granted over a particular grânul G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'How does the SGBD maintain the list of transactions that have reservations granted over a particular grânul G?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005008	Is it possible for two or more transactions to share the same grânul G simultaneously?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'Is it possible for two or more transactions to share the same grânul G simultaneously?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005009	If a transaction T requests a reservation over a grânul G that is already reserved by another transaction, what happens?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'If a transaction T requests a reservation over a grânul G that is already reserved by another transaction, what happens?'  
C001500050	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	(2)La tècnica de reserves S, X que veurem en aquest apartat s'aplica, amb petites variants, en SGBD com Informix o DB2. (3)En anglès, shared. (4)En anglès, exclusive. a) Si el grànul G no està reservat per a cap altra transacció, la reserva sobre el grànul G amb la modalitat volguda s'atorga a T. La transacció T pot continuar amb l'execució. L'SGBD necessita tenir constància que s'ha atorgat una reserva amb modalitat m a la transacció T. Per això, per cada possible grànul G de la BD, l'SGBD manté una llista que guarda quines transaccions tenen reserva concedida sobre el grànul G i amb quina modalitat. En definitiva, cada cop que s'atorga una reserva amb modalitat m sobre un grànul G en benefici d'una transacció T, l'SGBD afegeix una nova entrada (un parell <T, m>) a la llistadetransaccions que tenen reserva concedida sobre el grànul G. b) Si el grànul G està reservat per altres transaccions que tenen G reservat amb modalitats compatibles amb la modalitat que demana T, la reserva sobre el grànul G amb modalitat m s'atorga a T i l'SGBD afegeix una nova entrada a la llista de transaccions que tenen reserva concedida sobre el grànul G. La transacció T pot continuar amb l'execució. Treballant amb reserves S, X, aquest cas representa la situació en què la transacció T demana reserva S sobre un grànul G quan hi ha altres transaccions que també tenen reserva S sobre el mateix grànul G. Atès que les reserves S són compatibles entre elles, la reserva es pot atorgar a la transacció T. c) Si el grànul G està reservat per a altres transaccions amb modalitats incompatibles amb la modalitat que demana T, la reserva no es pot atorgar. En aquest cas, T bloqueja la seva execució. L'execució de T estarà bloquejada fins que T no pugui adquirir la reserva sobre el grànul G amb la modalitat volguda.	C00150005010	Can a transaction T be blocked from executing if it cannot acquire the required reservation over a grânul G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'Can a transaction T be blocked from executing if it cannot acquire the required reservation over a grânul G?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005101	"What is the purpose of the ""lock"" function in the context of transaction management?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What is the purpose of the ""lock"" function in the context of transaction management?'  "
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005102	"How does the ""enfortiment d'uneserva"" process work in the given scenario?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'How does the ""enfortiment d'uneserva"" process work in the given scenario?'  "
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005103	Why might a transaction attempt to convert its reservation from S to X?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'Why might a transaction attempt to convert its reservation from S to X?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005104	What happens if there is no transaction working on the granule G when a transaction tries to convert its reservation?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What happens if there is no transaction working on the granule G when a transaction tries to convert its reservation?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005105	How does the SGBD keep track of which transactions have blocked its execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'How does the SGBD keep track of which transactions have blocked its execution?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005106	"What is the significance of the ""modalitat m"" in the context of reservations and locks?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'What is the significance of the ""modalitat m"" in the context of reservations and locks?'  "
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005107	Can a transaction request multiple types of reservations (e.g., both S and X) on the same granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'Can a transaction request multiple types of reservations (e.g., both S and X) on the same granule G?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005108	If a transaction has a reservation S on a granule G and another transaction has a reservation X on the same granule G, how do they resolve their conflicting reservations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'If a transaction has a reservation S on a granule G and another transaction has a reservation X on the same granule G, how do they resolve their conflicting reservations?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005109	How does the SGBD ensure that only one transaction can execute on a given granule G at a time?	passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'How does the SGBD ensure that only one transaction can execute on a given granule G at a time?'  
C001500051	Gestio╠ü de transaccions	1)Significatdel'operaciódelock(G,m)	synthetic_question	Treballant amb reserves S, X, aquest cas representa o bé una situació en què T demana reserva S sobre el grànul G i existeix una altra transacció que té atorgada una reserva X sobre el grànul G, o bé una situació en què T demana una reserva X sobre el grànul G i existeix una altra transacció que té una reserva (S o X) atorgada sobre el grànul G. Addicionalment, en aquest cas, hi ha una situació particular que cal considerar. Una transacció T que ha reservat un grànul G amb una reserva S pot intentar convertir-la a X, executant una acció de lock(G,X), però pot ser bloquejada si hi ha una altra transacció Ti que tenia una reserva S del mateix grànul. En cas que no hi hagi cap transacció Ti treballant sobre el grànul G, la reserva serà concedida a la transacció T i caldrà modificar l'entrada5 corresponent a T en la llista de transaccions que tenen reserva concedida sobre G. Aquest procés de transformar una reserva S a X en benefici d'una transacció es coneix com a enfortimentd'unareserva. L'SGBD necessita saber quines transaccions han bloquejat la seva execució perquè no han pogut adquirir una reserva amb modalitat m sobre un grànul G. Per fer-ho, l'SGBD manté, per a cada grànul de la BD, una cua de transacci- (5)Més concretament, caldrà modificar la modalitat de la reserva atorgada a T sobre el grànul G. ons bloquejades. En definitiva, quan una transacció bloqueja la seva execució, l'SGBD afegeix una entrada nova (un parell <T, m>) a la cuadetransaccions que estan bloquejades en espera d'adquirir una reserva sobre G.	C00150005110	"In what way does the ""enfortiment d'uneserva"" process relate to the overall goal of ensuring consistency among the data stored in the database?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '1)Significatdel'operaciódelock(G,m)'; content: 'In what way does the ""enfortiment d'uneserva"" process relate to the overall goal of ensuring consistency among the data stored in the database?'  "
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005201	What is the purpose of liberating the reserve that T has granted over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'What is the purpose of liberating the reserve that T has granted over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005202	How does the SGBD eliminate entries corresponding to T from the list of transactions with reserved funds over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'How does the SGBD eliminate entries corresponding to T from the list of transactions with reserved funds over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005203	What happens if there are blocked transactions waiting to acquire reservations over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'What happens if there are blocked transactions waiting to acquire reservations over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005204	How does the SGBD determine whether the transaction was compatible with other reserves granted over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'How does the SGBD determine whether the transaction was compatible with other reserves granted over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005205	Can a transaction continue executing after being unlocked using this process?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'Can a transaction continue executing after being unlocked using this process?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005206	What happens if the mode of operation is not compatible with existing reserves granted over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'What happens if the mode of operation is not compatible with existing reserves granted over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005207	Will the process of granting new reservations stop if there are no more reserves that can be granted over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'Will the process of granting new reservations stop if there are no more reserves that can be granted over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005208	Does the SGBD prioritize certain reservations over others when granting new reservations over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'Does the SGBD prioritize certain reservations over others when granting new reservations over the granule G?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005209	Are all transactions that were previously blocked due to lack of reservations over the granule G now able to execute after being unlocked?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'Are all transactions that were previously blocked due to lack of reservations over the granule G now able to execute after being unlocked?'  
C001500052	Gestio╠ü de transaccions	2)Significatdel'operaciód'unlock(G)	synthetic_question	a) Alliberar la reserva que T tenia concedida sobre el grànul G. Això implica que l'SGBD elimina l'entrada corresponent a T de la llista de transaccions que tenen reserva atorgada sobre el grànul G. b) Si hi ha transaccions bloquejades, l'SGBD, seguint l'ordre de la cua de transaccions bloquejades en espera d'adquirir reserva sobre el grànul G, farà les accions següents: Si la modalitat és compatible amb les altres reserves concedides sobre el grànul G, la reserva s'atorga. L'entrada corresponent a la transacció que estava bloquejada a la cua de transaccions en espera d'adquirir reserva sobre G passa a la llista de transaccions que tenen reserva atorgada sobre G. La transacció bloquejada pot reprendre l'execució. Aquest pas es repeteix fins que la cua de transaccions bloquejades en espera d'adquirir reserves sobre el grànul G quedi buida, o fins que trobem la primera reserva que no es pot concedir. Si la modalitat és incompatible amb les reserves concedides sobre el grànul G, la transacció continua bloquejada a la cua. En aquest cas, el procés d'atorgar noves reserves s'atura, amb l'objectiu d'evitar la inanició de les transaccions bloquejades.	C00150005210	Is it possible for a transaction to remain blocked even after being unlocked if there are still no available reservations over the granule G?	passage: document 'Gestio╠ü de transaccions'; paragraph: '2)Significatdel'operaciód'unlock(G)'; content: 'Is it possible for a transaction to remain blocked even after being unlocked if there are still no available reservations over the granule G?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005301	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'What is the purpose of the example given in the paragraph?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005302	What is the current status of the transactions T2, T3, and T5 according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'What is the current status of the transactions T2, T3, and T5 according to the paragraph?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005303	What is the reason why transaction T4 is blocked according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'What is the reason why transaction T4 is blocked according to the paragraph?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005304	If transaction T1 wants to release its reserve, which transactions would be able to acquire the reserved resource according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'If transaction T1 wants to release its reserve, which transactions would be able to acquire the reserved resource according to the paragraph?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005305	Why does transaction T4 continue to be blocked after the execution of the unlock(G) action?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'Why does transaction T4 continue to be blocked after the execution of the unlock(G) action?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005306	How do the modalities of the transactions T2, T3, and T5 affect their ability to acquire the reserved resource according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'How do the modalities of the transactions T2, T3, and T5 affect their ability to acquire the reserved resource according to the paragraph?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005307	Can transaction T4 acquire the reserved resource if it is released by transaction T1?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'Can transaction T4 acquire the reserved resource if it is released by transaction T1?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005308	What happens to the reserved resource when all the transactions have been executed and the resources have been allocated?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'What happens to the reserved resource when all the transactions have been executed and the resources have been allocated?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005309	Is there any external context needed to understand the situation described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'Is there any external context needed to understand the situation described in the paragraph?'  
C001500053	Gestio╠ü de transaccions	Exemple de transaccions bloquejades	synthetic_question	Suposem que en un moment determinat, sobre un grànul G tenim la transacció T1 amb reserva atorgada sobre G amb modalitat X. Addicionalment, tenim que les transaccions T2, T3 i T5 estan bloquejades a la cua de transaccions, en espera d'adquirir una reserva amb modalitat S sobre el grànul G. La transacció T4 també està bloquejada, però en aquest cas en espera d'adquirir una reserva sobre G amb modalitat X. Temporalment, les reserves que no s'han pogut adquirir vénen en l'ordre següent: de primer la que demana T2, després la de T3, a continuació la que demana T4 i finalment la de la transacció T5. La situació descrita donaria lloc a la situació que tot seguit es mostra d'una manera gràfica: Suposem ara que la transacció T1 vol alliberar la seva reserva, mitjançant l'execució d'una acció d'unlock(G). Si apliquem el procediment descrit, T2 i T3 adquiririen la reserva sobre el grànul G, ja que les modalitats que totes dues demanen (modalitat S) són compatibles entre elles. T4 continuaria bloquejada, atès que la modalitat que demana (X) és incompatible amb les que s'atorguen. El procés s'atura, malgrat que es podria atorgar la	C00150005310	Can the procedure described in the paragraph be applied to other scenarios involving multiple transactions and reserved resources?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple de transaccions bloquejades'; content: 'Can the procedure described in the paragraph be applied to other scenarios involving multiple transactions and reserved resources?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005401	What is the purpose of the policy FIFO in managing the queue of blocked transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'What is the purpose of the policy FIFO in managing the queue of blocked transactions?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005402	How does the policy FIFO affect the transaction T5 in the example given?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'How does the policy FIFO affect the transaction T5 in the example given?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005403	Why is it important to ensure that T4 acquires the reserve with the appropriate modality X?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'Why is it important to ensure that T4 acquires the reserve with the appropriate modality X?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005404	In what situation would T1 execute the unlock(G) function, according to the diagram shown?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'In what situation would T1 execute the unlock(G) function, according to the diagram shown?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005405	How does the execution of the unlock(G) function impact the state of the system, as depicted in the diagram?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'How does the execution of the unlock(G) function impact the state of the system, as depicted in the diagram?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005406	What is the main goal of the tutorial module described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'What is the main goal of the tutorial module described in the paragraph?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005407	How does the management of the queue of blocked transactions contribute to achieving this goal?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'How does the management of the queue of blocked transactions contribute to achieving this goal?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005408	Can you identify any potential issues or challenges associated with implementing the policy FIFO in practice?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'Can you identify any potential issues or challenges associated with implementing the policy FIFO in practice?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005409	How might these issues be addressed or mitigated?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'How might these issues be addressed or mitigated?'  
C001500054	Gestio╠ü de transaccions	Gestió de la cua de transaccions	synthetic_question	En aquest mòdul didàctic seguirem una política FIFO per gestionar la cua de transaccions bloquejades en espera d'adquirir reserva, malgrat que hi pot haver altres polítiques. reserva que ha demanat T5. Per tant, T5 continua bloquejada. La idea és aconseguir que en un moment o altre T4 aconsegueixi la reserva amb modalitat X que necessita sobre G. En conseqüència, després de l'execució de l'unlock(G) per part de T1, passaríem a una situació com la que tot seguit es mostra d'una manera gràfica:	C00150005410	In what ways could the use of the policy FIFO improve the overall performance and efficiency of the system, as compared to alternative approaches?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Gestió de la cua de transaccions'; content: 'In what ways could the use of the policy FIFO improve the overall performance and efficiency of the system, as compared to alternative approaches?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005501	What are the rules that transactions must follow when acquiring and releasing reservations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What are the rules that transactions must follow when acquiring and releasing reservations?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005502	What is the purpose of the first rule mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the purpose of the first rule mentioned in the paragraph?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005503	How does a transaction ensure that it has acquired a reserve before executing an action?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How does a transaction ensure that it has acquired a reserve before executing an action?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005504	What is the difference between a lock operation and an unlock operation in the context of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the difference between a lock operation and an unlock operation in the context of transactions?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005505	Can a transaction execute an action if it has not previously acquired a reserve?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Can a transaction execute an action if it has not previously acquired a reserve?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005506	What is the purpose of the third rule mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the purpose of the third rule mentioned in the paragraph?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005507	How does a transaction know whether it should use a reserve with mode S or X?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How does a transaction know whether it should use a reserve with mode S or X?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005508	What happens to a reserve once a transaction has finished executing all of its actions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What happens to a reserve once a transaction has finished executing all of its actions?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005509	Can a transaction execute multiple actions without releasing the reserve it acquired earlier?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Can a transaction execute multiple actions without releasing the reserve it acquired earlier?'  
C001500055	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	L'adquisició i alliberament de reserves per part de les transaccions han de seguir unes certes regles que fan que lestransaccionsestiguinbenformades. Aquestes regles són les següents: 1) Una transacció T no intentarà executar una acció de lectura o escriptura sobre un grànul G si prèviament no ha adquirit una reserva sobre el grànul G que li permeti fer l'acció que vol. Per simplicitat, suposarem que la petició de reserva sobre el grànul G s'executa just abans que l'execució de l'acció de lectura o escriptura. 2) Una transacció T no executarà una acció d'unlock(G) si prèviament no havia efectuat una operació de lock(G,m). 3) Una transacció T no torna a executar una acció de lock(G,m) si abans ja havia dut a terme l'acció de lock(G,m), llevat del cas en què entre totes dues accions s'hagi executat una acció d'unlock(G). Tanmateix, pot succeir que una transacció enforteixi una reserva adquirida prèviament. En el cas de reserves S, X, això vol dir que una transacció T pot executar una acció de lock(G,S) i després intentar enfortir la reserva, duent a terme una acció de lock(G,X) sense que enmig la transacció T hagi executat una operació d'unlock(G). 4) Arribarà un punt en el temps en què la transacció T alliberarà totes les reserves que tenia concedides. Finalment, assumirem que cada transacció pot executar les accions que tot seguit s'especifiquen. En les accions per a les quals calgui demanar reserves, també s'indiquen les modalitats de reserva que cada transacció ha d'adquirir, en el supòsit que l'SGBD treballi amb reserves S, X: 1)R(G)6:lecturadelgrànulG. La transacció només vol llegir el grànul. La transacció ha d'adquirir una reserva sobre G amb modalitat S abans d'intentar executar el R(G). (6)Les operacions de lectura (R(G)) es corresponen amb l'execució de sentències SQL de SELECT.	C00150005510	What is the relationship between reserves and the sentences SQL of SELECT used in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the relationship between reserves and the sentences SQL of SELECT used in the paragraph?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005601	What is the purpose of the reserve X in transactional writing?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the purpose of the reserve X in transactional writing?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005602	How does the reserve X acquired before executing an operation RU(G) benefit the transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How does the reserve X acquired before executing an operation RU(G) benefit the transaction?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005603	Can other transactions read the granule G while one transaction has made a reservation but not yet executed the write operation (W(G))?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Can other transactions read the granule G while one transaction has made a reservation but not yet executed the write operation (W(G))?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005604	Why might the use of reservations lead to deadlocks in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Why might the use of reservations lead to deadlocks in the system?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005605	What happens when there is an apparent deadlock in the system due to reservations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What happens when there is an apparent deadlock in the system due to reservations?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005606	Is it possible for a transaction to execute both read and write operations without acquiring separate reservations for each operation?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Is it possible for a transaction to execute both read and write operations without acquiring separate reservations for each operation?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005607	How does the transaction ensure that it has sufficient resources to perform both read and write operations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How does the transaction ensure that it has sufficient resources to perform both read and write operations?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005608	In what way does the use of reservations increase the level of concurrency in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'In what way does the use of reservations increase the level of concurrency in the system?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005609	Are there any drawbacks or limitations associated with using reservations in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Are there any drawbacks or limitations associated with using reservations in the system?'  
C001500056	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	2) RU(G)7: lectura amb intenció de modificació posterior del grànul G. La transacció, més endavant en el temps, voldrà executar una operació d'escriptura (W(G)) sobre el grànul. La transacció ha d'adquirir una reserva X sobre el grànul abans d'intentar executar el RU(G). Aquesta reserva, un cop adquirida, li permet fer tant l'operació de lectura com l'acció posterior d'escriptura. En aquest cas, la transacció també podria demanar una reserva S abans de fer l'acció de RU(G) i enfortir la reserva a X abans de fer l'operació de W(G). L'avantatge d'aquesta opció és que es permet que altres transaccions puguin llegir el grànul mentre la transacció que ha efectuat el RU(G) no vulgui efectuar el W(G), augmentant el nivell de concurrència. Aquesta opció té el desavantatge que és propensa a l'aparició d'abraçadesmortals (és a dir, esperes indefinides) entre les transaccions, que constitueix el principal problema inherent a les tècniques basades en reserves. Quan es produeix una abraçada mortal, l'SGBD només la pot solucionar cancel·lant alguna de les transaccions implicades en l'abraçada mortal. Atès que la cancel·lació de transaccions és un procés molt costós, l'SGBD tendeix a evitar les situacions que afavoreixen abraçades mortals. Per això, la transacció demana una reserva amb modalitat X quan se sap que la lectura tindrà associada posteriorment una acció d'escriptura. Un cop adquirida, aquesta modalitat de reserva permet que la transacció s'asseguri no solament la lectura del grànul G, sinó també l'escriptura posterior. 3)W(G):escripturadelgrànulG. Abans, d'una manera obligatòria, la transacció ha d'haver fet una operació de RU(G) i ha d'haver adquirit la reserva corresponent que li permet fer totes dues accions. Per tant, no necessita adquirir cap reserva addicional abans de fer l'acció d'escriptura.	C00150005610	How do reservations differ from locks in terms of their impact on concurrency and resource management in the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How do reservations differ from locks in terms of their impact on concurrency and resource management in the system?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005701	What is the purpose of COMMIT in a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the purpose of COMMIT in a transaction?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005702	How does ROLLBACK end a transaction in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How does ROLLBACK end a transaction in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005703	What happens to reserved resources when a transaction ends with COMMIT?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What happens to reserved resources when a transaction ends with COMMIT?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005704	Cancel·lació de resultats és el same thing as ROLLBACK in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Cancel·lació de resultats és el same thing as ROLLBACK in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005705	What is the difference between ABORT and ROLLBACK in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'What is the difference between ABORT and ROLLBACK in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005706	When does an SGBD descenda los resultats after an ABORT in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'When does an SGBD descenda los resultats after an ABORT in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005707	How does a transaction end with ABORT in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'How does a transaction end with ABORT in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005708	Are there any differences between the effects of COMMIT and ROLLBACK in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Are there any differences between the effects of COMMIT and ROLLBACK in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005709	In what situations might an SGBD choose to use ABORT instead of ROLLBACK in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'In what situations might an SGBD choose to use ABORT instead of ROLLBACK in Gestioedeut de transaccions?'  
C001500057	Gestio╠ü de transaccions	7.2. Transaccions ben formades	synthetic_question	4)COMMIT: la transacció vol acabar l'execució amb una operació de confirmació de resultats. Si no ho ha fet abans, en aquest punt alliberarà totes les reserves que havia adquirit durant l'execució. 5)ROLLBACK: la transacció vol acabar, d'una manera voluntària, l'execució amb una operació de cancel·lació de resultats. L'SGBD haurà de descartar-ne els resultats. Si no ho ha fet abans, en aquest punt, la transacció alliberarà totes les reserves que havia adquirit durant l'execució. 6)ABORT: l'SGBD ha decidit cancel·lar la transacció, i en descarta els resultats. L'SGBD farà els mateixos passos que en l'acció de ROLLBACK.	C00150005710	Is it possible to recover from an ABORT in Gestioedeut de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.2. Transaccions ben formades'; content: 'Is it possible to recover from an ABORT in Gestioedeut de transaccions?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005801	What type of transactions does the paragraph describe?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'What type of transactions does the paragraph describe?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005802	According to the paragraph, what is the purpose of the RU(G) operations?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'According to the paragraph, what is the purpose of the RU(G) operations?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005803	Can you identify the types of sentences that execute INSERT, DELETE, and UPDATE statements in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'Can you identify the types of sentences that execute INSERT, DELETE, and UPDATE statements in SQL?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005804	How do the RU(G) operations correspond to the execution of these sentence types?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'How do the RU(G) operations correspond to the execution of these sentence types?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005805	What is the focus of the paragraph - the insertion, deletion, or updating of data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'What is the focus of the paragraph - the insertion, deletion, or updating of data?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005806	In which situations might the technique of reserves S, X be applied, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'In which situations might the technique of reserves S, X be applied, according to the paragraph?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005807	"Can you explain the meaning of ""intentació d'actualització"" in this context?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'Can you explain the meaning of ""intentació d'actualització"" in this context?'  "
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005808	How do the examples of transactions following the reserve S, X technique relate to the overall topic of transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'How do the examples of transactions following the reserve S, X technique relate to the overall topic of transaction management?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005809	What is the main idea of the paragraph - to illustrate the importance of using appropriate techniques for managing transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'What is the main idea of the paragraph - to illustrate the importance of using appropriate techniques for managing transactions?'  
C001500058	Gestio╠ü de transaccions	Exemples de transaccions que segueixen la tècnica de reserves S, X	synthetic_question	Donades les transaccions següents: (7)Les operacions de lectura amb intenció d'actualització (RU(G)) es corresponen amb l'execució de sentències SQL d'INSERT, DELETE i UPDATE.	C00150005810	In what way does the use of the reserve S, X technique contribute to effective transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemples de transaccions que segueixen la tècnica de reserves S, X'; content: 'In what way does the use of the reserve S, X technique contribute to effective transaction management?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005901	What is the main issue associated with the transaction T1, according to the subapartat 7.4 of this module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the main issue associated with the transaction T1, according to the subapartat 7.4 of this module?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005902	How does the transaction T1 not meet the requirements for a well-formed transaction, as described in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the transaction T1 not meet the requirements for a well-formed transaction, as described in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005903	What is an example of a well-formed transaction, as described in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is an example of a well-formed transaction, as described in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005904	Why is it irrelevant which order reserves are released in, according to the convention mentioned in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Why is it irrelevant which order reserves are released in, according to the convention mentioned in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005905	What is the purpose of highlighting the need to strengthen the reserve initially allocated to the granule F in the second example transaction T2, as stated in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of highlighting the need to strengthen the reserve initially allocated to the granule F in the second example transaction T2, as stated in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005906	According to the subapartat 7.4, what is the reason why the transaction T1 does not have the required reservation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'According to the subapartat 7.4, what is the reason why the transaction T1 does not have the required reservation?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005907	Can you identify another example of a well-formed transaction, as described in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you identify another example of a well-formed transaction, as described in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005908	In the first example transaction T1, what is the consequence of not having the required reservation, as stated in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In the first example transaction T1, what is the consequence of not having the required reservation, as stated in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005909	How does the transaction T2 differ from the transaction T1, as described in the subapartat 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the transaction T2 differ from the transaction T1, as described in the subapartat 7.4?'  
C001500059	Gestio╠ü de transaccions	Vegeu també	synthetic_question	En el subapartat 7.4 d'aquest mòdul didàctic es tracta la problemàtica associada a les abraçades mortals. Un exemple de transacció (per exemple, T1) que no està ben formada, podria ser el següent: Els motius pels quals la transacció T1 no està ben formada són els següents: T1 fa un R(B) sense tenir la reserva pertinent i T1 no allibera la reserva adquirida sobre E. Un exemple de transacció (de nou, per exemple, T1) que està ben formada, seria: En el cas de reserves S, X, és irrellevant l'ordre en què una transacció allibera les reserves. Per convenció, assumirem que s'alliberen en el mateix ordre en què s'han adquirit. Un altre exemple de transacció ben formada (agafem ara la transacció T2) seria: En aquest exemple, és important destacar el fet que la transacció T2 ha necessitat enfortir la reserva que inicialment tenia atorgada sobre el grànul F.	C00150005910	Based on the information provided in the subapartat 7.4, what is the overall goal or objective of ensuring that transactions are well-formed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Based on the information provided in the subapartat 7.4, what is the overall goal or objective of ensuring that transactions are well-formed?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006001	What is the main purpose of the protocol de reserves en dues fases (PR2F)?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'What is the main purpose of the protocol de reserves en dues fases (PR2F)?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006002	How does the PR2F prevent interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'How does the PR2F prevent interference between transactions?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006003	What is an example of how the PR2F can improve the serializability of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'What is an example of how the PR2F can improve the serializability of transactions?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006004	Why do the authors mention that simply having well-formed transactions and using reserves is not enough to guarantee serializability?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'Why do the authors mention that simply having well-formed transactions and using reserves is not enough to guarantee serializability?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006005	What is the difference between a reserve and a regular transaction according to the PR2F?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'What is the difference between a reserve and a regular transaction according to the PR2F?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006006	Can you explain how the PR2F ensures that transactions never overtake each other during reading or writing operations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'Can you explain how the PR2F ensures that transactions never overtake each other during reading or writing operations?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006007	In what way does the use of the PR2F affect the performance of the system compared to not using it?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'In what way does the use of the PR2F affect the performance of the system compared to not using it?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006008	How does the PR2F handle conflicts between transactions when they try to access the same resource simultaneously?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'How does the PR2F handle conflicts between transactions when they try to access the same resource simultaneously?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006009	Can you provide an example scenario where the PR2F would be particularly useful in a real-world application?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'Can you provide an example scenario where the PR2F would be particularly useful in a real-world application?'  
C001500060	Gestio╠ü de transaccions	7.3. Protocol de reserves en dues fases	synthetic_question	Malgrat que els serveis de petició i alliberament de reserves que acabem de descriure i el fet de tenir transaccions ben formades són la base sobre la qual es construeix el control de la concurrència, no garanteixen res per si mateixos. Per exemple, si les transaccions reserven els grànuls just abans d'operar-hi i els alliberen immediatament després, és evident que es podrien produir exactament les mateixes interferències que si no es fa res, tal com mostra l'exemple següent: En l'horari previ, malgrat que disposa de transaccions ben formades i fa servir reserves S, X, tenim una interferència de lectura no repetible entre les transaccions T1 i T2, atès que la transacció T2 troba un valor diferent per al grànul A en cadascuna de les lectures que efectua. Si les transaccions haguessin estat correctes entre elles, això no hauria succeït mai. En conseqüència, caldrà afegir noves restriccions en l'adquisició i alliberament de reserves per part de les transaccions. Una transacció compleix el que s'anomena protocol de reserves en duesfases(PR2F) si reserva qualsevol grànul en la modalitat adequada abans d'operar-hi, i mai no adquireix o reforça una reserva després d'haver-ne alliberat qualsevol altra abans. Si totes les transaccions utilitzen el PR2F i confirmen els seus resultats obtindrem horaris seriables. Alternativament, d'una manera gràfica, podem veure el PR2F, tal com es mostra a continuació.	C00150006010	How might the PR2F be extended or modified to accommodate additional features or requirements in future versions of the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.3. Protocol de reserves en dues fases'; content: 'How might the PR2F be extended or modified to accommodate additional features or requirements in future versions of the system?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006101	What is the main topic discussed in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the main topic discussed in the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006102	What is the purpose of the eix d'abscisses in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the purpose of the eix d'abscisses in the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006103	In which phase does the transaction T begin its execution according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'In which phase does the transaction T begin its execution according to the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006104	"How many times does the word ""fase"" appear in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'How many times does the word ""fase"" appear in the paragraph?'  "
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006105	"According to the paragraph, what happens during the ""fase creixent""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'According to the paragraph, what happens during the ""fase creixent""?'  "
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006106	What is the purpose of the grànuls in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the purpose of the grànuls in the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006107	During which phase do the reserves remain maintained according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'During which phase do the reserves remain maintained according to the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006108	What is the time period represented by BoT8 in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the time period represented by BoT8 in the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006109	What is the time period represented by EoT9 in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the time period represented by EoT9 in the paragraph?'  
C001500061	Gestio╠ü de transaccions	Num.	synthetic_question	Per la seva banda, l'eix d'abscisses representa el pas del temps, la transacció T comença l'execució en un instant de temps determinat (representat BoT8) i acaba l'execució en un altre instant de temps (representat EoT9). Durant l'execució de T es distingeixen dues fases; en la fase coneguda com a fasecreixent, T demana les reserves que necessita i en la fase coneguda com a fase minvant, T allibera els grànuls que havia reservat prèviament. Entre totes dues fases, i durant un temps, les reserves es mantenen perquè la transacció pugui	C00150006110	Based on the paragraph, how would you describe the overall flow of the transaction T?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'Based on the paragraph, how would you describe the overall flow of the transaction T?'  
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006201	What is the main idea of the paragraph according to the theory of seriability?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the main idea of the paragraph according to the theory of seriability?'  
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006202	"What does the phrase ""correctes"" mean in the context of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What does the phrase ""correctes"" mean in the context of the paragraph?'  "
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006203	According to the paragraph, what has been studied in the subapartat 5.1 of the same module didactic?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'According to the paragraph, what has been studied in the subapartat 5.1 of the same module didactic?'  
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006204	"What is the purpose of the sentence ""D'acord amb la teoria de la seriabilitat""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the purpose of the sentence ""D'acord amb la teoria de la seriabilitat""?'  "
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006205	"In the context of the paragraph, what does the term ""interferències"" refer to?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'In the context of the paragraph, what does the term ""interferències"" refer to?'  "
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006206	How does the theory of seriability relate to the topic of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How does the theory of seriability relate to the topic of the paragraph?'  
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006207	Can you summarize the key point of the paragraph in one sentence?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can you summarize the key point of the paragraph in one sentence?'  
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006208	What is the author's tone in this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the author's tone in this paragraph?'  
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006209	"How does the use of the word ""seriables"" contribute to the overall meaning of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How does the use of the word ""seriables"" contribute to the overall meaning of the paragraph?'  "
C001500062	Gestio╠ü de transaccions	Recordeu	synthetic_question	D'acord amb la teoria de la seriabilitat, els horaris seriables són correctes, és a dir, no presenten interferències. Hem estudiat la teoria de la seriabilitat en el subapartat 5.1 d'aquest mateix mòdul didàctic.	C00150006210	Based on the paragraph, what can be inferred about the importance of understanding the theory of seriability in the field of gestió de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Based on the paragraph, what can be inferred about the importance of understanding the theory of seriability in the field of gestió de transaccions?'  
C001500063	Gestio╠ü de transaccions	(8)BoT vol dir begin of transaction.	synthetic_question	(9)EoT vol dir end of transaction. fer les operacions que vol en la BD. Un cop una transacció T allibera la seva primera reserva, ja no pot demanar més reserves. Per tant, abans d'alliberar la reserva, una transacció T ha d'estar segura que no necessita adquirir-ne de noves. Forçant que les transaccions segueixin aquest protocol, i bloquejant-les i reprenent-les d'acord amb les peticions i els alliberaments de reserves, l'SGBD aconsegueix alterar horaris no seriables per convertir-los en seriables. És important remarcar que el mateix SGBD genera les operacions de petició i alliberament de reserves. Ho fa d'una manera transparent, sense que el programador se n'hagi de preocupar, d'acord amb les accions de lectura i escriptura rebudes. En l'horari d'exemple previ, les transaccions –concretament, la transacció T2– no segueix el PR2F, atès que allibera una reserva sobre un grànul (acció número 3) que posteriorment tornarà a necessitar reservar (acció número 8). En definitiva, T2 es precipita alliberant la reserva que tenia concedida sobre el grànul i acaba barrejant peticions d'adquisició i alliberament de reserves. La gràfica d'adquisició i alliberament de reserves quedaria de la manera següent: Num. reserves Forçant que les transaccions segueixin el PR2F, l'horari d'exemple hauria que-	C00150006301	What is the main purpose of the transactions management system according to the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(8)BoT vol dir begin of transaction.'; content: 'What is the main purpose of the transactions management system according to the given paragraph?'  
C001500063	Gestio╠ü de transaccions	(8)BoT vol dir begin of transaction.	synthetic_question	(9)EoT vol dir end of transaction. fer les operacions que vol en la BD. Un cop una transacció T allibera la seva primera reserva, ja no pot demanar més reserves. Per tant, abans d'alliberar la reserva, una transacció T ha d'estar segura que no necessita adquirir-ne de noves. Forçant que les transaccions segueixin aquest protocol, i bloquejant-les i reprenent-les d'acord amb les peticions i els alliberaments de reserves, l'SGBD aconsegueix alterar horaris no seriables per convertir-los en seriables. És important remarcar que el mateix SGBD genera les operacions de petició i alliberament de reserves. Ho fa d'una manera transparent, sense que el programador se n'hagi de preocupar, d'acord amb les accions de lectura i escriptura rebudes. En l'horari d'exemple previ, les transaccions –concretament, la transacció T2– no segueix el PR2F, atès que allibera una reserva sobre un grànul (acció número 3) que posteriorment tornarà a necessitar reservar (acció número 8). En definitiva, T2 es precipita alliberant la reserva que tenia concedida sobre el grànul i acaba barrejant peticions d'adquisició i alliberament de reserves. La gràfica d'adquisició i alliberament de reserves quedaria de la manera següent: Num. reserves Forçant que les transaccions segueixin el PR2F, l'horari d'exemple hauria que-	C00150006302	How does the system ensure that transactions follow the correct order before starting a new one?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(8)BoT vol dir begin of transaction.'; content: 'How does the system ensure that transactions follow the correct order before starting a new one?'  
C001500063	Gestio╠ü de transaccions	(8)BoT vol dir begin of transaction.	synthetic_question	(9)EoT vol dir end of transaction. fer les operacions que vol en la BD. Un cop una transacció T allibera la seva primera reserva, ja no pot demanar més reserves. Per tant, abans d'alliberar la reserva, una transacció T ha d'estar segura que no necessita adquirir-ne de noves. Forçant que les transaccions segueixin aquest protocol, i bloquejant-les i reprenent-les d'acord amb les peticions i els alliberaments de reserves, l'SGBD aconsegueix alterar horaris no seriables per convertir-los en seriables. És important remarcar que el mateix SGBD genera les operacions de petició i alliberament de reserves. Ho fa d'una manera transparent, sense que el programador se n'hagi de preocupar, d'acord amb les accions de lectura i escriptura rebudes. En l'horari d'exemple previ, les transaccions –concretament, la transacció T2– no segueix el PR2F, atès que allibera una reserva sobre un grànul (acció número 3) que posteriorment tornarà a necessitar reservar (acció número 8). En definitiva, T2 es precipita alliberant la reserva que tenia concedida sobre el grànul i acaba barrejant peticions d'adquisició i alliberament de reserves. La gràfica d'adquisició i alliberament de reserves quedaria de la manera següent: Num. reserves Forçant que les transaccions segueixin el PR2F, l'horari d'exemple hauria que-	C00150006303	What happens if a transaction needs to request more reservations after it has already released its first reserve?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(8)BoT vol dir begin of transaction.'; content: 'What happens if a transaction needs to request more reservations after it has already released its first reserve?'  
C001500063	Gestio╠ü de transaccions	(8)BoT vol dir begin of transaction.	synthetic_question	(9)EoT vol dir end of transaction. fer les operacions que vol en la BD. Un cop una transacció T allibera la seva primera reserva, ja no pot demanar més reserves. Per tant, abans d'alliberar la reserva, una transacció T ha d'estar segura que no necessita adquirir-ne de noves. Forçant que les transaccions segueixin aquest protocol, i bloquejant-les i reprenent-les d'acord amb les peticions i els alliberaments de reserves, l'SGBD aconsegueix alterar horaris no seriables per convertir-los en seriables. És important remarcar que el mateix SGBD genera les operacions de petició i alliberament de reserves. Ho fa d'una manera transparent, sense que el programador se n'hagi de preocupar, d'acord amb les accions de lectura i escriptura rebudes. En l'horari d'exemple previ, les transaccions –concretament, la transacció T2– no segueix el PR2F, atès que allibera una reserva sobre un grànul (acció número 3) que posteriorment tornarà a necessitar reservar (acció número 8). En definitiva, T2 es precipita alliberant la reserva que tenia concedida sobre el grànul i acaba barrejant peticions d'adquisició i alliberament de reserves. La gràfica d'adquisició i alliberament de reserves quedaria de la manera següent: Num. reserves Forçant que les transaccions segueixin el PR2F, l'horari d'exemple hauria que-	C00150006304	Can the system force transactions to wait for specific actions or events before proceeding?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(8)BoT vol dir begin of transaction.'; content: 'Can the system force transactions to wait for specific actions or events before proceeding?'  
C001500063	Gestio╠ü de transaccions	(8)BoT vol dir begin of transaction.	synthetic_question	(9)EoT vol dir end of transaction. fer les operacions que vol en la BD. Un cop una transacció T allibera la seva primera reserva, ja no pot demanar més reserves. Per tant, abans d'alliberar la reserva, una transacció T ha d'estar segura que no necessita adquirir-ne de noves. Forçant que les transaccions segueixin aquest protocol, i bloquejant-les i reprenent-les d'acord amb les peticions i els alliberaments de reserves, l'SGBD aconsegueix alterar horaris no seriables per convertir-los en seriables. És important remarcar que el mateix SGBD genera les operacions de petició i alliberament de reserves. Ho fa d'una manera transparent, sense que el programador se n'hagi de preocupar, d'acord amb les accions de lectura i escriptura rebudes. En l'horari d'exemple previ, les transaccions –concretament, la transacció T2– no segueix el PR2F, atès que allibera una reserva sobre un grànul (acció número 3) que posteriorment tornarà a necessitar reservar (acció número 8). En definitiva, T2 es precipita alliberant la reserva que tenia concedida sobre el grànul i acaba barrejant peticions d'adquisició i alliberament de reserves. La gràfica d'adquisició i alliberament de reserves quedaria de la manera següent: Num. reserves Forçant que les transaccions segueixin el PR2F, l'horari d'exemple hauria que-	C00150006305	According to the example given in the paragraph, which transaction violates the PR2F rule and why?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(8)BoT vol dir begin of transaction.'; content: 'According to the example given in the paragraph, which transaction violates the PR2F rule and why?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006401	What is the purpose of the shaded cells in the transaction diagram?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'What is the purpose of the shaded cells in the transaction diagram?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006402	"What does the phrase ""estona que la transacció T1 està bloquejada"" mean in the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'What does the phrase ""estona que la transacció T1 està bloquejada"" mean in the given paragraph?'  "
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006403	According to the paragraph, what is the correct time for serialization?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'According to the paragraph, what is the correct time for serialization?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006404	"What is the meaning of ""sense interferències"" in the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'What is the meaning of ""sense interferències"" in the given paragraph?'  "
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006405	How does the shading of certain cells in the transaction diagram indicate that a transaction is blocked?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'How does the shading of certain cells in the transaction diagram indicate that a transaction is blocked?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006406	In which part of the transaction diagram do the shaded cells appear?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'In which part of the transaction diagram do the shaded cells appear?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006407	What is the relationship between the two transactions T1 and T2 mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'What is the relationship between the two transactions T1 and T2 mentioned in the paragraph?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006408	Why is it important to ensure that the time for serialization is correct without interference?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'Why is it important to ensure that the time for serialization is correct without interference?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006409	Can you describe the significance of the shaded cells in the transaction diagram in one sentence?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'Can you describe the significance of the shaded cells in the transaction diagram in one sentence?'  
C001500064	Gestio╠ü de transaccions	dat de la manera següent.	synthetic_question	Les cel·les ombrejades representen l'estona que la transacció T1 està bloquejada. Ara, l'horari és correcte (sense interferències) i, per tant, es pot serialitzar. L'horari en sèrie equivalent és T2; T1.	C00150006410	Based on the given paragraph, how would you summarize the main idea of the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'dat de la manera següent.'; content: 'Based on the given paragraph, how would you summarize the main idea of the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006501	What is the main purpose of discussing recoverability in the context of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the main purpose of discussing recoverability in the context of transactions?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006502	What is an example of an interference that may occur when transactions retrieve values from other transactions that cancel their execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is an example of an interference that may occur when transactions retrieve values from other transactions that cancel their execution?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006503	How does the author suggest ensuring that such situations do not occur?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the author suggest ensuring that such situations do not occur?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006504	What is the difference between the PR2F basic and the PR2F strict, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the difference between the PR2F basic and the PR2F strict, according to the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006505	Why is it important to use the PR2F strict protocol in certain situations, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Why is it important to use the PR2F strict protocol in certain situations, according to the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006506	What happens if all transactions complete the PR2F strict protocol, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What happens if all transactions complete the PR2F strict protocol, according to the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006507	How does the use of the PR2F strict protocol prevent cancelations in cascade, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the use of the PR2F strict protocol prevent cancelations in cascade, according to the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006508	What is the consequence of not using the PR2F strict protocol, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the consequence of not using the PR2F strict protocol, according to the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006509	In what way does the PR2F strict protocol ensure that transactions do not work with unconfirmed values, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In what way does the PR2F strict protocol ensure that transactions do not work with unconfirmed values, according to the passage?'  
C001500065	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Com ja sabem, hi ha interferències que es produeixen quan les transaccions recuperen valors d'altres transaccions que cancel·len l'execució. Perquè aquestes situacions no es produeixin, cal garantir la recuperabilitat dels horaris. Per exemple, l'horari següent (que no verifica el criteri de recuperabilitat) presenta una interferència de lectura no confirmada: Heu estudiat la recuperabilitat en el subapartat 5.2 d'aquest mòdul didàctic. Si les transaccions utilitzen el PR2F, l'horari podria quedar així: L'exemple previ mostra que el PR2F que acabem de veure (també conegut com a PR2F bàsic) és insuficient per a tractar aquestes situacions. Per això s'ha d'utilitzar una variant del protocol, el PR2F estricte. Una transacció compleix el PR2Festrictesi satisfà el PR2F (el bàsic) i, a més, no allibera cap reserva fins que no acaba l'execució. Si totes les transaccions compleixen el PR2F estricte, se'n garanteix no solament la seriabilitat, sinó també la recuperabilitat dels horaris. A més a més, també s'evita la possibilitat que es produeixin cancel·lacions en cascada de les transaccions. El PR2F estricte impedeix que cap transacció pugui treballar amb valors no confirmats. D'una manera gràfica, el podem representar tal com es mostra a continuació.	C00150006510	What is the graphical representation of the PR2F strict protocol, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the graphical representation of the PR2F strict protocol, according to the passage?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006601	What is the proposed transformation of the previous example's schedule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the proposed transformation of the previous example's schedule?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006602	How would the schedule be transformed if the previous example's hours were followed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'How would the schedule be transformed if the previous example's hours were followed?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006603	What is the current schedule like?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the current schedule like?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006604	How does the current schedule need to be changed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'How does the current schedule need to be changed?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006605	What is the purpose of the transformation according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the purpose of the transformation according to the paragraph?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006606	What is the new schedule supposed to look like after the transformation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What is the new schedule supposed to look like after the transformation?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006607	Will the new schedule be different from the previous example's schedule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'Will the new schedule be different from the previous example's schedule?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006608	In what way(s) will the new schedule differ from the previous example's schedule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'In what way(s) will the new schedule differ from the previous example's schedule?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006609	Why is it important to transform the schedule according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'Why is it important to transform the schedule according to the paragraph?'  
C001500066	Gestio╠ü de transaccions	Num.	synthetic_question	Veiem ara com quedaria transformat l'horari d'exemple previ si se segueix el	C00150006610	What benefits might the transformation bring, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Num.'; content: 'What benefits might the transformation bring, according to the paragraph?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006701	What is the purpose of using PR2F strict in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'What is the purpose of using PR2F strict in transaction management?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006702	What is the advantage of using PR2F strict according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'What is the advantage of using PR2F strict according to the paragraph?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006703	Can you describe the problem that PR2F strict solves in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'Can you describe the problem that PR2F strict solves in transaction management?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006704	How does PR2F strict simplify the implementation and use of the system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'How does PR2F strict simplify the implementation and use of the system?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006705	What is the difference between T1 and T2 in the context of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'What is the difference between T1 and T2 in the context of the paragraph?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006706	Why is there no mention of T2 in the horarium en sèrie equivalent?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'Why is there no mention of T2 in the horarium en sèrie equivalent?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006707	"What is the significance of the phrase ""oficialment no ha existit mai"" in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'What is the significance of the phrase ""oficialment no ha existit mai"" in the paragraph?'  "
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006708	How does the use of PR2F strict ensure serializability in SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'How does the use of PR2F strict ensure serializability in SQL?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006709	What is the main benefit of using PR2F strict according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'What is the main benefit of using PR2F strict according to the paragraph?'  
C001500067	Gestio╠ü de transaccions	PR2F estricte:	synthetic_question	L'horari previ és correcte, sense cap interferència. Té associat com a horari en sèrie equivalent T1. No es fa cap menció a T2 en l'horari en sèrie equivalent, ja que T2 ha cancel·lat l'execució i, en conseqüència, oficialment no ha existit mai. El PR2F estricte s'usa en els SGBD per a garantir el nivell d'aïllament màxim de les transaccions (nivell SERIALIZABLE en l'SQL). Entre els avantatges que té, destaquem els següents: 1) Simplifica la implementació i l'ús del sistema: evita el problema d'haver d'establir el moment en què una transacció pot entrar a la segona fase, alliberant reserves i renunciant a demanar-les per a accedir a noves dades.	C00150006710	Can you explain how PR2F strict helps to guarantee the maximum level of isolation for transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'PR2F estricte:'; content: 'Can you explain how PR2F strict helps to guarantee the maximum level of isolation for transactions?'  
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006801	What is the topic studied in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the topic studied in the paragraph?'  
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006802	What is the purpose of studying the levels of isolation proposed by SQL standard in the subtopic 6.1 of this module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of studying the levels of isolation proposed by SQL standard in the subtopic 6.1 of this module?'  
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006803	What is the consequence of using higher levels of isolation in SQL standard?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the consequence of using higher levels of isolation in SQL standard?'  
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006804	How can the phenomenon of ghosts be treated in SQL standard?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How can the phenomenon of ghosts be treated in SQL standard?'  
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006805	What is the main idea of the last sentence of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the main idea of the last sentence of the paragraph?'  
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006806	"What does the phrase ""en contrapartida"" mean in the context of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What does the phrase ""en contrapartida"" mean in the context of the paragraph?'  "
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006807	"What is the meaning of ""bloquejar"" in the context of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the meaning of ""bloquejar"" in the context of the paragraph?'  "
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006808	"What is the significance of the word ""incloent"" in the last sentence of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the significance of the word ""incloent"" in the last sentence of the paragraph?'  "
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006809	"What is the purpose of mentioning ""informació interna o de control"" in the last sentence of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of mentioning ""informació interna o de control"" in the last sentence of the paragraph?'  "
C001500068	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem estudiat els nivells d'aïllament proposats per SQL estàndard en el subapartat 6.1 d'aquest mòdul didàctic. 2) Elimina la possibilitat de cancel·lacions en cascada. En contrapartida, el nivell de concurrència que permet assolir és més baix, atès que les dades estan bloquejades fins a l'acabament de les transaccions, i impedeix que altres transaccions hi tinguin accés. El cas particular dels fantasmes es pot tractar mitjançant l'ús de reserves per a fer les lectures i actualitzar qualsevol informació que s'hagi fet servir en la cerca de les dades, incloent-hi informació interna o de control.	C00150006810	What is the overall message of the paragraph regarding the management of transactions in SQL standard?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the overall message of the paragraph regarding the management of transactions in SQL standard?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006901	"What is the main idea discussed in paragraph 7.4 of the document ""Gestio̍ü de transaccions""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'What is the main idea discussed in paragraph 7.4 of the document ""Gestio̍ü de transaccions""?'  "
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006902	According to paragraph 7.4, what is the possibility that some transactions may remain indefinitely unfinished?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'According to paragraph 7.4, what is the possibility that some transactions may remain indefinitely unfinished?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006903	How does the use of reserves and the suspension of transaction execution introduce this possibility?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'How does the use of reserves and the suspension of transaction execution introduce this possibility?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006904	"Can you explain the term ""abraçadamortal"" used in paragraph 7.4?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'Can you explain the term ""abraçadamortal"" used in paragraph 7.4?'  "
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006905	Why do two or more transactions become blocked indefinitely according to paragraph 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'Why do two or more transactions become blocked indefinitely according to paragraph 7.4?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006906	What is the reason why one of the transactions involved must release an already obtained reserve to restart their execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'What is the reason why one of the transactions involved must release an already obtained reserve to restart their execution?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006907	In which situation might this occur, as described in paragraph 7.4?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'In which situation might this occur, as described in paragraph 7.4?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006908	How does the existence of such situations impact the overall management of transactions, as mentioned in the document title?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'How does the existence of such situations impact the overall management of transactions, as mentioned in the document title?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006909	Can you summarize the key point of paragraph 7.4 in three sentences?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'Can you summarize the key point of paragraph 7.4 in three sentences?'  
C001500069	Gestio╠ü de transaccions	7.4. Abraçades mortals	synthetic_question	La utilització de reserves i la suspensió d'execució de transaccions introdueix la possibilitat que algunes transaccions quedin en espera indefinida. Es diu que s'ha produït una abraçadamortalquan l'execució de dues transaccions o més queda bloquejada indefinidament pel fet que, per a reprendre'n l'execució, totes requereixen que una altra de les transaccions implicades alliberi alguna reserva ja obtinguda.	C00150006910	Based on paragraph 7.4, how would you describe the relationship between reserves and transaction execution in the context of the document's topic?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.4. Abraçades mortals'; content: 'Based on paragraph 7.4, how would you describe the relationship between reserves and transaction execution in the context of the document's topic?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007001	What is the main purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'What is the main purpose of the example given in the paragraph?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007002	According to the passage, which option do most SGBDs choose when dealing with deadlocks?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'According to the passage, which option do most SGBDs choose when dealing with deadlocks?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007003	How does an SGBD detect deadlocks according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'How does an SGBD detect deadlocks according to the passage?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007004	What is the recommended approach for dealing with deadlocks in SGBDs?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'What is the recommended approach for dealing with deadlocks in SGBDs?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007005	Why is it important to detect deadlocks in SGBDs?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'Why is it important to detect deadlocks in SGBDs?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007006	What is the difference between detecting deadlocks at the time of reservation and at irregular intervals?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'What is the difference between detecting deadlocks at the time of reservation and at irregular intervals?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007007	Can an SGBD break a cycle caused by a deadlock?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'Can an SGBD break a cycle caused by a deadlock?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007008	What happens if an SGBD cannot resolve a deadlock?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'What happens if an SGBD cannot resolve a deadlock?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007009	Is there a way to avoid canceling all transactions involved in a deadlock?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'Is there a way to avoid canceling all transactions involved in a deadlock?'  
C001500070	Gestio╠ü de transaccions	Exemple d'horari amb abraçada mortal	synthetic_question	Suposem que tenim tres transaccions (T1, T2 i T3) que volen executar les accions següents: L'horari següent presenta una situació d'abraçada mortal: Davant la possibilitat que es produeixin abraçades mortals, els SGBD basats en reserves han d'optar per una de les tres possibilitats següents: Prevenir-les abans que es produeixin. • Detectar-les i resoldre-les una vegada s'hagin produït. • Definir un temps d'espera màxim, que, si se supera, faci que es cancel·li automàticament la transacció. Gairebé tots els SGBD opten per la segona opció, que és l'única que tractarem en aquest mòdul didàctic. Un SGBD detecta les abraçades mortals buscant cicles d'espera. Pot fer aquesta cerca en moments diferents: Sempre que una transacció demana una reserva i no l'obté immediatament. Això permetria detectar les abraçades mortals molt de pressa, però no és freqüent, ja que afegiria un cost excessiu a les peticions de reserva. • A intervals de temps regulars, que no haurien de ser gaire llargs. • Quan hi ha transaccions sospitoses (com a mínim, dues), que estan més d'un temps determinat en espera. Una vegada detectada una abraçada mortal, l'única cosa que pot fer l'SGBD és trencar el cicle cancel·lant una de les transaccions implicades, o diverses. Per a escollir-ne una es pot mirar si alguna transacció participa en diverses abraçades mortals, a fi de trencar-les amb una cancel·lació única, o quina fa menys temps que s'executa (presumiblement, per a desfer menys feina), la transacció que ha fet menys canvis sobre la BD10, etc. Per acabar, també hi ha SGBD, que, un cop triada la transacció que s'ha de cancel·lar, en comptes de cancel·lar la transacció completa per resoldre una abraçada mortal, cancel·la únicament l'última sentència SQL11 executada amb un avís d'error, i dóna a l'aplicació (o l'usuari) la possibilitat d'avortar la cancel·lació o continuar la seva execució llançant noves sentències SQL. Això, que podria ser acceptable en certs entorns d'aplicació, vulnera una de les propietats de les transaccions, en concret, la propietat d'atomicitat. Per tant, des d'un punt de vista teòric seria incorrecte.	C00150007010	What is the consequence of violating atomicity property while resolving deadlocks in SGBDs?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'horari amb abraçada mortal'; content: 'What is the consequence of violating atomicity property while resolving deadlocks in SGBDs?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007101	What is the main topic discussed in this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'What is the main topic discussed in this paragraph?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007102	What is the purpose of using reserves in an SQL database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'What is the purpose of using reserves in an SQL database?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007103	How does the SQL database manage reserves?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'How does the SQL database manage reserves?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007104	What is the difference between reserves with modalities X and Y?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'What is the difference between reserves with modalities X and Y?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007105	Can transactions that only perform reads on the database be cancelled?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'Can transactions that only perform reads on the database be cancelled?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007106	At what level does the SQL database allow specifying the isolation level?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'At what level does the SQL database allow specifying the isolation level?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007107	"What is the significance of the phrase ""independent and self-explanatory"" in relation to the generated questions?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'What is the significance of the phrase ""independent and self-explanatory"" in relation to the generated questions?'  "
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007108	Why are reserves important in an SQL database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'Why are reserves important in an SQL database?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007109	What is the relationship between reserves and transaction cancellation in an SQL database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'What is the relationship between reserves and transaction cancellation in an SQL database?'  
C001500071	Gestio╠ü de transaccions	7.5. Reserves i relaxació del nivell d'aïllament	synthetic_question	Hem vist que en l'ús de reserves S, X, el fet de treballar amb transaccions ben formades i fer servir el PR2F estricte garanteix l'aïllament correcte del conjunt de transaccions que s'executen d'una manera concurrent. En altres paraules, els elements previs garanteixen la seriabilitat i la recuperabilitat dels horaris. Sabem també que l'SQL ens permet (per exemple amb la sentència SET TRANSACTION) especificar el nivell d'aïllament amb què treballaran les transaccions. Cada nivell d'aïllament evita certes interferències i en possibilita l'aparició d'altres. L'SGBD sempre gestiona les reserves d'escriptura amb el màxim rigor. Això implica que, amb independència del nivell d'aïllament especificat, totes les reserves amb modalitat X –aquestes reserves es corresponen amb l'execució d'accions RU(G) seguides de W(G)– es mantenen fins a l'acabament de la transacció. No obstant això, la manera d'utilitzar les reserves per a lectura –les reserves que es corresponen amb accions R(G)– pot variar, tal com indiquem a continuació: (10)En aquest sentit, les transaccions que només efectuen lectures sobre la BD són les transaccions ideals per a ser cancel·lades, ja que no canvien la BD i, en conseqüència, no cal que l'SGBD desfaci res. (11)Recordeu que a un alt nivell, les aplicacions i els usuaris treballen amb SQL.	C00150007110	How do applications and users work with SQL in relation to the topics discussed in this paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '7.5. Reserves i relaxació del nivell d'aïllament'; content: 'How do applications and users work with SQL in relation to the topics discussed in this paragraph?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007201	What is the topic of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the topic of the paragraph?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007202	What are the three levels of isolation in the READ COMMITTED mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What are the three levels of isolation in the READ COMMITTED mode?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007203	What is the difference between the REPEATABLE READ and SERIALIZABLE modes?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the difference between the REPEATABLE READ and SERIALIZABLE modes?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007204	Why does the READ UNCOMMITTED mode not use reservations for reading data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Why does the READ UNCOMMITTED mode not use reservations for reading data?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007205	How do reservations work in the READ COMMITTED mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How do reservations work in the READ COMMITTED mode?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007206	What is the purpose of using reservations in the READ COMMITTED mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of using reservations in the READ COMMITTED mode?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007207	Can transactions in the REPEATABLE READ mode be rolled back?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can transactions in the REPEATABLE READ mode be rolled back?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007208	What is the main difference between the REPEATABLE READ and SERIALIZABLE modes?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the main difference between the REPEATABLE READ and SERIALIZABLE modes?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007209	What is the purpose of the PR2F rule in the SERIALIZABLE mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of the PR2F rule in the SERIALIZABLE mode?'  
C001500072	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Les propietats de les transaccions s'expliquen en l'apartat 2 d'aquest mòdul didàctic. 1) En el nivellREAD UNCOMMITTED no s'efectua cap reserva per a lectura (tant per a la lectura de dades de la BD com de dades de control). Les dades que es llegeixen poden haver estat actualitzades per una transacció que encara no ha confirmat. En aquest nivell d'aïllament, les transaccions ni estan ben formades ni segueixen el PR2F. 2) En el nivell READ COMMITTED, les reserves S de lectura de cada grànul G es mantenen només fins després de cada lectura del grànul G. No s'efectua cap reserva de dades internes o de control. L'ús de reserves garanteix que el que es llegeix s'ha confirmat, ja que les reserves per a actualització sempre es mantenen fins al final de la transacció. En aquest nivell d'aïllament, malgrat que les transaccions estiguin ben formades, no segueixen el PR2F. 3) En el nivellREPEATABLE READ, les reserves S de lectura de cada grànul G es mantenen fins que la transacció no necessita tornar-les a llegir. Com que l'SGBD només pot estar segur que una transacció no necessitarà tornar a llegir unes dades fins a l'acabament de les transaccions, les reserves S es mantenen fins a l'acabament de la transacció. No s'efectua cap reserva de dades internes o de control. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte. 4) En el nivell SERIALIZABLE es demanen reserves S per a totes les dades que s'han llegit de la BD, incloent-hi també les dades de control. Les reserves es mantenen sempre fins que les transaccions finalitzen. En aquest nivell d'aïllament, les transaccions estan ben formades i segueixen el PR2F estricte, no solament per les dades que volen recuperar de la BD sinó també per les dades de control.	C00150007210	"What is the significance of the phrase ""vegeu també"" in the paragraph title?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the significance of the phrase ""vegeu també"" in the paragraph title?'  "
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007301	What is the main objective of the recovery mechanisms in an SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the main objective of the recovery mechanisms in an SGBD?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007302	How does the SGBD ensure atomicity and definitiveness of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'How does the SGBD ensure atomicity and definitiveness of transactions?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007303	What are the three situations that compromise the atomicity of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What are the three situations that compromise the atomicity of transactions?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007304	What is the difference between a voluntary rollback and an abort of a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the difference between a voluntary rollback and an abort of a transaction?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007305	How does the SGBD handle a situation where a transaction is involved in a deadlock?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'How does the SGBD handle a situation where a transaction is involved in a deadlock?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007306	What happens to active transactions when the system crashes or experiences a power failure?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What happens to active transactions when the system crashes or experiences a power failure?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007307	How does the SGBD recover from a crash or power failure while preserving the integrity of the data?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'How does the SGBD recover from a crash or power failure while preserving the integrity of the data?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007308	What is the purpose of the reconstruction phase in the recovery process?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the purpose of the reconstruction phase in the recovery process?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007309	How does the SGBD ensure the completeness and consistency of the recovered data after a disaster?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'How does the SGBD ensure the completeness and consistency of the recovered data after a disaster?'  
C001500073	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	Els mecanismesderecuperacióde l'SGBD han de garantir l'atomicitat i la definitivitat de les transaccions. L'objectiu és que mai no es perdin els canvis de les transaccions que han confirmat i que mai no es mantinguin canvis efectuats per transaccions que cancel·len. L'SGBD ha de tractar adequadament de les situacions següents: 1) La cancel·lació voluntària (ROLLBACK) d'una transacció a petició de l'aplicació. 2) La cancel·lació involuntària (ABORT) d'una transacció a causa de fallades de l'aplicació (per exemple, la realització d'una divisió per zero), la violació de restriccions d'integritat, decisions del mecanisme de control de concurrència de l'SGBD (per exemple, la transacció està implicada en una abraçada mortal), etc. 3) La caiguda del sistema (per exemple, a causa d'una avaria de programari o tall de llum), que provocaria la cancel·lació de totes les transaccions actives, és a dir en execució, en el moment de la caiguda. 4) La caiguda del sistema, en cas que hi pugui haver canvis efectuats per transaccions confirmades que encara no hagin estat transferits al dispositiu d'emmagatzematge permanent (per exemple, disc) on hi ha guardada la BD. 5) La destrucció total o parcial de la BD a causa de desastres (per exemple, un incendi o una inundació) o fallades dels dispositius (per exemple, un error d'escriptura al disc). Les tres primeres situacions comprometen la propietat d'atomicitat de les transaccions, mentre que les dues últimes comprometen la propietat de definitivitat de les transaccions. Podem distingir dues parts en la recuperació: 1) La restauració, que garanteix l'atomicitat i la definitivitat davant de cancel·lacions (voluntàries o involuntàries) de les transaccions i caigudes del sistema. 2) La reconstrucció, que recupera l'estat de la BD davant una pèrdua total o parcial de les dades que hi ha emmagatzemades en els dispositius d'emmagatzematge extern, a causa de fallades o desastres.	C00150007310	Can you describe a scenario where the SGBD would need to use both the restore and reconstruct phases in the recovery process?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'Can you describe a scenario where the SGBD would need to use both the restore and reconstruct phases in the recovery process?'  
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007401	What is the topic discussed in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the topic discussed in the paragraph?'  
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007402	"What is the purpose of using the term ""recuperación"" in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the purpose of using the term ""recuperación"" in the paragraph?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007403	"Who or what is being referred to when the word ""restauración"" is used in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'Who or what is being referred to when the word ""restauración"" is used in the paragraph?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007404	"According to the paragraph, what is the alternative term for ""recuperación""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'According to the paragraph, what is the alternative term for ""recuperación""?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007405	What is the main idea conveyed in the second sentence of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the main idea conveyed in the second sentence of the paragraph?'  
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007406	"How does the use of the word ""de vegades"" modify the meaning of the phrase ""recuperación"" in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'How does the use of the word ""de vegades"" modify the meaning of the phrase ""recuperación"" in the paragraph?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007407	"In which context might one use the term ""recuperación"" according to the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'In which context might one use the term ""recuperación"" according to the paragraph?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007408	"Can you summarize the definition of ""recuperación"" given in the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'Can you summarize the definition of ""recuperación"" given in the paragraph?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007409	"What is the difference between ""recuperación"" and ""restauración"" according to the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'What is the difference between ""recuperación"" and ""restauración"" according to the paragraph?'  "
C001500074	Gestio╠ü de transaccions	8. Recuperació	synthetic_question	De vegades també es parla de recuperació per a referir-se a la restauració.	C00150007410	"Why do we need to understand the distinction between ""recuperación"" and ""restauración"" in the context of the document?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '8. Recuperació'; content: 'Why do we need to understand the distinction between ""recuperación"" and ""restauración"" in the context of the document?'  "
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007501	What are the two types of operations that the restoration process should be able to perform according to the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'What are the two types of operations that the restoration process should be able to perform according to the given paragraph?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007502	What is the purpose of using memory intermediates (memòries intermèdies) in an SGBD system like Gestió de Transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'What is the purpose of using memory intermediates (memòries intermèdies) in an SGBD system like Gestió de Transaccions?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007503	How does the SGBD system use memories intermediates to improve performance?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'How does the SGBD system use memories intermediates to improve performance?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007504	What is the structure of the data used by the SGBD system to keep track of changes made by transactions, and how does it work?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'What is the structure of the data used by the SGBD system to keep track of changes made by transactions, and how does it work?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007505	Can you explain the difference between confirmed and unconfirmed writes in the context of the SGBD system?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'Can you explain the difference between confirmed and unconfirmed writes in the context of the SGBD system?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007506	How do the registries of changes, confirmations, and cancellations stored in the dietary help the SGBD system to manage transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'How do the registries of changes, confirmations, and cancellations stored in the dietary help the SGBD system to manage transactions?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007507	What is the purpose of the identifier of transaction, state earlier, and state later in the registries of changes?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'What is the purpose of the identifier of transaction, state earlier, and state later in the registries of changes?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007508	In what order are the registries of changes, confirmations, and cancellations stored in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'In what order are the registries of changes, confirmations, and cancellations stored in the dietary?'  
C001500075	Gestio╠ü de transaccions	8.1. Restauració	synthetic_question	La restauració ha de ser capaç d'efectuar dos tipus d'operacions: la restauraciócapenrere, que implica desfer els canvis d'una transacció avortada, i la restauraciócapendavant, que comporta refer els canvis d'una transacció confirmada. Un factor que cal tenir en compte és la utilització de memòries intermèdies12 per part de l'SGBD. Les memòries intermèdies són zones de memòria volàtil que l'SGBD fa servir per a guardar els grànuls de la BD als quals accedeixen les transaccions amb l'objectiu de millorar el rendiment del sistema. No totes les accions de lectura i escriptura de grànuls sol·licitades per les transaccions es tradueixen en operacions aplicades als dispositius físics, ja que algunes es poden dur a terme directament a les memòries intermèdies. Així doncs, en un moment determinat hi ha accions d'escriptura que no han arribat a la BD en memòria externa, i d'altres que sí que ho han fet. En general, i en el pitjor dels casos, això pot ser independent del fet que les transaccions hagin confirmat o no: hi pot haver escriptures confirmades que no hagin arribat a memòria externa i escriptures no confirmades que sí que ho hagin fet. Per a desfer canvis, i refer-ne, l'SGBD utilitza una estructura de dades amb informació de canvis, el dietari13, que guarda informació de les modificacions que han efectuat les transaccions, i de les confirmacions i les cancel·lacions d'aquestes. Els registres de canvis solen portar un identificador de transacció, l'estat anterior del grànul modificat i el posterior. Els registres de confirmació i cancel·lació han de contenir l'identificador de transacció. Tots aquests registres s'emmagatzemen en ordre cronològic. La figura següent mostra un possible fragment de dietari: (12)En anglès, buffers.	C00150007509	Can you provide an example of a possible fragment of the dietary showing the records of changes, confirmations, and cancellations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.1. Restauració'; content: 'Can you provide an example of a possible fragment of the dietary showing the records of changes, confirmations, and cancellations?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007601	What types of policies are available for transferring changes from intermediate memory to external memory?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What types of policies are available for transferring changes from intermediate memory to external memory?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007602	"How does the SGBD (presumably an acronym for ""Small General Purpose Database"") handle memory management for transactions?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD (presumably an acronym for ""Small General Purpose Database"") handle memory management for transactions?'  "
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007603	Can you describe the process of transferring changes from intermediate memory to external memory in the SGBD?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can you describe the process of transferring changes from intermediate memory to external memory in the SGBD?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007604	What is the purpose of storing data in intermediate memory before transferring it to external memory?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of storing data in intermediate memory before transferring it to external memory?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007605	Are there any performance benefits or drawbacks associated with using intermediate memory for transactional data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Are there any performance benefits or drawbacks associated with using intermediate memory for transactional data?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007606	How does the SGBD ensure data consistency when transferring changes from intermediate memory to external memory?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD ensure data consistency when transferring changes from intermediate memory to external memory?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007607	Is there a specific algorithm or technique used by the SGBD for transferring changes from intermediate memory to external memory?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Is there a specific algorithm or technique used by the SGBD for transferring changes from intermediate memory to external memory?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007608	Can you explain how the SGBD handles concurrent access to intermediate memory during transactional operations?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can you explain how the SGBD handles concurrent access to intermediate memory during transactional operations?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007609	Are there any limitations or restrictions placed on the amount of data that can be stored in intermediate memory?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Are there any limitations or restrictions placed on the amount of data that can be stored in intermediate memory?'  
C001500076	Gestio╠ü de transaccions	Nota	synthetic_question	Les polítiques per a transferir canvis de les memòries intermèdies a la memòria externa poden variar segons l'SGBD.	C00150007610	How does the SGBD optimize the transfer of changes from intermediate memory to external memory to minimize performance overhead?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD optimize the transfer of changes from intermediate memory to external memory to minimize performance overhead?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007701	What is the purpose of changing the state of grànul A according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'What is the purpose of changing the state of grànul A according to the passage?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007702	How does T2 change B after T1 changes A?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'How does T2 change B after T1 changes A?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007703	What is the new state of C after T1 changes it, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'What is the new state of C after T1 changes it, according to the passage?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007704	Why is it essential to write registers of change before confirming transactions, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'Why is it essential to write registers of change before confirming transactions, according to the passage?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007705	What happens to D when T3 changes it, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'What happens to D when T3 changes it, according to the passage?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007706	Can T1 abort the transaction after T2 confirms it, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'Can T1 abort the transaction after T2 confirms it, according to the passage?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007707	"What is the significance of the phrase ""desfer i refer transaccions"" in the passage?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'What is the significance of the phrase ""desfer i refer transaccions"" in the passage?'  "
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007708	According to the passage, what happens to the data in the memory intermediaries during the transaction process?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'According to the passage, what happens to the data in the memory intermediaries during the transaction process?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007709	How does the dietary allow desfer and refer transaccions, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'How does the dietary allow desfer and refer transaccions, according to the passage?'  
C001500077	Gestio╠ü de transaccions	(13)En anglès, log.	synthetic_question	Primerament, T1 canvia el grànul A, que passa a tenir un nou estat, A'. Després T2 canvia B, que ara tindrà un nou estat, B'. Per la seva banda, T1 canvia C, que passa a tenir un nou estat C'. Finalment, T2 confirma, T3 canvia D a un nou estat D' i T1 avorta. Perquè el dietari permeti desfer i refer transaccions és indispensable que s'hi escriguin els registres de canvi, a partir de les dades en les memòries intermèdies, abans que les modificacions arribin a la BD en memòria externa i que les transaccions confirmin.	C00150007710	What is the final state of the system after all transactions have been confirmed or aborted, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: '(13)En anglès, log.'; content: 'What is the final state of the system after all transactions have been confirmed or aborted, according to the passage?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007801	What is the purpose of maintaining a record of changes made to transactions in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What is the purpose of maintaining a record of changes made to transactions in the dietary?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007802	How does the system handle aborted transactions in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'How does the system handle aborted transactions in the dietary?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007803	"What is the difference between a ""registre de canvi"" and a ""punt de control"" in the dietary?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What is the difference between a ""registre de canvi"" and a ""punt de control"" in the dietary?'  "
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007804	Why is it important to identify the first register of change for each transaction in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'Why is it important to identify the first register of change for each transaction in the dietary?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007805	How does the system recover values from previous versions of transactions in the dietary after a fall?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'How does the system recover values from previous versions of transactions in the dietary after a fall?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007806	What is the main challenge in handling falls in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What is the main challenge in handling falls in the dietary?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007807	How does the system address this challenge when dealing with multiple active transactions and confirmed transactions with modifications not yet arrived at the external memory?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'How does the system address this challenge when dealing with multiple active transactions and confirmed transactions with modifications not yet arrived at the external memory?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007808	"Can you explain the concept of ""registres de transaccions confirmades"" in the dietary?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'Can you explain the concept of ""registres de transaccions confirmades"" in the dietary?'  "
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007809	How does the system ensure that all registries of change are properly linked to their corresponding transactions in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'How does the system ensure that all registries of change are properly linked to their corresponding transactions in the dietary?'  
C001500078	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	1) Quan una transacció avorta, tant si és d'una manera voluntària com involuntària, s'han de desfer els canvis que havia fet fins aquell moment. Així, els registres de canvi en el dietari es recorren cap enrere. Perquè això sigui eficient, s'han d'enllaçar tots els registres de canvi d'una mateixa transacció, i s'ha de poder identificar el primer registre de canvi per a cada transacció dins del dietari, per no haver de continuar buscant cap enrere. 2) Quan es produeix una caiguda, s'han de desfer els canvis de totes les transaccions que hi hagi actives, que es cancel·len, i refer els de totes les transaccions confirmades que puguin tenir modificacions que no hagin arribat a la BD en memòria externa. Per a fer-ho, de primer s'ha de recórrer el dietari cap enrere, i recuperar valors anteriors de les transaccions no confirmades, i després cap endavant, i recuperar valors posteriors de transaccions confirmades. La dificultat que planteja el comportament en cas de caigudes és saber fins a quin punt cal recórrer el dietari cap enrere i a partir de quin punt s'ha de recórrer cap endavant. És a dir, cal saber a partir de quina posició del dietari no hi haurà més registres de canvi ni de transaccions actives, ni de transaccions confirmades amb canvis que no hagin arribat a la memòria externa. Això se soluciona mitjançant un nou tipus de registre del dietari: els registres de punt de control. Un registredepuntdecontrolidentifica un moment en què l'SGBD porta a la memòria externa tots els grànuls modificats que hi ha a les memòries intermèdies. El registre conté, a més, una llista de totes les transaccions actives en aquest instant. Per desfer transaccions, l'SGBD només haurà de recórrer el dietari fins que trobi tots els registres de canvi de les transaccions actives en l'últim punt de control. Per refer-ne, només haurà de buscar registres de transaccions confirmades a	C00150007810	"What is the significance of ""recuperar valors anteriors de les transaccions no confirmades"" in the dietary?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What is the significance of ""recuperar valors anteriors de les transaccions no confirmades"" in the dietary?'  "
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007901	What is the main purpose of the policy of generating points of control in a Gestioêü de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What is the main purpose of the policy of generating points of control in a Gestioêü de transaccions?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007902	How often should an SGBD follow this policy of generating points of control, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'How often should an SGBD follow this policy of generating points of control, according to the paragraph?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007903	What happens to unconfirmed transactions if an SGBD always carries all changes to the memory external before confirming them?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What happens to unconfirmed transactions if an SGBD always carries all changes to the memory external before confirming them?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007904	Why might policies such as those described in point 2 of the paragraph have negative effects on performance or resource usage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'Why might policies such as those described in point 2 of the paragraph have negative effects on performance or resource usage?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007905	In what way does the inconvenience of these policies relate to the management of intermediate memories?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'In what way does the inconvenience of these policies relate to the management of intermediate memories?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007906	Can you explain why it is important to highlight the difference between carrying out updates and carrying out cancellations in the context of Gestioêü de transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'Can you explain why it is important to highlight the difference between carrying out updates and carrying out cancellations in the context of Gestioêü de transaccions?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007907	According to the paragraph, how does the policy of not carrying over changes to unconfirmed transactions affect the rendering of restoration processes?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'According to the paragraph, how does the policy of not carrying over changes to unconfirmed transactions affect the rendering of restoration processes?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007908	What is the significance of the example given in the paragraph regarding a massive update of data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'What is the significance of the example given in the paragraph regarding a massive update of data?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007909	How does the policy of carrying over changes to confirmed transactions impact the rendering of restoration processes, as mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'How does the policy of carrying over changes to confirmed transactions impact the rendering of restoration processes, as mentioned in the paragraph?'  
C001500079	Gestio╠ü de transaccions	Vegem com s'utilitza el dietari:	synthetic_question	partir d'aquest últim punt de control. Els SGBD han de seguir una política de generació de punts de control determinada, cosa que faran cada cert temps o segons qualsevol altre criteri. És important destacar que els SGBD, en funció de les polítiques que defineixin per transferir els grànuls modificats des de les memòries intermèdies fins a la memòria externa, poden simplificar considerablement els processos de restauració que hem descrit, tal com es mostra a continuació: 1) Si abans de confirmar una transacció l'SGBD sempre porta tots els canvis a la memòria externa, davant una caiguda mai no caldrà refer transaccions confirmades. 2) Si l'SGBD no porta canvis de transaccions no confirmades a la memòria externa, aleshores no caldrà desfer mai els canvis de transaccions cancel·lades. L'inconvenient d'aquestes polítiques és que poden empitjorar el rendiment o gastar massa recursos, a causa de les restriccions imposades en la gestió de memòries intermèdies. Per exemple, en el cas d'un SGBD que utilitzés la política 2, una transacció d'actualització massiva de dades hauria de guardar tots els grànuls que contenen aquestes dades canviades a les memòries intermèdies, com a mínim, fins a la confirmació de la transacció.	C00150007910	In what way could the use of different policies for transferring modified granules from intermediate memories to the memory external simplify or complicate the restoration processes described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegem com s'utilitza el dietari:'; content: 'In what way could the use of different policies for transferring modified granules from intermediate memories to the memory external simplify or complicate the restoration processes described in the paragraph?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008001	What is the purpose of maintaining multiple copies of data in a business continuity plan?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'What is the purpose of maintaining multiple copies of data in a business continuity plan?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008002	How often should backups be taken to ensure minimal loss of data in case of a disaster?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'How often should backups be taken to ensure minimal loss of data in case of a disaster?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008003	What is the difference between static and dynamic backup copies?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'What is the difference between static and dynamic backup copies?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008004	Why is it important to store backup copies in different physical locations?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'Why is it important to store backup copies in different physical locations?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008005	What type of information is essential to recover after a system failure or data loss?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'What type of information is essential to recover after a system failure or data loss?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008006	How does the diary log help in recovery efforts after a disaster?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'How does the diary log help in recovery efforts after a disaster?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008007	What is the advantage of using incremental backups instead of complete backups?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'What is the advantage of using incremental backups instead of complete backups?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008008	Can you explain the classification of backups based on their characteristics?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'Can you explain the classification of backups based on their characteristics?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008009	How often should the backup policy be reviewed and updated?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'How often should the backup policy be reviewed and updated?'  
C001500080	Gestio╠ü de transaccions	8.2. Reconstrucció	synthetic_question	Per a poder reconstruir l'estat d'una BD després d'una pèrdua parcial o total de dades, cal utilitzar dues fonts d'informació: 1) Una còpia de seguretat que contingui un estat correcte de la BD. 2) El contingut del dietari a partir del moment en què es va fer la còpia de seguretat. Pel que fa a la còpia de seguretat, per a cada BD s'ha d'establir una política de realització de còpies que garanteixi que la feina d'un període massa llarg de temps no es perdrà mai. Aquesta política ha de considerar aspectes com, per exemple, la localització física de la BD i de les còpies de seguretat (si són en el mateix lloc s'augmenta el risc de pèrdua). Naturalment, l'esforç que es faci ha de ser proporcional a la importància de la pèrdua d'informació. Podem fer una classificació de les còpies de seguretat segons les característiques següents: 1) Les còpies de seguretat poden ser estàtiques, també anomenades còpies en fred, o còpies dinàmiques, també anomenades còpies en calent. Les primeres exigeixen que s'aturi l'activitat dels usuaris i les aplicacions (si més no, les actualitzacions), en canvi, les segones, no. 2) Les còpies de seguretat poden ser completeso incrementals. Les completes copien tot l'estat de la BD, i les incrementals només els canvis efectuats des que s'ha fet la còpia anterior. La informació que guarden els registres del dietari és necessària per a fer les mateixes tasques que davant una caiguda del sistema, després de recuperar l'estat d'una còpia de seguretat. D'aquesta manera, es pot evitar la pèrdua de tots els canvis que s'hagin fet des de l'última còpia de seguretat. Per a fer-ho possible, és convenient emmagatzemar el dietari en dispositius físics diferents dels de la BD, perquè no es perdin juntament amb aquesta.	C00150008010	What factors should be considered when establishing a backup policy?	passage: document 'Gestio╠ü de transaccions'; paragraph: '8.2. Reconstrucció'; content: 'What factors should be considered when establishing a backup policy?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008101	What is the default mode of transactional work in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'What is the default mode of transactional work in PostgreSQL?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008102	How do we indicate the beginning of a transaction explicitly in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'How do we indicate the beginning of a transaction explicitly in PostgreSQL?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008103	What happens to unsaved changes when a transaction is cancelled in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'What happens to unsaved changes when a transaction is cancelled in PostgreSQL?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008104	Can we set transaction characteristics such as read-only or read-write using the SET TRANSACTION statement in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Can we set transaction characteristics such as read-only or read-write using the SET TRANSACTION statement in PostgreSQL?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008105	What is the default level of isolation used by PostgreSQL transactions if not specified otherwise?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'What is the default level of isolation used by PostgreSQL transactions if not specified otherwise?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008106	Are there any specific nivells of isolation available in PostgreSQL apart from READ COMMITTED and SERIALIZABLE?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Are there any specific nivells of isolation available in PostgreSQL apart from READ COMMITTED and SERIALIZABLE?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008107	How does PostgreSQL treat transactions that are started but not committed or rolled back?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'How does PostgreSQL treat transactions that are started but not committed or rolled back?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008108	Is it possible to specify characteristcs like read-only or read-write for a transaction at the time of starting it in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Is it possible to specify characteristcs like read-only or read-write for a transaction at the time of starting it in PostgreSQL?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008109	If an user doesn't specify any characteristic for a transaction, what kind of transaction will PostgreSQL consider it to be?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'If an user doesn't specify any characteristic for a transaction, what kind of transaction will PostgreSQL consider it to be?'  
C001500081	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	Per defecte, i si no s'indica expressament el contrari, PostgreSQL treballa amb transaccions implícites (aquest mode de treball també es coneix amb el nom de autocommit activat). Això vol dir que qualsevol grup de sentències SQL que seleccionem (per exemple, des del PgAdmin) i enviem a executar és tractat com una transacció. Si el grup de sentències enviat no genera cap error, els resultats esdevenen definitius en la BD. Altrament, els resultats són descartats per l'SGBD. Ja sabem que treballar amb transaccions implícites en un entorn d'aplicació real pot crear confusions sobre l'abast de cada transacció. Per això, PostgreSQL ens ofereix la sentència de l'SQL estàndard START TRANSACTION, i també una sentència pròpia, la sentència BEGIN, per a indicar d'una manera explícita el començament d'una transacció. Quan s'indica d'una manera explícita el començament d'una transacció, el PostgreSQL desactiva la modalitat autocommit i la transacció romandrà activa fins que en confirmem o en cancel·lem els resultats explícitament. Per a indicar l'acabament de la transacció disposem de les sentències de l'SQL estàndard COMMIT i ROLLBACK. Addicionalment, també tenim disponible la sentència SET TRANSACTION de l'SQL estàndard per a indicar les característiques (si la transacció és READ ONLY o READ WRITE, i el nivell d'aïllament) de la transacció, en cas que no s'hagi fet anteriorment; per exemple, amb les sentències START TRANSACTION o BEGIN. Si l'usuari no ha especificat cap característica per a les transaccions que vol executar, per defecte PostgreSQL considerarà que són transaccions READ WRITE que treballen amb un nivell d'aïllament READ COMMITTED. Malgrat que PostgreSQL permet especificar qualsevol dels nivells d'aïllament proposats per l'SQL estàndard (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ i SERIALIZABLE), de fet, internament només treballa amb dos nivells d'aïllament. Aquests nivells són els nivells de READ COMMITTED i de SERIALIZABLE:	C00150008110	Can we use the START TRANSACTION and BEGIN statements interchangeably to start a new transaction in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Can we use the START TRANSACTION and BEGIN statements interchangeably to start a new transaction in PostgreSQL?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008201	What is the purpose of the READ COMMITTED isolation level in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'What is the purpose of the READ COMMITTED isolation level in PostgreSQL?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008202	How does the READ COMMITTED isolation level prevent interference from update conflicts and uncommitted reads?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'How does the READ COMMITTED isolation level prevent interference from update conflicts and uncommitted reads?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008203	What kind of interferences can occur when using the READ COMMITTED isolation level in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'What kind of interferences can occur when using the READ COMMITTED isolation level in PostgreSQL?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008204	"Can you explain the concept of ""fantasies"" in the context of PostgreSQL transactions and isolation levels?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Can you explain the concept of ""fantasies"" in the context of PostgreSQL transactions and isolation levels?'  "
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008205	How does the READ COMMITTED isolation level affect the consistency of analysis in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'How does the READ COMMITTED isolation level affect the consistency of analysis in PostgreSQL?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008206	Is it possible to avoid interference from uncommitted reads and update conflicts in PostgreSQL without using the READ COMMITTED isolation level?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Is it possible to avoid interference from uncommitted reads and update conflicts in PostgreSQL without using the READ COMMITTED isolation level?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008207	What is the difference between the READ COMMITTED isolation level and other isolation levels available in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'What is the difference between the READ COMMITTED isolation level and other isolation levels available in PostgreSQL?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008208	When would you choose to use the READ COMMITTED isolation level in a PostgreSQL transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'When would you choose to use the READ COMMITTED isolation level in a PostgreSQL transaction?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008209	Are there any performance trade-offs associated with using the READ COMMITTED isolation level in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Are there any performance trade-offs associated with using the READ COMMITTED isolation level in PostgreSQL?'  
C001500082	Gestio╠ü de transaccions	9. Transaccions a PostgreSQL	synthetic_question	1) El nivell d'aïllament READ COMMITTED evita que la transacció es vegi involucrada en interferències d'actualització perduda i de lectura no confirmada. La transacció es podria veure implicada en interferències de lectura no repetible i d'anàlisi inconsistent (incloent-hi fantasmes).	C00150008210	Can you provide an example scenario where using the READ COMMITTED isolation level in PostgreSQL would be beneficial?	passage: document 'Gestio╠ü de transaccions'; paragraph: '9. Transaccions a PostgreSQL'; content: 'Can you provide an example scenario where using the READ COMMITTED isolation level in PostgreSQL would be beneficial?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008301	What is the topic of the current module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the topic of the current module?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008302	What is presented in the apartat 6 of this module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is presented in the apartat 6 of this module?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008303	What is the purpose of presenting these sentences in the module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of presenting these sentences in the module?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008304	Can you identify the main theme of the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you identify the main theme of the paragraph?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008305	What is the name of the current document?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the name of the current document?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008306	What is the name of the previous section discussed in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the name of the previous section discussed in the paragraph?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008307	What is the focus of the current paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the focus of the current paragraph?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008308	How many sentences are presented in the apartat 6 of the module?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How many sentences are presented in the apartat 6 of the module?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008309	Is there any specific requirement or prerequisite to work with transactions using SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Is there any specific requirement or prerequisite to work with transactions using SQL?'  
C001500083	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem presentat les sentències de l'SQL per treballar amb transaccions en l'apartat 6 d'aquest mòdul didàctic.	C00150008310	What is the overall objective of working with transactions using SQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the overall objective of working with transactions using SQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008401	What is the purpose of the NOTA paragraph in the 'Gestió de transaccions' document?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of the NOTA paragraph in the 'Gestió de transaccions' document?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008402	What is the default isolation level for transactions in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the default isolation level for transactions in PostgreSQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008403	How does PostgreSQL internally transform READ UNCOMMITTED isolation levels?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does PostgreSQL internally transform READ UNCOMMITTED isolation levels?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008404	Can you explain the difference between READ UNCOMMITTED and READ COMMITTED isolation levels in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can you explain the difference between READ UNCOMMITTED and READ COMMITTED isolation levels in PostgreSQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008405	In which situations might it be beneficial to use READ UNCOMMITTED isolation level in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'In which situations might it be beneficial to use READ UNCOMMITTED isolation level in PostgreSQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008406	How does the NOTA paragraph relate to the topic of transaction management in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the NOTA paragraph relate to the topic of transaction management in PostgreSQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008407	"What is the main idea behind the statement ""PostgreSQL internamente el transformará en READ COMMITTED""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the main idea behind the statement ""PostgreSQL internamente el transformará en READ COMMITTED""?'  "
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008408	Can you provide an example scenario where the READ UNCOMMITTED isolation level would not be appropriate in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can you provide an example scenario where the READ UNCOMMITTED isolation level would not be appropriate in PostgreSQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008409	How does the use of READ UNCOMMITTED or READ COMMITTED isolation levels affect the consistency of data in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the use of READ UNCOMMITTED or READ COMMITTED isolation levels affect the consistency of data in PostgreSQL?'  
C001500084	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de READ UNCOMMITTED, PostgreSQL internament el transformarà en READ COMMITTED.	C00150008410	"What is the significance of the phrase ""internamente el transformará"" in the context of the NOTA paragraph and PostgreSQL transaction management?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the significance of the phrase ""internamente el transformará"" in the context of the NOTA paragraph and PostgreSQL transaction management?'  "
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008501	What is the purpose of the note mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of the note mentioned in the paragraph?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008502	What are the two nivells d'aïllament available in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What are the two nivells d'aïllament available in PostgreSQL?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008503	How does PostgreSQL handle concurrent access to data in a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does PostgreSQL handle concurrent access to data in a database?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008504	What is the mechanism used by PostgreSQL to control concurrency?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the mechanism used by PostgreSQL to control concurrency?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008505	How do different versions of a granule reflect the actions of write transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How do different versions of a granule reflect the actions of write transactions?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008506	What happens when a transaction wants to access a granule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What happens when a transaction wants to access a granule?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008507	How does the SGBD choose which version of a granule to use for a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the SGBD choose which version of a granule to use for a transaction?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008508	Can reading only (R(G)) ever cause blocks or waiting?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can reading only (R(G)) ever cause blocks or waiting?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008509	Do applications and users see multiple versions of a granule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Do applications and users see multiple versions of a granule?'  
C001500085	Gestio╠ü de transaccions	Nota	synthetic_question	Si indiquem un nivell d'aïllament de REPEATABLE READ, PostgreSQL internament el transformarà en SERIALIZABLE. 2) Per la seva banda, el nivell d'aïllament SERIALIZABLE evita qualsevol tipus d'interferència. El fet que PostgreSQL només hagi de considerar internament dos nivells d'aïllament està relacionat amb el mecanisme per al control de concurrència que implementa. Aquest mecanisme es basa en el que es coneix com a model de control de concurrència multiversió (en anglès, multiversion concurrency control, abreujat MVCC) i que expliquem tot seguit. Per a cada grànul14 de la BD, l'MVCC manté diverses versions. Les diferents versions d'un mateix grànul reflecteixen les distintes accions d'escriptura (W(G)) que les transaccions READ WRITE realitzen. Quan una transacció vol accedir a un grànul, l'SGBD tria la versió més adequada a les necessitats de la transacció. Addicionalment, quan una transacció escriu un grànul, si l'SGBD autoritza l'escriptura, es crea una nova versió de grànul, i es conserven les versions anteriors. Aquesta nova versió de grànul només esdevé visible per a la resta de transaccions quan la transacció que ha creat la versió confirma els resultats. Els usuaris i les aplicacions no són conscients que hi ha múltiples versions d'un mateix grànul; l'SGBD internament decideix quina versió de grànul cal triar. En l'MVCC, les accions de només lectura (R(G)), mai no generen reserves ni tampoc no veuen mai bloquejada l'execució. Encara més, aquestes accions de lectura sempre llegeixen dades confirmades. L'SGBD tria la versió més adequada per als seus interessos. Que una versió sigui més adequada depèn del nivell d'aïllament amb què treballi la transacció que intenta executar les accions de lectura: 1) En cas que la transacció treballi amb un nivell d'aïllament READ COMMITTED, la versió de grànul que es tria en benefici de la transacció és la versió confirmada més recentment.	C00150008510	Who decides which version of a granule to use for a transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Who decides which version of a granule to use for a transaction?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008601	What is the purpose of choosing the confirmed version of the granule in the serializable isolation level?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the purpose of choosing the confirmed version of the granule in the serializable isolation level?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008602	How does MVCC handle updates (RU(G) followed by W(G)) in the exclusive reserve mode (modalitat de reserva X)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does MVCC handle updates (RU(G) followed by W(G)) in the exclusive reserve mode (modalitat de reserva X)?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008603	What is the protocol for reservations in two phases (PR2F) used in MVCC?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'What is the protocol for reservations in two phases (PR2F) used in MVCC?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008604	When does the creation of a new version of the granule become visible to other transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'When does the creation of a new version of the granule become visible to other transactions?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008605	Can you explain the significance of the exclusive reserve mode (modalidad de reserva X) in MVCC?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can you explain the significance of the exclusive reserve mode (modalidad de reserva X) in MVCC?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008606	How does the acquisition of a reserve authorize the creation of a new version of the granule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How does the acquisition of a reserve authorize the creation of a new version of the granule?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008607	In what situations might it be necessary to use the PR2F protocol for reservations in MVCC?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'In what situations might it be necessary to use the PR2F protocol for reservations in MVCC?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008608	Can you describe the difference between the serializable isolation level and the MVCC mechanism in terms of their approach to handling concurrent updates?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'Can you describe the difference between the serializable isolation level and the MVCC mechanism in terms of their approach to handling concurrent updates?'  
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008609	"How do the concepts of ""versió confirmada"" and ""grànul"" relate to each other within the context of MVCC?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'How do the concepts of ""versió confirmada"" and ""grànul"" relate to each other within the context of MVCC?'  "
C001500086	Gestio╠ü de transaccions	Nota	synthetic_question	2) Si la transacció treballa amb un nivell d'aïllament SERIALIZABLE, es tria la versió confirmada més recentment en la BD i que alhora sigui prèvia a l'instant d'inici de la transacció. Per la seva banda, en l'MVCC, les accions d'actualització (és a dir, les accions de RU(G) seguides d'accions W(G)) requereixen l'adquisició d'una reserva sobre el grànul en modalitat exclusiva (modalitat de reserva X) per part de la transacció que vol efectuar l'operació d'actualització. Aquesta reserva es manté –d'acord amb el protocol de reserves en dues fases (PR2F) estricte– fins a l'acabament de la transacció. L'adquisició de la reserva autoritza la creació d'una nova versió del grànul que només serà visible a la resta de transaccions quan la transacció	C00150008610	In which scenarios might it be beneficial to use the serializable isolation level instead of MVCC for managing concurrent updates?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Nota'; content: 'In which scenarios might it be beneficial to use the serializable isolation level instead of MVCC for managing concurrent updates?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008701	What is the name of the control mechanism described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'What is the name of the control mechanism described in the paragraph?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008702	In which database management systems does the MVCC model exist?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'In which database management systems does the MVCC model exist?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008703	What is the typical size of a granule in MVCC called?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'What is the typical size of a granule in MVCC called?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008704	Can you describe the purpose of the MVCC model according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'Can you describe the purpose of the MVCC model according to the paragraph?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008705	Which statement best describes the relationship between MVCC and other SGBDs mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'Which statement best describes the relationship between MVCC and other SGBDs mentioned in the paragraph?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008706	According to the passage, what is the unit of measurement used to quantify the size of a granule in MVCC?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'According to the passage, what is the unit of measurement used to quantify the size of a granule in MVCC?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008707	How many types of records are typically stored in an MVCC granule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'How many types of records are typically stored in an MVCC granule?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008708	What is the term used to describe the process of updating multiple rows simultaneously using MVCC?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'What is the term used to describe the process of updating multiple rows simultaneously using MVCC?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008709	Why might it be beneficial to use MVCC instead of traditional locking mechanisms, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'Why might it be beneficial to use MVCC instead of traditional locking mechanisms, according to the passage?'  
C001500087	Gestio╠ü de transaccions	MVCC	synthetic_question	El model de control de concurrència MVCC no solament es troba disponible en PostgreSQL, sinó que també l'implementen altres SGBD com, per exemple, Oracle i SQL Server. (14)La mida habitual de grànul en l'MVCC és el registre (o fila).	C00150008710	Based on the passage, how does MVCC differ from traditional locking mechanisms in terms of performance?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'MVCC'; content: 'Based on the passage, how does MVCC differ from traditional locking mechanisms in terms of performance?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008801	What type of actions does the paragraph describe?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What type of actions does the paragraph describe?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008802	What do sentences in SQL correspond to according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What do sentences in SQL correspond to according to the paragraph?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008803	Can the actions described in the paragraph be executed by both READ ONLY and READ WRITE transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can the actions described in the paragraph be executed by both READ ONLY and READ WRITE transactions?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008804	What is the purpose of the paragraph's description of action types and their corresponding SQL sentences?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the purpose of the paragraph's description of action types and their corresponding SQL sentences?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008805	How do the actions of only reading (R(G)) differ from those of both reading and writing (REaD WRiTE)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How do the actions of only reading (R(G)) differ from those of both reading and writing (REaD WRiTE)?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008806	In what way do the actions of only reading (R(G)) relate to transcations READ ONLY?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'In what way do the actions of only reading (R(G)) relate to transcations READ ONLY?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008807	Can the actions of only writing (W) be executed by READ WRITE transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can the actions of only writing (W) be executed by READ WRITE transactions?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008808	Why might it be important to distinguish between READ ONLY and READ WRITE transactions when discussing database management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Why might it be important to distinguish between READ ONLY and READ WRITE transactions when discussing database management?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008809	According to the paragraph, which transaction type would be more appropriate for performing only reads (R(G))?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'According to the paragraph, which transaction type would be more appropriate for performing only reads (R(G))?'  
C001500088	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions de només lectura (R(G)), en termes de l'SQL es corresponen amb sentències SELECT. Les accions de només lectura poden ser executades tant per transaccions READ ONLY com per transaccions READ WRITE.	C00150008810	How does the distinction between READ ONLY and READ WRITE transactions impact the design and implementation of databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How does the distinction between READ ONLY and READ WRITE transactions impact the design and implementation of databases?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008901	What type of actions does the passage describe as being able to update?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What type of actions does the passage describe as being able to update?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008902	According to the passage, what is required for updating actions to be successful?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'According to the passage, what is required for updating actions to be successful?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008903	Can updates be made without using transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can updates be made without using transactions?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008904	How do new versions of granules get created according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How do new versions of granules get created according to the passage?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008905	Why is it important to have a confirmed version of a granule before creating a new one?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Why is it important to have a confirmed version of a granule before creating a new one?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008906	What happens if changes are not confirmed before creating a new version of a granule?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What happens if changes are not confirmed before creating a new version of a granule?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008907	Does the passage mention anything about the authority to create new versions of granules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Does the passage mention anything about the authority to create new versions of granules?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008908	"What is the purpose of the sentence ""La creació de la nova versió del grànul es fa siempre a partir de la versió del grànul confirmada més recentment""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the purpose of the sentence ""La creació de la nova versió del grànul es fa siempre a partir de la versió del grànul confirmada més recentment""?'  "
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008909	In what way does the passage emphasize the importance of keeping track of changes made to granules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'In what way does the passage emphasize the importance of keeping track of changes made to granules?'  
C001500089	Gestio╠ü de transaccions	Recordeu	synthetic_question	Les accions d'actualització (RU(G) seguides de W(G)), en termes de SQL, es corresponen amb sentències INSERT, DELETE i UPDATE. Les accions d'actualització només poden ser realitzades per transaccions READ WRITE. autoritzada a crear la nova versió del grànul confirmi els resultats. La creació de la nova versió del grànul es fa sempre a partir de la versió del grànul confirmada més recentment, per a evitar que es puguin perdre canvis confirmats.	C00150008910	Based on the passage, how often should one create a new version of a granule after making changes to it?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Based on the passage, how often should one create a new version of a granule after making changes to it?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009001	What is the purpose of the MVCC mechanism in managing transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the purpose of the MVCC mechanism in managing transactions?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009002	How does the PR2F strict rule affect transaction reservations?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does the PR2F strict rule affect transaction reservations?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009003	"Can you explain the situation of ""abraçada mortal"" in the context of transaction management?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'Can you explain the situation of ""abraçada mortal"" in the context of transaction management?'  "
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009004	How does PostgreSQL resolve conflicts when multiple transactions attempt to modify the same data?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How does PostgreSQL resolve conflicts when multiple transactions attempt to modify the same data?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009005	What happens if an SGBD aborts one of the transactions involved in a conflict resolution process?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What happens if an SGBD aborts one of the transactions involved in a conflict resolution process?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009006	In what way does PostgreSQL handle errors reported by an application or user during transaction execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In what way does PostgreSQL handle errors reported by an application or user during transaction execution?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009007	"How do the concepts of ""reserve"" and ""modalitat X"" relate to transaction management in Gestió de Transaccions?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'How do the concepts of ""reserve"" and ""modalitat X"" relate to transaction management in Gestió de Transaccions?'  "
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009008	What is the significance of explaining the modalities of reserve in the apartat 7 of this module didactic?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'What is the significance of explaining the modalities of reserve in the apartat 7 of this module didactic?'  
C001500090	Gestio╠ü de transaccions	Vegeu també	synthetic_question	Hem explicat la modalitat de reserva X i el PR2F estricte en l'apartat 7 d'aquest mòdul didàctic. Evidentment, com que es fan servir reserves amb modalitat X per a gestionar les accions d'actualització que efectuen les transaccions, es pot produir una situació d'abraçada mortal. Per a solucionar-la caldrà que l'SGBD avorti alguna de les transaccions implicades. En el cas de PostgreSQL, no es pot conèixer a priori quina transacció és la que es cancel·larà. Un cop triada la transacció que es vol cancel·lar, el PostgreSQL descartarà tots els canvis que la transacció hagi produït i reportarà un error a l'usuari o aplicació que havia iniciat l'execució de la transacció. A continuació mostrem un parell d'exemples d'aplicació del mecanisme MVCC per al cas d'execució concurrent de transaccions READ ONLY i READ WRITE.	C00150009009	In which situations might it be necessary to use the MVCC mechanism to manage transactions in Gestió de Transaccions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Vegeu també'; content: 'In which situations might it be necessary to use the MVCC mechanism to manage transactions in Gestió de Transaccions?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009101	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'What is the purpose of the example given in the paragraph?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009102	What are the two transactions T1 and T2 doing in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'What are the two transactions T1 and T2 doing in the example?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009103	What is the difference between the nivell d'aïllament used by T1 and T2 in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'What is the difference between the nivell d'aïllament used by T1 and T2 in the example?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009104	How does the size of the granule affect the behavior of T2 in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'How does the size of the granule affect the behavior of T2 in the example?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009105	What is the outcome of the two transactions working with a level of serializability, according to the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'What is the outcome of the two transactions working with a level of serializability, according to the example?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009106	Why is it irrelevant which level of isolation T2 uses in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'Why is it irrelevant which level of isolation T2 uses in the example?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009107	What is the purpose of imagining a table with columns and rows in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'What is the purpose of imagining a table with columns and rows in the example?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009108	"What is the meaning of ""MVC"" in the context of the paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'What is the meaning of ""MVC"" in the context of the paragraph?'  "
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009109	Can you explain why T2 always shows the same behavior regardless of the level of isolation used?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'Can you explain why T2 always shows the same behavior regardless of the level of isolation used?'  
C001500091	Gestio╠ü de transaccions	Exemple d'aplicació del mecanisme MVCC	synthetic_question	Suposem que tenim una taula de comptes (clau primària subratllada) amb les columnes i les files que s'indiquen a continuació: Imaginem que tenim dues transaccions T1 (READ ONLY) i T2 (READ WRITE) que volen executar les sentències SQL següents: (15)De fet, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Independentment del nivell d'aïllament, T2 sempre mostrarà el mateix comportament. Suposant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE Vegem ara què passaria si les dues transaccions treballessin amb un nivell de SERIALIZABLE:	C00150009110	According to the example, what would happen if both transactions worked with a level of serializability?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exemple d'aplicació del mecanisme MVCC'; content: 'According to the example, what would happen if both transactions worked with a level of serializability?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009201	What is the specific issue mentioned in the paragraph regarding the mechanism MVCC?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What is the specific issue mentioned in the paragraph regarding the mechanism MVCC?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009202	How does the MVCC mechanism handle transactions READ WRITE when they also execute reading operations (SELECT)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'How does the MVCC mechanism handle transactions READ WRITE when they also execute reading operations (SELECT)?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009203	What is the example given in the paragraph to illustrate the problem?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What is the example given in the paragraph to illustrate the problem?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009204	How do the two transactions T1 and T2 interact with each other in the example?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'How do the two transactions T1 and T2 interact with each other in the example?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009205	What is the effect of the interaction between T1 and T2 on the account balance?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What is the effect of the interaction between T1 and T2 on the account balance?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009206	Why does the execution of T1's update operation cause an interference with T2's reading operation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'Why does the execution of T1's update operation cause an interference with T2's reading operation?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009207	What is the source of the problem according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What is the source of the problem according to the paragraph?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009208	How does the nivell d'aïllament (isolation level) of T1 affect its interaction with T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'How does the nivell d'aïllament (isolation level) of T1 affect its interaction with T2?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009209	What would be the expected outcome if T1 had executed independently without being affected by T2?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What would be the expected outcome if T1 had executed independently without being affected by T2?'  
C001500092	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Un cas especialment problemàtic és el tractament que el mecanisme MVCC fa de les transaccions READ WRITE quan aquestes també executen operacions de només lectura (execució de sentències SELECT de l'SQL). El problema es presenta perquè l'MVCC no efectua reserves amb modalitat S per gestionar aquestes operacions. (16)De nou, en l'exemple, és irrellevant el nivell d'aïllament amb què treballi T2. Agafem de nou la nostra taula de comptes amb les dades indicades inicialment. Suposem, a més, que tenim dues transaccions T1 i T2 de tipus READ WRITE que volen executar les sentències SQL següents: Considerant que la mida del grànul és la fila, vegem quins resultats produeix un horari com el que s'indica tot seguit, en cas que T1 treballi amb un nivell d'aïllament de READ COMMITTED i T2, amb un nivell d'aïllament de SERIALIZABLE 16: L'execució prèvia mostra que la transacció T1 ha vist interferida la seva execució per la transacció T2. Si T1 s'hagués executat d'una manera aïllada, sense encavalcaments amb l'execució de T2, la segona operació de SELECT que efectua recuperaria un valor per al saldo del compte corrent número 234509876 de 200 €, en comptes de 250 €. Encara més, el valor de 200 € seria el valor esperat per la transacció T1, atès que la primera sentència SELECT que executa T1 recupera un valor de 100 € i la transacció T1 incrementa el saldo únicament en 100 unitats. La font del problema és que l'operació d'UPDATE que executa T1 obligatòriament s'ha de basar en la nova fila que crea i confirma la transacció T2. L'execució d'aquest UPDATE internament es tradueix en una nova operació de lectura amb la intenció posterior d'actualització (és a dir, en una seqüència de RU(G) seguida d'un W(G)). En conseqüència, s'està produint una interferència de lectura no repetible. Com que la transacció T1 treballa amb un nivell d'aïllament de READ COMMITTED s'accepta el fet que la interferència de lectura no repetible es pugui produir (com efectivament passa).	C00150009210	Can you explain why the issue described in the paragraph is relevant to the topic of transaction management in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'Can you explain why the issue described in the paragraph is relevant to the topic of transaction management in databases?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009301	What is the mechanism called that resolves the problem of lost updates in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What is the mechanism called that resolves the problem of lost updates in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009302	How does the mechanism MVCC resolve the problem of lost updates in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'How does the mechanism MVCC resolve the problem of lost updates in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009303	What is the level of isolation called that ensures serializable transactions are executed one at a time in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What is the level of isolation called that ensures serializable transactions are executed one at a time in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009304	Why do new versions of granules always get created from the most recently confirmed version in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'Why do new versions of granules always get created from the most recently confirmed version in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009305	What happens if two transactions try to update the same data simultaneously in PostgreSQL using a SERIALIZABLE isolation level?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'What happens if two transactions try to update the same data simultaneously in PostgreSQL using a SERIALIZABLE isolation level?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009306	Can changes made by one transaction be lost if another transaction confirms those changes before the first transaction completes in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'Can changes made by one transaction be lost if another transaction confirms those changes before the first transaction completes in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009307	How does the MVCC mechanism prevent lost updates in PostgreSQL when multiple transactions are executing concurrently?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'How does the MVCC mechanism prevent lost updates in PostgreSQL when multiple transactions are executing concurrently?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009308	In what situation might the MVCC mechanism cause a delay in updating data in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'In what situation might the MVCC mechanism cause a delay in updating data in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009309	Can a transaction still execute successfully even if it reads stale data in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'Can a transaction still execute successfully even if it reads stale data in PostgreSQL?'  
C001500093	Gestio╠ü de transaccions	Tractament del mecanisme MVCC de les transaccions READ WRITE	synthetic_question	Atès que la creació d'una nova versió de grànul sempre s'efectua a partir de la versió confirmada més recentment (altrament, com ja s'ha explicat, es podrien perdre canvis confirmats), el mecanisme MVCC resol la problemàtica abans plantejada en el nivell d'aïllament SERIALIZABLE cancel·lant l'execució de la transacció que intenta actualitzar dades que ha llegit prèviament, si aquestes han estat canviades i confirmades per una altra transacció que s'està executant d'una manera concurrent. Sobre les nostres transaccions d'exemple T1 i T2, i considerant ara que totes dues treballen amb un nivell d'aïllament de SERIALIZABLE, l'execució concurrent de totes dues produiria els resultats que es presenten tot seguit:	C00150009310	How does the MVCC mechanism ensure that all transactions see a consistent view of the database in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Tractament del mecanisme MVCC de les transaccions READ WRITE'; content: 'How does the MVCC mechanism ensure that all transactions see a consistent view of the database in PostgreSQL?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009401	What is the purpose of the isolation level in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'What is the purpose of the isolation level in transaction management?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009402	How does the serializable isolation level ensure there is no interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How does the serializable isolation level ensure there is no interference between transactions?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009403	"Can you explain the meaning of ""proprietat d'isolament"" in the context of transaction management?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can you explain the meaning of ""proprietat d'isolament"" in the context of transaction management?'  "
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009404	In what way do transactions verify the property of isolation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'In what way do transactions verify the property of isolation?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009405	Is it possible for multiple transactions to occur simultaneously while maintaining serializable isolation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Is it possible for multiple transactions to occur simultaneously while maintaining serializable isolation?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009406	How does the serializable isolation level differ from other isolation levels such as repeatable read or snapshot?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How does the serializable isolation level differ from other isolation levels such as repeatable read or snapshot?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009407	Can you provide an example scenario where serializable isolation would be particularly useful?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can you provide an example scenario where serializable isolation would be particularly useful?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009408	Are there any limitations or drawbacks associated with using serializable isolation in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Are there any limitations or drawbacks associated with using serializable isolation in transaction management?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009409	How might serializable isolation impact the performance of transactional operations compared to other isolation levels?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'How might serializable isolation impact the performance of transactional operations compared to other isolation levels?'  
C001500094	Gestio╠ü de transaccions	Recordeu	synthetic_question	El nivell d'aïllament SERIALIZABLE garanteix que no es produeix cap tipus d'interferència, és a dir, garanteix que les transaccions verifiquen la propietat d'isolament.	C00150009410	Can you discuss how serializable isolation relates to other concepts in database systems, such as consistency models or recovery mechanisms?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Recordeu'; content: 'Can you discuss how serializable isolation relates to other concepts in database systems, such as consistency models or recovery mechanisms?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009501	What is the main advantage of MVCC over traditional locking mechanisms?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'What is the main advantage of MVCC over traditional locking mechanisms?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009502	How does MVCC ensure recoverability of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'How does MVCC ensure recoverability of transactions?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009503	Can you describe one of the key benefits of using MVCC for transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'Can you describe one of the key benefits of using MVCC for transaction management?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009504	What is one potential drawback of using MVCC, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'What is one potential drawback of using MVCC, according to the passage?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009505	How does MVCC handle conflicts between read-only and write transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'How does MVCC handle conflicts between read-only and write transactions?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009506	"What is the purpose of the ""VACUUM"" sentence in PostgreSQL, according to the passage?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'What is the purpose of the ""VACUUM"" sentence in PostgreSQL, according to the passage?'  "
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009507	Can you explain how MVCC facilitates the creation of dynamic backups of the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'Can you explain how MVCC facilitates the creation of dynamic backups of the database?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009508	According to the passage, what is one way to purge old versions of granules?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'According to the passage, what is one way to purge old versions of granules?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009509	How does MVCC affect the storage capacity requirements of the database, compared to traditional locking mechanisms?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'How does MVCC affect the storage capacity requirements of the database, compared to traditional locking mechanisms?'  
C001500095	Gestio╠ü de transaccions	T1.  T2.  Comentaris	synthetic_question	Per acabar aquest apartat, els avantatges principals de l'MVCC es poden resumir de la manera següent: 1) S'incrementa significativament el nivell de concurrència en relació amb les reserves S, X. Les transaccions READ ONLY mai no bloquegen l'execució a causa de les transaccions READ WRITE, ni a la inversa. Les transaccions READ WRITE només poden suspendre l'execució si entren en conflicte amb altres transaccions READ WRITE. 2) Sempre es garanteix la recuperabilitat dels horaris, pel fet que les transaccions sempre llegeixen dades confirmades. 3) Facilita els mecanismes de restauració cap enrere. Per a desfer els resultats d'una transacció que cancel·la l'execució, simplement cal destruir (alliberant l'espai) les versions que hagi pogut crear. 4) Facilita la realització de còpies de seguretat de la BD dinàmiques. D'altra banda, com a desavantatges principals de l'MVCC tenim: 1) Cal disposar d'una certa capacitat d'emmagatzematge (en relació amb les reserves S, X) per a absorbir la creació de noves versions de grànuls, i més si la BD s'actualitza freqüentment. Si calgués, l'SGBD pot purgar periòdicament versions antigues de grànuls, i alliberar l'espai que ocupaven aquestes versions. Si es vol forçar la purga de versions antigues, en el cas de PostgreSQL disposem de la sentència VACUUM. 2) La cancel·lació, en certs casos, de transaccions READ WRITE, pel fet que aquestes transaccions no generen reserves amb modalitat S per poder executar operacions de només lectura (sentències SELECT de l'SQL).	C00150009510	In which situations might the cancellation of read-write transactions occur in MVCC, according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'T1.  T2.  Comentaris'; content: 'In which situations might the cancellation of read-write transactions occur in MVCC, according to the passage?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009601	What is the objective of transaction management in databases?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'What is the objective of transaction management in databases?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009602	What are the four properties that must be guaranteed by transactions in a database?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'What are the four properties that must be guaranteed by transactions in a database?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009603	How does the atomicity property ensure data integrity in transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'How does the atomicity property ensure data integrity in transactions?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009604	What is the purpose of isolation in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'What is the purpose of isolation in transaction management?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009605	How does the consistency property ensure that the database remains in a consistent state after transactions have been executed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'How does the consistency property ensure that the database remains in a consistent state after transactions have been executed?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009606	What is the difference between serializability and isolation in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'What is the difference between serializability and isolation in transaction management?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009607	How do reservations contribute to ensuring the seriability and recoverability of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'How do reservations contribute to ensuring the seriability and recoverability of transactions?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009608	What is the purpose of recovery mechanisms in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'What is the purpose of recovery mechanisms in transaction management?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009609	How do developers identify and manage transactions in their applications?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'How do developers identify and manage transactions in their applications?'  
C001500096	Gestio╠ü de transaccions	Resum	synthetic_question	L'objectiu de la gestió de transaccions és garantir la integritat de la BD davant l'accés simultani de múltiples usuaris, i que s'eviti qualsevol pèrdua d'informació. L'accés a una BD es fa per mitjà de transaccions. Una transacció ha de verificar les propietats ACID; és a dir, l'atomicitat, que garanteix que s'executen totes les operacions o no se'n fa cap; la consistència, per garantir que la BD quedi en un estat correcte, en què es verifiquin les regles d'integritat que s'hagin definit en la BD; l'isolament, perquè les actualitzacions d'una transacció no interfereixin en la feina d'unes altres, i la definitivitat, que evita la pèrdua dels canvis de les transaccions que confirmen la seva execució. Per garantir l'isolament correcte de les transaccions, l'SGBD ha de garantir la seriabilitat i la recuperabilitat dels horaris. Per a fer-ho, els SGBD poden fer servir tècniques com les reserves o el model de control de concurrència multiversió (MVCC). D'altra banda, els mecanismes de recuperació s'encarreguen de garantir l'atomicitat i la definitivitat de les transaccions. Per a poder fer la recuperació (restauració o reconstrucció) de la BD, cal disposar de dietaris i de còpies de seguretat de la BD. També, el desenvolupador d'una aplicació ha d'identificar correctament les transaccions (d'acord amb els requeriments dels usuaris) i garantir la integritat de les dades en l'àmbit de l'aplicació. A més, ha de garantir que el nivell de concurrència permeti un rendiment correcte, considerant factors com ara la relaxació dels nivells d'aïllament o les esperes a causa de la interacció amb l'usuari.	C00150009610	What factors should developers consider when setting the level of concurrency for their applications?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Resum'; content: 'What factors should developers consider when setting the level of concurrency for their applications?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009701	What is the main activity proposed in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'What is the main activity proposed in the paragraph?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009702	How many sessions of work do you need to open to perform the activity?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'How many sessions of work do you need to open to perform the activity?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009703	What is the purpose of creating a table of accounts in the activity?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'What is the purpose of creating a table of accounts in the activity?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009704	Can you explain the mechanism of control of concurrency MVCC in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'Can you explain the mechanism of control of concurrency MVCC in PostgreSQL?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009705	Why is it important to mark explicitly the beginning of transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'Why is it important to mark explicitly the beginning of transactions?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009706	What changes may occur in the syntax of some SQL sentences in PostgreSQL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'What changes may occur in the syntax of some SQL sentences in PostgreSQL?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009707	In which session should you execute each transaction (T1 or T2)?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'In which session should you execute each transaction (T1 or T2)?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009708	How can you ensure that operations associated with each transaction are executed in order?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'How can you ensure that operations associated with each transaction are executed in order?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009709	What is the advantage of using explicit transactions over implicit ones?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'What is the advantage of using explicit transactions over implicit ones?'  
C001500097	Gestio╠ü de transaccions	Activitats	synthetic_question	1. Com a activitat us proposem que proveu els exemples que hem presentat en l'apartat 9 en relació amb el mecanisme de control de concurrència MVCC sobre PostgreSQL. Per a fer-ho, a més de crear la taula de comptes i inserir-hi les files indicades, caldrà que obriu dues sessions de treball diferents amb l'SGBD; per exemple, amb el PgAdmin. En cada sessió, caldrà executar una de les transaccions; per exemple, en la primera sessió la transacció T1 i en la segona sessió, la transacció T2. Heu de tenir especial cura d'executar les operacions associades a cada transacció en l'ordre que s'indica en el mòdul. Per a fer-ho, cal canviar d'una sessió a l'altra sessió i executar les operacions d'una en una. També és convenient que marqueu explícitament l'inici de les transaccions (i les característiques que tenen) per tal de desactivar l'execució implícita de transaccions. Finalment, penseu que hi pot haver canvis en la sintaxi d'alguna de les sentències SQL en PostgreSQL. En el material didàctic, d'una manera deliberada, s'ha fet servir la sintaxi de l'SQL estàndard. Per tant, cal revisar els manuals de sintaxi de PostgreSQL.	C00150009710	How does the use of MVCC affect the performance of the activity?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Activitats'; content: 'How does the use of MVCC affect the performance of the activity?'  
C001500098	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	1. Sigui un SGBD sense cap mecanisme de control de concurrència, i suposem que es produeix l'horari que mostrem a continuació (en què R = lectura, RU = lectura amb intenció d'escriptura, W = escriptura; les accions s'han numerat per a facilitar-ne la referència): a) Digueu si hi ha interferències, quines, entre quines transaccions i per a quins grànuls. Doneu el graf de precedència associat. b) És seriable l'horari anterior? I recuperable? Justifiqueu la resposta breument. 2. Tenim una taula R(X,Y) en què la clau primària està subratllada i les files d'aquesta taula tenen valors (1,1), (2,2), (3,3), etc. També tenim les transaccions següents: Abans que cap d'aquestes transaccions no s'executi, la suma dels valors de Y de la taula R és 2015 (aquesta suma inclou els valors de Y de 20, 30 i 40). També sabem que l'SGBD usa reserves S, X com a mecanisme de control de concurrència. Si les transaccions anteriors s'executen concurrentment utilitzant el nivell d'aïllament de SQL de SERIALIZABLE, expliqueu breument quines sumes poden ser produïdes per la transacció T1. Suposem que les lectures que duu a terme la transacció T1 s'executen sempre seguides. Considerem també que el grànul que es fa servir és la fila. 3. Sigui un SGBD sense cap mecanisme de control de concurrència, i suposem que es produeix l'horari que mostrem a continuació (en què R = lectura, RU = lectura amb intenció d'escriptura, W = escriptura; les accions s'han numerat per a facilitar-ne la referència): a) Digueu si hi ha interferències, quines, entre quines transaccions i per a quins grànuls. Doneu el graf de precedència associat. b) És seriable l'horari anterior? I recuperable? Justifiqueu la resposta breument. c) Suposem ara que les quatre transaccions treballen amb el mateix nivell d'aïllament i que el control de concurrència s'efectua mitjançant reserves S, X. Indiqueu com quedaria l'horari anterior per als nivells d'aïllament READ UNCOMMITTED i SERIALIZABLE. Per a cadascun d'aquests nivells, indiqueu també els horaris en sèrie equivalents que es produeixen a conseqüència d'aplicar-hi reserves.	C00150009801	What are the potential interferences between transactions, and which granules are affected?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'What are the potential interferences between transactions, and which granules are affected?'  
C001500098	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	1. Sigui un SGBD sense cap mecanisme de control de concurrència, i suposem que es produeix l'horari que mostrem a continuació (en què R = lectura, RU = lectura amb intenció d'escriptura, W = escriptura; les accions s'han numerat per a facilitar-ne la referència): a) Digueu si hi ha interferències, quines, entre quines transaccions i per a quins grànuls. Doneu el graf de precedència associat. b) És seriable l'horari anterior? I recuperable? Justifiqueu la resposta breument. 2. Tenim una taula R(X,Y) en què la clau primària està subratllada i les files d'aquesta taula tenen valors (1,1), (2,2), (3,3), etc. També tenim les transaccions següents: Abans que cap d'aquestes transaccions no s'executi, la suma dels valors de Y de la taula R és 2015 (aquesta suma inclou els valors de Y de 20, 30 i 40). També sabem que l'SGBD usa reserves S, X com a mecanisme de control de concurrència. Si les transaccions anteriors s'executen concurrentment utilitzant el nivell d'aïllament de SQL de SERIALIZABLE, expliqueu breument quines sumes poden ser produïdes per la transacció T1. Suposem que les lectures que duu a terme la transacció T1 s'executen sempre seguides. Considerem també que el grànul que es fa servir és la fila. 3. Sigui un SGBD sense cap mecanisme de control de concurrència, i suposem que es produeix l'horari que mostrem a continuació (en què R = lectura, RU = lectura amb intenció d'escriptura, W = escriptura; les accions s'han numerat per a facilitar-ne la referència): a) Digueu si hi ha interferències, quines, entre quines transaccions i per a quins grànuls. Doneu el graf de precedència associat. b) És seriable l'horari anterior? I recuperable? Justifiqueu la resposta breument. c) Suposem ara que les quatre transaccions treballen amb el mateix nivell d'aïllament i que el control de concurrència s'efectua mitjançant reserves S, X. Indiqueu com quedaria l'horari anterior per als nivells d'aïllament READ UNCOMMITTED i SERIALIZABLE. Per a cadascun d'aquests nivells, indiqueu també els horaris en sèrie equivalents que es produeixen a conseqüència d'aplicar-hi reserves.	C00150009802	Is the previous schedule serializable or recoverable?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'Is the previous schedule serializable or recoverable?'  
C001500098	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	1. Sigui un SGBD sense cap mecanisme de control de concurrència, i suposem que es produeix l'horari que mostrem a continuació (en què R = lectura, RU = lectura amb intenció d'escriptura, W = escriptura; les accions s'han numerat per a facilitar-ne la referència): a) Digueu si hi ha interferències, quines, entre quines transaccions i per a quins grànuls. Doneu el graf de precedència associat. b) És seriable l'horari anterior? I recuperable? Justifiqueu la resposta breument. 2. Tenim una taula R(X,Y) en què la clau primària està subratllada i les files d'aquesta taula tenen valors (1,1), (2,2), (3,3), etc. També tenim les transaccions següents: Abans que cap d'aquestes transaccions no s'executi, la suma dels valors de Y de la taula R és 2015 (aquesta suma inclou els valors de Y de 20, 30 i 40). També sabem que l'SGBD usa reserves S, X com a mecanisme de control de concurrència. Si les transaccions anteriors s'executen concurrentment utilitzant el nivell d'aïllament de SQL de SERIALIZABLE, expliqueu breument quines sumes poden ser produïdes per la transacció T1. Suposem que les lectures que duu a terme la transacció T1 s'executen sempre seguides. Considerem també que el grànul que es fa servir és la fila. 3. Sigui un SGBD sense cap mecanisme de control de concurrència, i suposem que es produeix l'horari que mostrem a continuació (en què R = lectura, RU = lectura amb intenció d'escriptura, W = escriptura; les accions s'han numerat per a facilitar-ne la referència): a) Digueu si hi ha interferències, quines, entre quines transaccions i per a quins grànuls. Doneu el graf de precedència associat. b) És seriable l'horari anterior? I recuperable? Justifiqueu la resposta breument. c) Suposem ara que les quatre transaccions treballen amb el mateix nivell d'aïllament i que el control de concurrència s'efectua mitjançant reserves S, X. Indiqueu com quedaria l'horari anterior per als nivells d'aïllament READ UNCOMMITTED i SERIALIZABLE. Per a cadascun d'aquests nivells, indiqueu també els horaris en sèrie equivalents que es produeixen a conseqüència d'aplicar-hi reserves.	C00150009803	Suppose now that all four transactions work with the same isolation level and use reserves S, X to control concurrency. How would the previous schedule change if we apply reserves to each transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'Suppose now that all four transactions work with the same isolation level and use reserves S, X to control concurrency. How would the previous schedule change if we apply reserves to each transaction?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009901	What is the purpose of the different registers described in the dietary?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'What is the purpose of the different registers described in the dietary?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009902	How does the SGBD handle transactions when there is a system failure during execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'How does the SGBD handle transactions when there is a system failure during execution?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009903	What is the significance of carrying out all changes made by a transaction to memory external before confirmation?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'What is the significance of carrying out all changes made by a transaction to memory external before confirmation?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009904	Can you explain the policy followed by the SGBD regarding the transfer of changes to memory external?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'Can you explain the policy followed by the SGBD regarding the transfer of changes to memory external?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009905	In what way does the SGBD ensure data consistency across all memories after a system failure?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'In what way does the SGBD ensure data consistency across all memories after a system failure?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009906	How does the SGBD recover the state of the database after a system failure if it does not carry over changes to memory external?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'How does the SGBD recover the state of the database after a system failure if it does not carry over changes to memory external?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009907	What happens to unsaved changes made by a transaction during a system failure?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'What happens to unsaved changes made by a transaction during a system failure?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009908	Does the SGBD maintain a dietary to keep track of changes made by each transaction?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'Does the SGBD maintain a dietary to keep track of changes made by each transaction?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009909	If the SGBD does not maintain a dietary, how does it ensure data consistency across all memories?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'If the SGBD does not maintain a dietary, how does it ensure data consistency across all memories?'  
C001500099	Gestio╠ü de transaccions	Exercicis d'autoavaluació	synthetic_question	4. Suposem que tenim el fragment següent del dietari: El significat dels diversos registres del dietari es descriu a continuació: • • Ti, inici_transacció: Ti inicia l'execució. Tj, escriure, P, v1, v2: Tj modifica P, el valor de P abans de la modificació és v1 i després de la modificació és v2. Ti, confirmar: Ti confirma els resultats. Ti, avortar: Ti cancel·la els resultats. Punt de control: registre de punt de control: <Llista de transaccions actives> a) Quines accions durà a terme el nostre SGBD per poder restaurar l'estat de la BD després de la caiguda del sistema si la política que segueix l'SGBD és la descrita en el material docent, és a dir, en cada punt de control es porta a memòria externa tots els canvis de les memòries intermèdies. b) Què canvia en la resposta de l'apartat a) si ara, en el moment de confirmar una transacció, l'SGBD també porta els canvis fets per aquesta transacció a memòria externa. 5. Considerem un SGBD que a l'efecte de recuperació treballa amb la política que es descriu tot seguit: Mai no porta canvis de transaccions en execució (és a dir, de transaccions que encara no han confirmat els resultats) des de les memòries intermèdies fins a memòria externa. • Quan una transacció confirma, l'SGBD transfereix els canvis que la transacció hagi fet des les memòries intermèdies fins a la memòria externa. En l'entorn descrit, podem afirmar que no cal que l'SGBD mantingui un dietari?	C00150009910	Can you explain why the SGBD chooses not to carry over changes to memory external for transactions that have not yet confirmed their results?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Exercicis d'autoavaluació'; content: 'Can you explain why the SGBD chooses not to carry over changes to memory external for transactions that have not yet confirmed their results?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010001	What is the topic of the given paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the topic of the given paragraph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010002	What is the name of the document being referred to in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the name of the document being referred to in the paragraph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010003	What is the name of the first exercise mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the name of the first exercise mentioned in the paragraph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010004	What is the purpose of the graph associated with the schedule, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the purpose of the graph associated with the schedule, according to the paragraph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010005	What is the conclusion drawn about the recoverability of the proposed schedule, based on the analysis of the graph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the conclusion drawn about the recoverability of the proposed schedule, based on the analysis of the graph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010006	What is the reason for the lack of recoverability, according to the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the reason for the lack of recoverability, according to the paragraph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010007	How many execution scenarios are described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'How many execution scenarios are described in the paragraph?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010008	In which order do the transactions execute in scenario 1?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'In which order do the transactions execute in scenario 1?'  
C001500100	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	a) El graf de precedència associat a l'horari és: Hi ha les interferències següents: • Anàlisi inconsistent entre T2 i T4 grànuls A i B, accions 5-6-12-13. F, accions 7-10-16. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul F que després llegirà T3, i T1 confirma abans que T3; de l'altra, la transacció T2 escriu els grànuls A i B que seran llegits per T4 i T2 confirma abans que T4. Finalment, T2 llegeix el grànul E que ha estat prèviament escrit per T3, però T2 confirma després que T3. 2. Com que les transaccions s'executen utilitzant el nivell d'aïllament SERIALIZABLE, no es produirà cap interferència entre elles. Per tant, l'execució de les nostres tres transaccions ha de donar el mateix resultat que el d'alguna de les execucions en sèrie. Les execucions en sèrie que podem tenir són les següents: T1; T2; T3 • T1, T3; T2 T2, T1; T3 • T3; T1; T2 • T2; T3; T1 • T3; T2; T1 • En els dos primers casos, la transacció T1 s'executa en primer lloc. Com que les accions de lectura de T1 es duen a terme totes seguides, T1 llegeix els valors inicials de Y, abans de que s'executin els UPDATE de T2 i els DELETE de T3. Per tant, la suma dels valors de Y llegida per T1 serà 2015. En el tercer cas, la transacció T1 s'executa després de la transacció T2, és a dir, després de dur a terme els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2105. En el quart cas, la transacció T1 s'executa després de dur a terme la transacció T3, és a dir, després d'executar els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 1965.	C00150010009	What is the difference in the value of Y read by T1 in each of the three execution scenarios?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the difference in the value of Y read by T1 in each of the three execution scenarios?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010101	What is the purpose of the example given in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the purpose of the example given in the paragraph?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010102	What are the two types of transactions mentioned in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What are the two types of transactions mentioned in the paragraph?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010103	How do the transactions T1, T2, and T3 interact with each other according to the given graph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'How do the transactions T1, T2, and T3 interact with each other according to the given graph?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010104	What is the outcome of the execution of transaction T1 according to the given graph?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the outcome of the execution of transaction T1 according to the given graph?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010105	Why does the author state that the horizon is not serializable?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'Why does the author state that the horizon is not serializable?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010106	What is the definition of an isolation level according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the definition of an isolation level according to the passage?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010107	What is the difference between a recoverable and non-recoverable horizon according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the difference between a recoverable and non-recoverable horizon according to the passage?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010108	How does the use of the READ UNCOMMITTED mode of aìllament affect the reservations of reading and writing according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'How does the use of the READ UNCOMMITTED mode of aìllament affect the reservations of reading and writing according to the passage?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010109	What is the effect of the interference of reading without repeating according to the passage?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the effect of the interference of reading without repeating according to the passage?'  
C001500101	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cinquè cas, la transacció T1 s'executa després de dur a terme T2 i T3, és a dir, després d'executar els UPDATE i els DELETE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Finalment, en el sisè cas, la transacció T1 s'executa després d'executar T3 i T2, és a dir, després d'executar els DELETE i els UPDATE. Per tant, la suma dels valors de Y llegida per T1 serà 2005. Resumint, els valors llegits per la transacció T1, tenint en compte que les transaccions s'executen utilitzant el nivell SERIALIZABLE, són els següents: 3. a) El graf de precedència associat a l'horari és: Lectura no repetible entre les transaccions T2 i T3 sobre el grànul A, accions número 4-7-12. • Actualització perduda entre les transaccions T1 i T4 sobre el grànul C, accions número 8-9-10-11. b) Com hem vist en l'apartat anterior, es produeixen interferències i, per tant, no es tracta d'un horari seriable. Pel que fa a la recuperabilitat, un horari és recuperable quan cap transacció Tx que llegeix o escriu un grànul escrit per una altra transacció Ty no confirma abans que confirmi Ty. En el cas de l'horari proposat, es tracta d'un horari recuperable. D'una banda, la transacció T1 escriu el grànul C prèviament escrit per la transacció T4, però T1 no confirma abans que T4; de l'altra, la transacció T2 llegeix els grànuls A i B escrits prèviament per les transaccions T3 i T1, i T2 no confirma abans que no ho facin aquestes. c) Amb el mode d'aïllament READ UNCOMMITTED no es fan reserves de lectura i les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. Com podeu veure, la interferència de lectura no repetible es continua produint; per tant, l'horari no és seriable i no hi ha cap horari en sèrie equivalent.	C00150010110	What is the conclusion reached by the author about the horizon proposed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the conclusion reached by the author about the horizon proposed?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010201	What is the purpose of the isolation level in the serializable mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the purpose of the isolation level in the serializable mode?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010202	How does the serializable mode ensure there is no interference between transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'How does the serializable mode ensure there is no interference between transactions?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010203	What is the difference between the shadow block and the actual lock in the serializable mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'What is the difference between the shadow block and the actual lock in the serializable mode?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010204	"Can you explain the meaning of ""seriable"" and ""recoverable"" in the context of transaction isolation levels?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'Can you explain the meaning of ""seriable"" and ""recoverable"" in the context of transaction isolation levels?'  "
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010205	In what way do the reserve of reading and writing affect the transaction in the serializable mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'In what way do the reserve of reading and writing affect the transaction in the serializable mode?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010206	How does the serializable mode guarantee that all transactions are executed in a consistent state?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'How does the serializable mode guarantee that all transactions are executed in a consistent state?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010207	Is it possible to have multiple transactions running concurrently in the serializable mode?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'Is it possible to have multiple transactions running concurrently in the serializable mode?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010208	Can you provide an example scenario where the serializable mode would be beneficial?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'Can you provide an example scenario where the serializable mode would be beneficial?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010209	How does the serializable mode differ from other isolation levels such as repeatable read or snapshot?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'How does the serializable mode differ from other isolation levels such as repeatable read or snapshot?'  
C001500102	Gestio╠ü de transaccions	Solucionari.  Exercicis d'autoavaluació.  1.	synthetic_question	En el cas del mode d'aïllament SERIALIZABLE, tant les reserves de lectura com les d'escriptura es mantenen fins al final de la transacció. En ombrejat es mostren els bloquejos de les transaccions que no poden aconseguir reserva. En aquest cas, el nivell d'aïllament garanteix que no es produeix cap tipus d'interferència (l'horari és seriable i recuperable). L'horari en sèrie equivalent és T4; T1; T2; T3.	C00150010210	Are there any limitations or drawbacks associated with using the serializable mode in a database system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Solucionari.  Exercicis d'autoavaluació.  1.'; content: 'Are there any limitations or drawbacks associated with using the serializable mode in a database system?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010301	What is the purpose of recurring through the diary in the'Gestió de transaccions' process?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'What is the purpose of recurring through the diary in the'Gestió de transaccions' process?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010302	Which transactions should be reversed according to the policy described in the paragraph?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'Which transactions should be reversed according to the policy described in the paragraph?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010303	Why is it not necessary to refer the changes made to confirmed transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'Why is it not necessary to refer the changes made to confirmed transactions?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010304	What is the significance of the last point of control in the diary?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'What is the significance of the last point of control in the diary?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010305	How does the diary help in reconstructing the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'How does the diary help in reconstructing the database?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010306	Can you explain the difference between the first change made by T3 and the last point of control?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'Can you explain the difference between the first change made by T3 and the last point of control?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010307	Why is it important to refer the actions taken by T4 in instant 14?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'Why is it important to refer the actions taken by T4 in instant 14?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010308	According to the policy described, what should be done with the changes made to confirmed transactions?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'According to the policy described, what should be done with the changes made to confirmed transactions?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010309	In which situations might the diary be useful in restoring the database?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'In which situations might the diary be useful in restoring the database?'  
C001500103	Gestio╠ü de transaccions	4.	synthetic_question	a) Caldrà recórrer cap enrere el dietari per a desfer els canvis de les transaccions no confirmades. És a dir, caldrà recórrer cap enrere el dietari per a trobar tots els registres de modificació de les transaccions actives des de l'últim punt de control. En el nostre cas, caldrà desfer l'acció que T2 ha fet en l'instant 8. De T3 no s'haurà de desfer res, perquè els seus canvis no són a la memòria externa (el primer canvi de T3 es produeix després del darrer punt de control). A més, caldrà refer els canvis de les transaccions confirmades. Per tant, s'haurà de recórrer cap endavant el dietari i buscar els registres de canvi de les transaccions confirmades des de l'últim punt de control. En el nostre cas caldrà refer l'acció que T4 ha fet en l'instant 14. b) Amb aquesta política no cal refer els canvis de les transaccions confirmades. Per tant, el canvi respecte a l'apartat a) és que no caldrà refer l'acció de T4 en l'instant 14. 5. No, tot i que pugui semblar que el dietari no sigui necessari en l'SGBD descrit, hem de recordar que el dietari no solament s'utilitza per a restaurar la BD, sinó que també s'usa per a poder reconstruir la BD; per exemple, en el cas que el dispositiu d'emmagatzematge extern que guarda la BD perdi les dades a causa, per exemple, d'una avaria o catàstrofe (incendi, inundació, etc.).	C00150010310	What is the main idea behind the 'Gestió de transaccions' process?	passage: document 'Gestio╠ü de transaccions'; paragraph: '4.'; content: 'What is the main idea behind the 'Gestió de transaccions' process?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010401	"What is the definition of ""abraçada mortal"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the definition of ""abraçada mortal"" according to the given paragraph?'  "
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010402	What does ACID stand for, and what do each of those letters represent?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What does ACID stand for, and what do each of those letters represent?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010403	"What is the meaning of ""BD f"" in the context of the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the meaning of ""BD f"" in the context of the given paragraph?'  "
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010404	What is the difference between cancel·lació d'una transacció and confirmació d'una transacció?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the difference between cancel·lació d'una transacció and confirmació d'una transacció?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010405	What is the purpose of control de concurrència in a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the purpose of control de concurrència in a database management system?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010406	What is a còpia de seguretat, and how is it used in a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is a còpia de seguretat, and how is it used in a database management system?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010407	What is a dietari, and how is it related to transaction management in a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is a dietari, and how is it related to transaction management in a database management system?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010408	What is a grànul, and how is it used in a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is a grànul, and how is it used in a database management system?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010409	What is an horari, and how is it related to transaction execution in a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is an horari, and how is it related to transaction execution in a database management system?'  
C001500104	Gestio╠ü de transaccions	Glossari	synthetic_question	abraçada mortal f Situació que es produeix, usant reserves, quan l'execució de dues transaccions o més queda bloquejada, sense possibilitat de reprendre-la, perquè cada una s'espera a obtenir una reserva que està en possessió d'una altra de les transaccions que hi estan implicades. ACID m Acrònim format pels mots atomicitat, consistència, isolament i definitivitat que indica les propietats que ha de tenir tota transacció. BD f Sigla corresponent a base de dades. cancel·lació d'una transacció f Finalització d'una transacció sense que se'n confirmin les actualitzacions fetes en la BD. confirmació d'una transacció f Finalització d'una transacció que fa que els canvis fets esdevinguin definitius en la BD. control de concurrència m Conjunt de tècniques que utilitza un SGBD per a evitar que es produeixin interferències entre transaccions que s'executen concurrentment. còpia de seguretat f Còpia d'un estat correcte d'una BD, que es fa servir per a reconstruir-la en cas de pèrdua total o parcial de les dades. dietari m Estructura de dades utilitzada per l'SGBD per a emmagatzemar informació dels canvis que han fet les transaccions i com (les transaccions) han acabat la seva execució. S'empra en les tasques de recuperació. grànul m Unitat de dades controlada individualment per l'SGBD a l'efecte de control de concurrència i recuperació. horari m Execució concurrent, en un cert ordre, de les accions que incorporen un conjunt de transaccions. interferència f Comportament anòmal que pot produir l'accés concurrent de diversos usuaris a la BD si no es prenen les precaucions adequades, i que posa en perill la integritat de la BD o fa que arribi informació errònia als usuaris. nivell d'aïllament m Grau de protecció que ofereix l'SGBD a una transacció, segons els tipus d'interferències dels quals la protegeix.	C00150010410	What is interferència, and how can it affect the integrity of a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is interferència, and how can it affect the integrity of a database management system?'  
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010501	"What is the purpose of the ""gestioêü de transaccions"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the purpose of the ""gestioêü de transaccions"" according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010502	"What is the definition of ""nivell de concurrència"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the definition of ""nivell de concurrència"" according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010503	"What is the difference between the ""protocol de reserves en dues fases"" and the ""protocol de reserves estricte""?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the difference between the ""protocol de reserves en dues fases"" and the ""protocol de reserves estricte""?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010504	"What is the function of the ""punt de control"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the function of the ""punt de control"" according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010505	"What is the meaning of ""reconstrucció"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the meaning of ""reconstrucció"" according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010506	"What is the criterion for ""recuperabilitat"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the criterion for ""recuperabilitat"" according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010507	"What is the goal of the ""recuperació"" process according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the goal of the ""recuperació"" process according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010508	"What is the definition of ""reserva"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the definition of ""reserva"" according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010509	"How does the ""reserva"" work according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'How does the ""reserva"" work according to the given paragraph?'  "
C001500105	Gestio╠ü de transaccions	Glossari	synthetic_question	nivell de concurrència m Grau d'aprofitament dels recursos de procés disponibles segons l'encavalcament d'execució de les transaccions que accedeixen concurrentment a la BD i aconsegueixen confirmar. protocol de reserves en dues fases m Manera d'utilitzar reserves per part de les transaccions que en garanteix la seriabilitat dels horaris, però no la recuperabilitat. En la primera fase permet a les transaccions adquirir reserves, i en la segona, només alliberar-les. protocol de reserves en dues fases estricte m Variant estricta del protocol de reserves en dues fases, en què les reserves no s'alliberen fins que no acaba la transacció. Garanteix, a més de la seriabilitat, la recuperabilitat dels horaris. PR2F m Protocol de reserves en dues fases. punt de control m Registre del dietari que identifica un instant en què l'SGBD escriu en memòria externa tots els canvis que s'han fet a les memòries intermèdies i que conté els identificadors de totes les transaccions que estan actives en aquest instant. reconstrucció f Conjunt de tasques necessàries per a recuperar l'últim estat d'una BD quan, a causa de fallades o desastres, es produeix una pèrdua total o parcial de les dades guardades en la BD. recuperabilitat f Criteri formal que defineix quines condicions ha de complir un horari perquè les cancel·lacions no provoquin interferències. recuperació f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions. Té la missió d'aconseguir que no es perdin els canvis que hagin fet les transaccions confirmades i que es desfacin els que hagin fet les transaccions que no confirmen la seva execució. reserva f Dret que pot adquirir una transacció per a accedir a un grànul de la BD, que es demana abans d'accedir al grànul i s'allibera posteriorment. La reserva es demana en una certa modalitat que permet fer l'acció que la transacció vol sobre el grànul.	C00150010510	"What is the purpose of the ""reserva"" according to the given paragraph?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the purpose of the ""reserva"" according to the given paragraph?'  "
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010601	"What is the main purpose of the ""gestió de transaccions"" in a database management system?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the main purpose of the ""gestió de transaccions"" in a database management system?'  "
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010602	What is the difference between atomicity and definitiveness in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the difference between atomicity and definitiveness in transaction management?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010603	How does the server ensure that transactions are correctly isolated from each other?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'How does the server ensure that transactions are correctly isolated from each other?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010604	What is the criterion formal definition of serializability in transaction processing?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the criterion formal definition of serializability in transaction processing?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010605	"Can you explain the concept of ""seriabilitat"" in the context of transaction management?"	"passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'Can you explain the concept of ""seriabilitat"" in the context of transaction management?'  "
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010606	What is the sequence of operations involved in a transaction in a database management system?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What is the sequence of operations involved in a transaction in a database management system?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010607	How do transactions ensure that all operations are properly executed and committed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'How do transactions ensure that all operations are properly executed and committed?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010608	What happens if a transaction is cancelled or rolled back before it is committed?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'What happens if a transaction is cancelled or rolled back before it is committed?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010609	Can you describe the process of restoration in transaction management?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'Can you describe the process of restoration in transaction management?'  
C001500106	Gestio╠ü de transaccions	Glossari	synthetic_question	restauració f Conjunt de tasques necessàries per a garantir l'atomicitat i la definitivitat de les transaccions davant de cancel·lacions voluntàries o involuntàries i davant de caigudes de l'SGBD. seriabilitat f Criteri formal que defineix les condicions que ha de tenir un horari per a garantir que les transaccions estan correctament aïllades entre elles, en el supòsit que totes les transaccions confirmen els seus resultats. transacció f Seqüència d'operacions de lectura i actualització de la BD que compleix les propietats ACID.	C00150010610	How does the database management system guarantee the consistency of data during transaction execution?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'Glossari'; content: 'How does the database management system guarantee the consistency of data during transaction execution?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010901	What is the title of the documentation according to the given URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'What is the title of the documentation according to the given URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010902	In which year was the previous version of PostgreSQL available at the given URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'In which year was the previous version of PostgreSQL available at the given URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010903	What is the current version number of PostgreSQL mentioned in the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'What is the current version number of PostgreSQL mentioned in the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010904	What is the purpose of the documentation according to the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'What is the purpose of the documentation according to the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010905	Who is responsible for the development of PostgreSQL according to the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'Who is responsible for the development of PostgreSQL according to the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010906	When was the last time the documentation was updated, based on the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'When was the last time the documentation was updated, based on the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010907	What is the address of the website where the documentation can be found, according to the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'What is the address of the website where the documentation can be found, according to the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010908	Is the documentation available in multiple languages, according to the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'Is the documentation available in multiple languages, according to the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010909	How often is the documentation updated, according to the URL?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'How often is the documentation updated, according to the URL?'  
C001500109	Gestio╠ü de transaccions	The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.	synthetic_question	L'obra prèvia està disponible en l'adreça següent (darrer accés setembre 2010): http:// www.postgresql.org.	C00150010910	Can the documentation be accessed through a different URL, according to the text?	passage: document 'Gestio╠ü de transaccions'; paragraph: 'The PostgreSQL Global Development Group (2009). PostgreSQL 8.4.2 Documentation.'; content: 'Can the documentation be accessed through a different URL, according to the text?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000201	What is the main objective of designing a distributed database system according to the given paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What is the main objective of designing a distributed database system according to the given paragraph?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000202	How does the distribution of data fragments affect the cost of data transmission in a distributed database system?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'How does the distribution of data fragments affect the cost of data transmission in a distributed database system?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000203	According to the passage, what are some factors that should be considered when designing a distributed database system?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'According to the passage, what are some factors that should be considered when designing a distributed database system?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000204	"Can you explain the concept of ""transparency of distribution"" mentioned in the passage?"	"passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'Can you explain the concept of ""transparency of distribution"" mentioned in the passage?'  "
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000205	What are some potential benefits of using a distributed database system over a centralized one, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What are some potential benefits of using a distributed database system over a centralized one, according to the passage?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000206	In which situations might it be necessary to replicate data fragments in a distributed database system, and why?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'In which situations might it be necessary to replicate data fragments in a distributed database system, and why?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000207	How does the placement of data fragments impact the performance of a distributed database system, and why?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'How does the placement of data fragments impact the performance of a distributed database system, and why?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000208	What is the purpose of analyzing user needs before designing a distributed database system, and how does this analysis influence the design process?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What is the purpose of analyzing user needs before designing a distributed database system, and how does this analysis influence the design process?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000209	Can you describe the relationship between the objectives of reducing data transmission costs, repartiendo la carga de trabajo, and increasing efficiency in processing requests, as mentioned in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'Can you describe the relationship between the objectives of reducing data transmission costs, repartiendo la carga de trabajo, and increasing efficiency in processing requests, as mentioned in the passage?'  
C001400002	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	(cid:1) El diseño de BDD toma decisiones acerca de cómo fragmentar la BD, qué fragmentos se deben replicar, y dónde almacenar los fragmentos y réplicas diseñados. (cid:1) Para ello es necesario analizar las necesidades de los usuarios/aplicaciones: – Qué parte de la BD necesitan – Qué operaciones realizan sobre la BD – Cuál es su punto de acceso al sistema (cid:1) Los objetivos a conseguir son: – Disminuir los costes de transmisión de datos – Repartir la carga de trabajo – Aumentar la eficiencia y promover la disponibilidad de los datos EIMT.U U El diseño de bases de datos distribuidas consiste en tomar decisiones en relación a una serie de aspectos. Antes de entrar en ellos, recordemos que existen diferentes situaciones que pueden conducir a la existencia de una base de datos distribuida. Una es que se trate de una decisión tomada por el equipo que diseña la base de datos de acuerdo con la organización o empresa que la utilizará. En este caso, a las estrategias de diseño seguidas en una base de datos centralizada, se deben añadir otras que ayuden a tomar decisiones relativas a cómo dividir la base de datos en diferentes fragmentos, si es o no necesario replicar algunos de esos fragmentos (o todos) y dónde se van almacenar los fragmentos (y sus réplicas, si las hubiera). Para poder realizar un buen diseño de la base de datos distribuida es necesario analizar cuidadosamente las necesidades de las aplicaciones (y en consecuencia de los usuarios). En concreto, hay que considerar qué parte de la base de datos necesitan acceder, qué funcionalidades hay que suministrar (es decir, qué operaciones se realizan sobre los datos y cómo se accede a éstos) y cuál es el punto de acceso de los usuarios al sistema (es decir, la idea es acercar los datos a dónde éstos se necesitan). Los objetivos que se esperan conseguir son principalmente tres. En primer lugar, disminuir los costes de transmisión de datos a través de la red. En segundo lugar, repartir la carga de trabajo de forma uniforme entre los diferentes nodos. Y en tercer lugar, y como consecuencia de las dos anteriores, aumentar la eficiencia en el procesamiento de las peticiones formuladas, y garantizar la disponibilidad de los datos. Idealmente, la existencia de fragmentos y sus réplicas, así como el lugar donde estos elementos estén almacenados, debe ser transparente a todos los usuarios. Esta noción se conoce como transparencia de distribución.	C00140000210	How does the existence of fragmentos and their replicas, as well as the location where they are stored, contribute to the transparency of the distributed database system, as described in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'How does the existence of fragmentos and their replicas, as well as the location where they are stored, contribute to the transparency of the distributed database system, as described in the passage?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000301	What is the main purpose of designing distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What is the main purpose of designing distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000302	What are the two strategies discussed in the paragraph for designing distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What are the two strategies discussed in the paragraph for designing distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000303	What is fragmentation in the context of distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What is fragmentation in the context of distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000304	How does replication work in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'How does replication work in distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000305	What are the benefits of using fragmentation and replication in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What are the benefits of using fragmentation and replication in distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000306	Are there any challenges or difficulties associated with implementing fragmentation and replication in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'Are there any challenges or difficulties associated with implementing fragmentation and replication in distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000307	Can you explain how fragmentation and replication differ in terms of their initial purpose and scope?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'Can you explain how fragmentation and replication differ in terms of their initial purpose and scope?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000308	In what way do the concepts of fragmentation and replication apply to non-relational databases as well?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'In what way do the concepts of fragmentation and replication apply to non-relational databases as well?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000309	What are some examples of different types of fragmentation in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'What are some examples of different types of fragmentation in distributed databases?'  
C001400003	BDD_Disen╠âo	¿En qué consiste el diseño de BD distribuidas?	synthetic_question	A continuación vamos a ver en qué consisten la fragmentación y replicación de los datos. Éstas son las estrategias que podemos utilizar en el diseño de bases de datos distribuidas. Tras esto analizaremos cuáles son los principales beneficios y dificultades que se derivan de su uso. Finalmente, estudiaremos los diferentes tipos de fragmentación, y se ejemplificarán en el caso particular de bases de datos relacionales. Debemos tener en cuenta que la fragmentación y replicación son estrategias inicialmente pensadas para el ámbito de bases de datos relacionales. A pesar de ello, los conceptos teóricos que subyacen y las conclusiones alcanzadas son también válidas para las bases de datos NoSQL. 5 5	C00140000310	How does the case study of relational databases illustrate the principles of fragmentation and replication in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: '¿En qué consiste el diseño de BD distribuidas?'; content: 'How does the case study of relational databases illustrate the principles of fragmentation and replication in distributed databases?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000401	What is the main purpose of fragmentation in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What is the main purpose of fragmentation in distributed databases?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000402	Can you describe the three types of fragmentation in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'Can you describe the three types of fragmentation in distributed databases?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000403	How does horizontal fragmentation work in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'How does horizontal fragmentation work in distributed databases?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000404	What is vertical fragmentation in distributed databases, and how does it work?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What is vertical fragmentation in distributed databases, and how does it work?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000405	Can you explain the concept of híbrida fragmentation in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'Can you explain the concept of híbrida fragmentation in distributed databases?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000406	What is replication in distributed databases, and what are its purposes?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What is replication in distributed databases, and what are its purposes?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000407	How does replication differ from fragmentation in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'How does replication differ from fragmentation in distributed databases?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000408	In which situations might fragmentation or replication be more appropriate for a distributed database system?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'In which situations might fragmentation or replication be more appropriate for a distributed database system?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000409	How do the choices of fragmentation and replication affect the performance and scalability of a distributed database system?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'How do the choices of fragmentation and replication affect the performance and scalability of a distributed database system?'  
C001400004	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	(cid:1) Fragmentación: los datos/esquema se dividen en subconjuntos. Existen tres tipos de fragmentación: Horizontal: toma como unidad de distribución conjuntos de datos relacionados. Vertical: usa subconjuntos del esquema (y los datos asociados) como unidad de distribución, por ejemplo, grupos de atributos. Híbrida: mezcla de las dos anteriores. (cid:1) Replicación: consiste en reproducir fragmentos del esquema (y de los datos que éstos contienen). EIMT.U U La fragmentación se basa en la idea de que las aplicaciones (y por lo tanto los usuarios), en general, no necesitan acceder a toda la base de datos, sino que están interesados en acceder a subconjuntos de la misma. Por lo tanto, el objetivo de la fragmentación es encontrar la unidad de acceso a los datos más apropiada para cada dominio de aplicación. Dicha unidad de acceso (que se denomina fragmento) se convierte en la unidad de distribución entre los diferentes nodos que forman la base de datos distribuida. Existen tres tipos de fragmentación: la horizontal, la vertical y la híbrida. La fragmentación horizontal toma conjuntos de datos relacionados como unidad de distribución, de tal manera que objetos individuales o subconjuntos de objetos que comparten semántica (es decir, objetos que pertenecen a una misma clase) pasan a ser la unidad de distribución entre los diferentes nodos. Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Finalmente, la fragmentación híbrida combina la fragmentación horizontal y vertical. La segunda estrategia de distribución es la replicación. Ésta consiste en almacenar todos o una parte de los fragmentos diseñados (y por lo tanto, los datos que éstos contienen) en más de un nodo.	C00140000410	Can you discuss some potential challenges and limitations of using fragmentation and replication in distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'Can you discuss some potential challenges and limitations of using fragmentation and replication in distributed database systems?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000501	What is the main idea of the paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What is the main idea of the paragraph?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000502	What are the two strategies discussed in the paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What are the two strategies discussed in the paragraph?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000503	How do fragmentation and replication relate to each other according to the paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'How do fragmentation and replication relate to each other according to the paragraph?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000504	Is it possible to use only fragmentation or only replication in distributing a database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'Is it possible to use only fragmentation or only replication in distributing a database?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000505	What is the typical choice when distributing a database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What is the typical choice when distributing a database?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000506	Can you explain the concept of mirroring in databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'Can you explain the concept of mirroring in databases?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000507	How does the combination of fragmentation and replication work in distributing a database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'How does the combination of fragmentation and replication work in distributing a database?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000508	What is the purpose of dividing a database into fragments if there is no replication?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'What is the purpose of dividing a database into fragments if there is no replication?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000509	Can you give an example scenario where using only fragmentation might be beneficial?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'Can you give an example scenario where using only fragmentation might be beneficial?'  
C001400005	BDD_Disen╠âo	Estrategias de distribución	synthetic_question	Las estrategias de fragmentación y replicación son ortogonales entre sí. En consecuencia, podemos optar por usar únicamente fragmentación (la base de datos se divide en fragmentos que se distribuyen entre los diferentes nodos, pero ningún fragmento estará replicado), podemos no fragmentar la base de datos pero sí replicarla (si se replica de forma completa estaríamos hablando de técnicas de mirroring de bases de datos) o bien podemos utilizar una combinación de ambas estrategias. Esta última acostumbra a ser la elección habitual en el caso de una base de datos distribuida. 6 6	C00140000510	In what situation would using only replication be more appropriate?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución'; content: 'In what situation would using only replication be more appropriate?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000601	What are the main benefits and difficulties associated with using distribution strategies in a database system?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What are the main benefits and difficulties associated with using distribution strategies in a database system?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000602	How does fragmentation affect the availability of data in a distributed database system?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does fragmentation affect the availability of data in a distributed database system?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000603	What is the significance of data locality in a distributed database system?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the significance of data locality in a distributed database system?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000604	How does replication improve the performance of distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does replication improve the performance of distributed database systems?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000605	What are some challenges related to inconsistency and integrity in distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What are some challenges related to inconsistency and integrity in distributed database systems?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000606	How do insertion, modification, and deletion operations impact the consistency of distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do insertion, modification, and deletion operations impact the consistency of distributed database systems?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000607	What are some policies for ensuring consistency among replicas in distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What are some policies for ensuring consistency among replicas in distributed database systems?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000608	How do synchronous vs. asynchronous consistency models differ in their approach to maintaining consistency in distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do synchronous vs. asynchronous consistency models differ in their approach to maintaining consistency in distributed database systems?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000609	What is the relationship between replication and data availability in distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the relationship between replication and data availability in distributed database systems?'  
C001400006	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	A continuación resumimos los principales beneficios y dificultades que se derivan del uso de las estrategias de distribución que acabamos de presentar. La fragmentación permite acercar los datos allá donde se necesitan. Esta característica se conoce como localidad de los datos (en inglés data locality). Si un mismo fragmento debe ser accedido desde diferentes ubicaciones, se puede replicar. Por lo tanto, la replicación ayuda a maximizar la localidad de los datos. Asimismo la fragmentación permite que más operaciones se ejecuten al mismo tiempo y en paralelo, de tal manera que se incrementa el rendimiento global del sistema. Este aspecto es de gran importancia en bases de datos altamente distribuidas que almacenan grandes volúmenes de datos. La existencia de réplicas, además, incrementa la disponibilidad de los datos ante situaciones de avería (si un nodo no está disponible o accesible, los datos se pueden recuperar de otros nodos). La replicación también permite mejorar significativamente la eficiencia de las operaciones de consulta. A pesar de estos beneficios, la fragmentación puede conducir a un peor rendimiento cuando hay que acceder a fragmentos que están almacenados en diferentes nodos. Por ejemplo, esta situación se puede dar cuando hay requerimientos contradictorios que hacen imposible separar los datos en fragmentos mutuamente excluyentes. En este sentido, la situación ideal sería que cada usuario sólo necesitase acceder a un nodo para recuperar los datos que necesita, y que el acceso de los usuarios se repartiese de forma uniforme entre todos los nodos, porque esto permitiría equilibrar la carga de trabajo. Los problemas de rendimiento descritos se podrían ver agravados si existen reglas de integridad que implican a fragmentos diferentes almacenados en distintos nodos. Finalmente, la replicación complica las operaciones de inserción, borrado y modificación de los datos. En concreto, la inserción y modificación son especialmente problemáticas. La inserción de nuevos objetos, incluye también la inserción de sus réplicas (si las hubiera). En el caso de modificación, es necesario garantizar que todas las réplicas de un mismo objeto contengan los mismos valores. Si esto no es así, se está comprometiendo la consistencia. Existen diferentes políticas para garantizar que las réplicas de un mismo objeto sean idénticas. Estas políticas surgen de considerar dos dimensiones. La primera tiene que ver con el hecho de si la consistencia se mantiene de forma síncrona o asíncrona (es decir, si los cambios realizados sobre una réplica se propagan de forma inmediata o diferida al resto). La segunda dimensión se relaciona con la existencia de diferentes tipos de réplicas (una copia primaria donde se realizan los cambios que luego serán propagados al resto) o no (todas las réplicas son iguales). Estas dimensiones se pueden combinar dando lugar a diferentes políticas como sería el caso de la replicación master-slave y la replicación P2P. Estas políticas serán objeto de estudio en presentaciones posteriores.	C00140000610	How do different types of replication (e.g., master-slave, peer-to-peer) address the challenges of consistency and availability in distributed database systems?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do different types of replication (e.g., master-slave, peer-to-peer) address the challenges of consistency and availability in distributed database systems?'  
C001400007	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	7 7 Fragmentación horizontal (cid:1) Especialmente adecuada para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente (maximiza la data locality). (cid:1) Los filtros (o condiciones) aplicados en las operaciones que formulan los usuarios/aplicaciones pueden servir para decidir qué fragmentos crear. La fragmentación horizontal toma como unidad de distribución objetos individuales o subconjuntos de objetos. Estos subconjuntos de objetos comparten semántica (en definitiva, son instancias de una misma clase). En general, los subconjuntos se establecen en función del valor de un atributo o grupo de atributos del objeto. Si pensamos en una base de datos distribuida relacional, la fragmentación horizontal consiste en dividir una relación en relaciones más pequeñas que contienen subconjuntos de filas de la relación original. Cada una de estas relaciones más pequeñas constituye un fragmento. Por ejemplo, dada una relación de clientes, podríamos fragmentar dicha relación en función de su país de procedencia (que es un atributo de la relación). Cada fragmento contiene todos los atributos del cliente. Diferentes fragmentos que estén relacionados se pueden almacenar en un mismo nodo. Esto puede ser especialmente interesante, por ejemplo, para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente. Para decidir qué fragmentos se deben crear se suelen analizar las condiciones usadas por los usuarios en las peticiones que formulan, o el patrón que siguen en el acceso a los datos. 8 8 Fragmentación vertical (cid:1) Para el diseño de fragmentos es necesario analizar la afinidad entre atributos (qué atributos se recuperan de forma conjunta en las operaciones de consulta). (cid:1) Pueden complicar las operaciones de inserción y modificación, y comprometer la consistencia de los datos. (cid:1) Ayuda a mejorar el ratio de datos útiles recuperados en operaciones de consulta (sólo se leen los atributos relevantes). (cid:1) Especialmente útil en sistemas decisionales	C00140000701	What is the main advantage of fragmentation horizontal in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main advantage of fragmentation horizontal in distributed databases?'  
C001400007	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	7 7 Fragmentación horizontal (cid:1) Especialmente adecuada para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente (maximiza la data locality). (cid:1) Los filtros (o condiciones) aplicados en las operaciones que formulan los usuarios/aplicaciones pueden servir para decidir qué fragmentos crear. La fragmentación horizontal toma como unidad de distribución objetos individuales o subconjuntos de objetos. Estos subconjuntos de objetos comparten semántica (en definitiva, son instancias de una misma clase). En general, los subconjuntos se establecen en función del valor de un atributo o grupo de atributos del objeto. Si pensamos en una base de datos distribuida relacional, la fragmentación horizontal consiste en dividir una relación en relaciones más pequeñas que contienen subconjuntos de filas de la relación original. Cada una de estas relaciones más pequeñas constituye un fragmento. Por ejemplo, dada una relación de clientes, podríamos fragmentar dicha relación en función de su país de procedencia (que es un atributo de la relación). Cada fragmento contiene todos los atributos del cliente. Diferentes fragmentos que estén relacionados se pueden almacenar en un mismo nodo. Esto puede ser especialmente interesante, por ejemplo, para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente. Para decidir qué fragmentos se deben crear se suelen analizar las condiciones usadas por los usuarios en las peticiones que formulan, o el patrón que siguen en el acceso a los datos. 8 8 Fragmentación vertical (cid:1) Para el diseño de fragmentos es necesario analizar la afinidad entre atributos (qué atributos se recuperan de forma conjunta en las operaciones de consulta). (cid:1) Pueden complicar las operaciones de inserción y modificación, y comprometer la consistencia de los datos. (cid:1) Ayuda a mejorar el ratio de datos útiles recuperados en operaciones de consulta (sólo se leen los atributos relevantes). (cid:1) Especialmente útil en sistemas decisionales	C00140000702	How does fragmentation horizontal improve data locality in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does fragmentation horizontal improve data locality in distributed databases?'  
C001400007	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	7 7 Fragmentación horizontal (cid:1) Especialmente adecuada para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente (maximiza la data locality). (cid:1) Los filtros (o condiciones) aplicados en las operaciones que formulan los usuarios/aplicaciones pueden servir para decidir qué fragmentos crear. La fragmentación horizontal toma como unidad de distribución objetos individuales o subconjuntos de objetos. Estos subconjuntos de objetos comparten semántica (en definitiva, son instancias de una misma clase). En general, los subconjuntos se establecen en función del valor de un atributo o grupo de atributos del objeto. Si pensamos en una base de datos distribuida relacional, la fragmentación horizontal consiste en dividir una relación en relaciones más pequeñas que contienen subconjuntos de filas de la relación original. Cada una de estas relaciones más pequeñas constituye un fragmento. Por ejemplo, dada una relación de clientes, podríamos fragmentar dicha relación en función de su país de procedencia (que es un atributo de la relación). Cada fragmento contiene todos los atributos del cliente. Diferentes fragmentos que estén relacionados se pueden almacenar en un mismo nodo. Esto puede ser especialmente interesante, por ejemplo, para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente. Para decidir qué fragmentos se deben crear se suelen analizar las condiciones usadas por los usuarios en las peticiones que formulan, o el patrón que siguen en el acceso a los datos. 8 8 Fragmentación vertical (cid:1) Para el diseño de fragmentos es necesario analizar la afinidad entre atributos (qué atributos se recuperan de forma conjunta en las operaciones de consulta). (cid:1) Pueden complicar las operaciones de inserción y modificación, y comprometer la consistencia de los datos. (cid:1) Ayuda a mejorar el ratio de datos útiles recuperados en operaciones de consulta (sólo se leen los atributos relevantes). (cid:1) Especialmente útil en sistemas decisionales	C00140000703	Can you explain the difference between fragmentation horizontal and fragmentation vertical in distributed databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you explain the difference between fragmentation horizontal and fragmentation vertical in distributed databases?'  
C001400007	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	7 7 Fragmentación horizontal (cid:1) Especialmente adecuada para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente (maximiza la data locality). (cid:1) Los filtros (o condiciones) aplicados en las operaciones que formulan los usuarios/aplicaciones pueden servir para decidir qué fragmentos crear. La fragmentación horizontal toma como unidad de distribución objetos individuales o subconjuntos de objetos. Estos subconjuntos de objetos comparten semántica (en definitiva, son instancias de una misma clase). En general, los subconjuntos se establecen en función del valor de un atributo o grupo de atributos del objeto. Si pensamos en una base de datos distribuida relacional, la fragmentación horizontal consiste en dividir una relación en relaciones más pequeñas que contienen subconjuntos de filas de la relación original. Cada una de estas relaciones más pequeñas constituye un fragmento. Por ejemplo, dada una relación de clientes, podríamos fragmentar dicha relación en función de su país de procedencia (que es un atributo de la relación). Cada fragmento contiene todos los atributos del cliente. Diferentes fragmentos que estén relacionados se pueden almacenar en un mismo nodo. Esto puede ser especialmente interesante, por ejemplo, para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente. Para decidir qué fragmentos se deben crear se suelen analizar las condiciones usadas por los usuarios en las peticiones que formulan, o el patrón que siguen en el acceso a los datos. 8 8 Fragmentación vertical (cid:1) Para el diseño de fragmentos es necesario analizar la afinidad entre atributos (qué atributos se recuperan de forma conjunta en las operaciones de consulta). (cid:1) Pueden complicar las operaciones de inserción y modificación, y comprometer la consistencia de los datos. (cid:1) Ayuda a mejorar el ratio de datos útiles recuperados en operaciones de consulta (sólo se leen los atributos relevantes). (cid:1) Especialmente útil en sistemas decisionales	C00140000704	How do filters or conditions applied by users/applications decide which fragments to create in a distributed database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do filters or conditions applied by users/applications decide which fragments to create in a distributed database?'  
C001400007	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	7 7 Fragmentación horizontal (cid:1) Especialmente adecuada para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente (maximiza la data locality). (cid:1) Los filtros (o condiciones) aplicados en las operaciones que formulan los usuarios/aplicaciones pueden servir para decidir qué fragmentos crear. La fragmentación horizontal toma como unidad de distribución objetos individuales o subconjuntos de objetos. Estos subconjuntos de objetos comparten semántica (en definitiva, son instancias de una misma clase). En general, los subconjuntos se establecen en función del valor de un atributo o grupo de atributos del objeto. Si pensamos en una base de datos distribuida relacional, la fragmentación horizontal consiste en dividir una relación en relaciones más pequeñas que contienen subconjuntos de filas de la relación original. Cada una de estas relaciones más pequeñas constituye un fragmento. Por ejemplo, dada una relación de clientes, podríamos fragmentar dicha relación en función de su país de procedencia (que es un atributo de la relación). Cada fragmento contiene todos los atributos del cliente. Diferentes fragmentos que estén relacionados se pueden almacenar en un mismo nodo. Esto puede ser especialmente interesante, por ejemplo, para organizaciones geográficamente dispersas que principalmente acceden a los datos que guardan localmente. Para decidir qué fragmentos se deben crear se suelen analizar las condiciones usadas por los usuarios en las peticiones que formulan, o el patrón que siguen en el acceso a los datos. 8 8 Fragmentación vertical (cid:1) Para el diseño de fragmentos es necesario analizar la afinidad entre atributos (qué atributos se recuperan de forma conjunta en las operaciones de consulta). (cid:1) Pueden complicar las operaciones de inserción y modificación, y comprometer la consistencia de los datos. (cid:1) Ayuda a mejorar el ratio de datos útiles recuperados en operaciones de consulta (sólo se leen los atributos relevantes). (cid:1) Especialmente útil en sistemas decisionales	C00140000705	In what situations might fragmentation vertical complicate insertion and modification operations in a distributed database, and how can it impact data consistency?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'In what situations might fragmentation vertical complicate insertion and modification operations in a distributed database, and how can it impact data consistency?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000801	What is the main idea of the second sentence in the paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main idea of the second sentence in the paragraph?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000802	Can you identify the two types of fragmentation mentioned in the paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you identify the two types of fragmentation mentioned in the paragraph?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000803	Why has traditional fragmentation been less used according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Why has traditional fragmentation been less used according to the passage?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000804	What is an example of a system that uses the principles of fragmentation vertical, as described in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is an example of a system that uses the principles of fragmentation vertical, as described in the passage?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000805	How does the fragmentation vertical strategy differ from the traditional approach to data storage and retrieval?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the fragmentation vertical strategy differ from the traditional approach to data storage and retrieval?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000806	In what way do the almacenes de columnas (column stores) illustrate the principle of fragmentation vertical, as discussed in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'In what way do the almacenes de columnas (column stores) illustrate the principle of fragmentation vertical, as discussed in the passage?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000807	What is the purpose of creating separate fragments for different attributes of objects, as suggested in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the purpose of creating separate fragments for different attributes of objects, as suggested in the passage?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000808	How does the use of fragmentation vertical affect the insertion of new objects and modification of existing ones, as noted in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the use of fragmentation vertical affect the insertion of new objects and modification of existing ones, as noted in the passage?'  
C001400008	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	Por su parte, la fragmentación vertical consiste en usar subconjuntos del esquema, en general, grupos de atributos de los objetos (y los datos asociados a ellos) como unidad de distribución. Tradicionalmente la fragmentación vertical ha sido poco utilizada, por diversas razones. En primer lugar, la decisión de qué atributos agrupar en cada fragmento requiere analizar su afinidad y esto puede ser muy complejo. En segundo lugar, la fragmentación vertical puede introducir complicaciones en la inserción de nuevos objetos y en la modificación de los existentes. Pensemos que los atributos de los objetos (y en consecuencia, los propios objetos) pueden haber quedado divididos en diferentes fragmentos que, además, pueden estar almacenados en diferentes nodos. A pesar de las dificultades reseñadas, con la irrupción de los sistemas decisionales (en donde a los usuarios sólo necesitan consultar datos), esta estrategia de fragmentación emerge como una alternativa poderosa para procesar de forma eficiente operaciones que implican la lectura de grupos de atributos de todos o una parte de los objetos almacenados. Los almacenes de columnas (column stores) constituyen el ejemplo más claro de sistema basado en los principios de la fragmentación vertical. La figura muestra un ejemplo de fragmentación vertical sobre una base de datos distribuida relacional. En este caso, se han diseñado dos fragmentos para la relación de clientes. El primero contiene el identificador del cliente, su nombre y país de procedencia, mientras que el segundo contiene el identificador del cliente y los datos sobre el total facturado, el número de proyectos contratados, y el comercial que cada cliente tiene asignado. 9 9 Finalmente, la fragmentación híbrida combina las estrategias de fragmentación vertical y horizontal, tal y como muestra el ejemplo.	C00140000809	According to the passage, what is the advantage of using fragmentation vertical over traditional approaches to data storage and retrieval?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'According to the passage, what is the advantage of using fragmentation vertical over traditional approaches to data storage and retrieval?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000901	What is the main topic discussed in this paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main topic discussed in this paragraph?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000902	What type of distribution strategies are being discussed in this paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What type of distribution strategies are being discussed in this paragraph?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000903	How does fragmentation apply to databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does fragmentation apply to databases?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000904	What are the three properties that an esquema of fragmentation must fulfill?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What are the three properties that an esquema of fragmentation must fulfill?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000905	What is complete fragmentation in the context of databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is complete fragmentation in the context of databases?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000906	What is disyunction in the context of databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is disyunction in the context of databases?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000907	How do fragmented relationships ensure data consistency?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do fragmented relationships ensure data consistency?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000908	Can you explain the process of reconstructruction in database design?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you explain the process of reconstructruction in database design?'  
C001400009	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En este caso, y tras haber fragmentado verticalmente en dos fragmentos la relación de clientes, se aplicado fragmentación horizontal (en función del país de procedencia del cliente) sobre el primero de dichos fragmentos. 10 10 En esta sección vamos a explicar las particularidades asociadas a las estrategias de distribución que acabamos de discutir cuando se aplican, respectivamente, en bases de datos relacionales y en bases de datos NoSQL. También situaremos el uso de dichas estrategias dentro del proceso general de diseño de bases de datos. 11 11 Diseño de BD distribuidas: BD relacionales (cid:1) Las BD relacionales soportan los diferentes tipos de fragmentación y también replicación. (cid:1) El esquema de fragmentación tiene que cumplir tres propiedades: completitud, disyunción y reconstrucción. Como hemos ejemplificado, las bases de datos relacionales soportan los diferentes tipos de fragmentación y también replicación. Los criterios de asignación de datos a fragmentos, las réplicas que tienen que existir de cada fragmento, así cómo la distribución de dichos elementos entre los nodos que conforman la base de datos distribuida son decisiones que toma el equipo responsable del diseño de la base de datos. Finalmente, el esquema de fragmentación debe cumplir las propiedades de completitud, disyunción y reconstrucción. La completitud garantiza que no se pierdan datos como consecuencia del proceso de fragmentación. Por su parte, la disyunción indica que cada elemento de datos (fila o columna) sólo puede estar en un fragmento, a excepción de aquellas relaciones que hayan sido fragmentadas verticalmente. En este caso, la clave primaria de la relación deberá aparecer en todos los fragmentos. Finalmente, la reconstrucción significa que la relación original se tiene que poder regenerar a partir de sus fragmentos. La presencia de la clave primaria en todas las relaciones que hayan sido fragmentadas verticalmente garantiza que la relación original pueda ser reconstruida.	C00140000909	In what way does the presence of a primary key guarantee data consistency in fragmented relations?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'In what way does the presence of a primary key guarantee data consistency in fragmented relations?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001001	What is the main purpose of fragmentation in databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main purpose of fragmentation in databases?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001002	How does the use of fragmentation in distributed databases promote data consistency?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the use of fragmentation in distributed databases promote data consistency?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001003	Can you explain the difference between completeness and disjointness in relation to database fragmentation?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you explain the difference between completeness and disjointness in relation to database fragmentation?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001004	In what way do the properties of fragmentation ensure the preservation of semantic meaning in a distributed database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'In what way do the properties of fragmentation ensure the preservation of semantic meaning in a distributed database?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001005	How does the example given in the passage illustrate the principles of fragmentation and reconstruction in a hybrid schema?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the example given in the passage illustrate the principles of fragmentation and reconstruction in a hybrid schema?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001006	What is the significance of the assumption made about the countries of origin of clients in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the significance of the assumption made about the countries of origin of clients in the passage?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001007	How does the use of NoSQL databases based on aggregation models promote fragmentation horizontally?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the use of NoSQL databases based on aggregation models promote fragmentation horizontally?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001008	What is the unit of minimum distribution in a NoSQL database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the unit of minimum distribution in a NoSQL database?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001009	Who makes decisions about where and how data fragments are stored in a NoSQL database?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Who makes decisions about where and how data fragments are stored in a NoSQL database?'  
C001400010	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esencia, las propiedades previas garantizan, por una parte, que el proceso de fragmentación preserve la semántica de la base de datos y de los datos almacenados en ella (completitud y reconstrucción). Por otra parte, garantiza que se eviten redundancias, es decir, repeticiones de los datos que serían evitables (disyunción). En relación a este último punto, recordemos que las bases de datos relacionales promulgan la normalización de los datos. La disyunción no es contradictoria con la existencia de réplicas. Si bien la replicación de fragmentos introduce redundancias, éstas serán controladas por el gestor de la base de datos. A modo de ejemplo, y tal como muestra la figura, el esquema de fragmentación híbrida que hemos creado verifica las propiedades de completitud (todos los datos contenidos en la relación de clientes están en algún fragmento), disyunción (cada elemento de datos está sólo en un fragmento, a excepción de la clave primaria de la relación clientes) y reconstrucción (la relación de clientes se puede reconstruir haciendo, en primera instancia, la unión de los 3 fragmentos mostrados en la parte izquierda de la figura, y a continuación la combinación (join) con el fragmento de la derecha. En el ejemplo se asume que los países de procedencia de los clientes únicamente pueden ser Francia, USA o España. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD NoSQL basadas en modelos de agregación permiten la replicación de datos y promueven la fragmentación horizontal (que se conoce bajo la denominación de sharding). (cid:1) El agregado constituye la unidad mínima a efectos de distribución de datos. (cid:1) En las BD NoSQL, en ocasiones, las decisiones sobre en qué fragmentos se almacenan los datos y dónde se almacenan los fragmentos son realizadas automáticamente por el gestor de la BD (auto-sharding). (cid:1) El esquema de fragmentación debe cumplir las propiedades de completitud y reconstrucción.	C00140001010	What property must an effective scheme of fragmentation satisfy in order to guarantee the accuracy of reconstructed data?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What property must an effective scheme of fragmentation satisfy in order to guarantee the accuracy of reconstructed data?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001101	What is the main idea behind the distribution strategies presented in the paragraph?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main idea behind the distribution strategies presented in the paragraph?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001102	How do the distribution strategies in NoSQL databases differ from those in relational databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do the distribution strategies in NoSQL databases differ from those in relational databases?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001103	What is sharding, and how does it relate to fragmentation in NoSQL databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is sharding, and how does it relate to fragmentation in NoSQL databases?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001104	Can you explain the concept of agregación in NoSQL databases, and how it affects data distribution?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you explain the concept of agregación in NoSQL databases, and how it affects data distribution?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001105	In what ways can the assignment of fragments and the distribution of shards be delegated to the database manager in NoSQL databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'In what ways can the assignment of fragments and the distribution of shards be delegated to the database manager in NoSQL databases?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001106	"What is meant by ""auto-sharding"" in NoSQL databases, and how does it work?"	"passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is meant by ""auto-sharding"" in NoSQL databases, and how does it work?'  "
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001107	How does the schema of fragmentation ensure completeness and reconstruction of the data in NoSQL databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the schema of fragmentation ensure completeness and reconstruction of the data in NoSQL databases?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001108	Is disunity necessary for distributed databases, and why or why not?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Is disunity necessary for distributed databases, and why or why not?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001109	How do key-value distributed databases differ from document-oriented and column-oriented databases in terms of sharding techniques?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How do key-value distributed databases differ from document-oriented and column-oriented databases in terms of sharding techniques?'  
C001400011	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	EIMT.U U A continuación presentamos las estrategias de distribución usadas por las bases de datos NoSQL. Destacar que se omiten las de modelos en grafo, dado que éstas están primordialmente pensadas para ser centralizadas. Las bases de datos NoSQL basadas en modelos de agregación permiten la replicación (en algunos casos masiva) de los datos y promueven principalmente la fragmentación horizontal. En el contexto de NoSQL, la fragmentación horizontal recibe el nombre de sharding. Recordemos que en los modelos de agregación, el agregado es la unidad a efectos de acceso (y manipulación) y de control de concurrencia y consistencia. Por estos motivos, también constituye la unidad mínima a efectos de distribución de datos. Podemos agrupar agregados de un mismo tipo en fragmentos. Cada uno de estos fragmentos recibe el nombre de shard. Cada fragmento (o shard) estará almacenado, al menos, en un nodo de la base de datos distribuida. Mientras que en las bases de datos relacionales la asignación de datos a fragmentos y la distribución de fragmentos entre los diferentes nodos constituyen decisiones que toman el equipo responsable del diseño de la base de datos, en NoSQL esta decisión se puede delegar al gestor de la base de datos. Esto se conoce como auto-sharding. El esquema de fragmentación debe preservar la semántica de la base de datos y de los datos almacenados en ella. En definitiva, el esquema de fragmentación debe garantizar las propiedades de completitud y reconstrucción. La disyunción no es necesaria, dado que las bases de datos NoSQL se basan en la desnormalización de los datos. Diseño de BD distribuidas: BD NoSQL (cid:1) Las BD clave-valor distribuyen los agregados, en general, apoyándose en el uso de técnicas de hash (por ejemplo, consistent hashing). (cid:1) Las BD orientadas a documentos pueden realizar sharding a través de técnicas de hash o según el valor de ciertos atributos. (cid:1) Las BD orientadas a columnas pueden usar tanto técnicas de fragmentación horizontal como vertical.	C00140001110	Can you provide an example of a real-world application that uses a NoSQL database with a distributed architecture?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you provide an example of a real-world application that uses a NoSQL database with a distributed architecture?'  
C001400012	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En las bases de datos clave-valor la distribución de los agregados se hace a partir de su clave. Para ello, en algunos casos, se usan técnicas de hash (por ejemplo, consistent hashing) que de manera aleatoria y uniforme distribuyen los agregados entre los diferentes nodos. Por lo tanto, no hay garantía de que agregados relacionados estén en un mismo nodo. Es más, en algunos casos, no existen fragmentos (shards). En otras palabras, la unidad de distribución puede ser el agregado y no conjuntos de agregados. Es por ello que algunos fabricantes (por ejemplo, Riak) afirman que no usan sharding, sino únicamente replicación como estrategia de distribución. En el caso de bases de datos orientadas a documentos, el sharding se puede efectuar, bien aplicando técnicas de hash, bien a partir del valor que toman ciertos atributos que siempre están presentes en el agregado (o documento). Un ejemplo de base de datos que admite ambas posibilidades es MongoDB. En MongoDB, los documentos de un mismo tipo se agrupan en colecciones y la fragmentación (sharding) se efectúa a nivel de colección. Las colecciones se pueden fragmentar según el valor de ciertos atributos, dando lugar a fragmentos (shards) que constituyen la unidad de distribución. Fijémonos que esta estrategia ayuda a resolver consultas por rangos que impliquen a los atributos usados en la fragmentación, dado que documentos con valores cercanos para esos atributos estarán posiblemente en el mismo fragmento. Los fragmentos son distribuidos automáticamente y de forma equitativa por el gestor de la base de datos entre los nodos. Si en algún momento la carga de trabajo se desequilibra (por ejemplo, un nodo pasa a almacenar un volumen de documentos muy superior al resto), el gestor la reequilibra de forma automática. Las bases de datos orientadas a columnas también realizan el sharding a partir del valor que toma la clave. Recordemos que este modelo se puede ver como una tabla compuesta por filas. Cada fila queda identificada por la clave y representa un agregado. A su vez, cada agregado se puede organizar en columnas y/o familias de columnas. Si se desea que agregados con valores próximos para la clave queden agrupados en un mismo fragmento que, a su vez, se almacena en al menos un nodo, la estrategia seguida para generar las claves es de importancia primordial. A modo de ejemplo, BigTable utiliza URL invertidas como claves (por ejemplo, una URL como www.cnn.com se transformaría en com.cnn.www). Las claves se disponen en orden lexicográfico y se agrupan en rangos (cada rango recibe el nombre de tablet). La tablet (que vendría a ser un shard) es la unidad de distribución. Con esta estrategia, por ejemplo, se consigue que el contenido de páginas web de un mismo dominio se realice de forma eficiente dado que pertenecerán a una misma tablet y estarán, en consecuencia, almacenadas en un mismo nodo. Además, a nivel de cada nodo, BigTable permite que las columnas y familias de columnas de los agregados se puedan segregar en grupos (denominados locality groups), que a su vez, se almacenan localmente de forma separada. En definitiva, permite efectuar una fragmentación vertical. La segregación de columnas (o familias de columnas) que no se acceden de manera conjunta en grupos separados permite mejorar el ratio de datos útiles recuperados en las operaciones de consulta (sólo se leen los grupos de columnas o familias de columnas relevantes).	C00140001201	¿Qué es el sharding en bases de datos y cómo se utiliza en las bases de datos orientadas a documentos y bases de datos orientadas a columnas?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: '¿Qué es el sharding en bases de datos y cómo se utiliza en las bases de datos orientadas a documentos y bases de datos orientadas a columnas?'  
C001400012	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En las bases de datos clave-valor la distribución de los agregados se hace a partir de su clave. Para ello, en algunos casos, se usan técnicas de hash (por ejemplo, consistent hashing) que de manera aleatoria y uniforme distribuyen los agregados entre los diferentes nodos. Por lo tanto, no hay garantía de que agregados relacionados estén en un mismo nodo. Es más, en algunos casos, no existen fragmentos (shards). En otras palabras, la unidad de distribución puede ser el agregado y no conjuntos de agregados. Es por ello que algunos fabricantes (por ejemplo, Riak) afirman que no usan sharding, sino únicamente replicación como estrategia de distribución. En el caso de bases de datos orientadas a documentos, el sharding se puede efectuar, bien aplicando técnicas de hash, bien a partir del valor que toman ciertos atributos que siempre están presentes en el agregado (o documento). Un ejemplo de base de datos que admite ambas posibilidades es MongoDB. En MongoDB, los documentos de un mismo tipo se agrupan en colecciones y la fragmentación (sharding) se efectúa a nivel de colección. Las colecciones se pueden fragmentar según el valor de ciertos atributos, dando lugar a fragmentos (shards) que constituyen la unidad de distribución. Fijémonos que esta estrategia ayuda a resolver consultas por rangos que impliquen a los atributos usados en la fragmentación, dado que documentos con valores cercanos para esos atributos estarán posiblemente en el mismo fragmento. Los fragmentos son distribuidos automáticamente y de forma equitativa por el gestor de la base de datos entre los nodos. Si en algún momento la carga de trabajo se desequilibra (por ejemplo, un nodo pasa a almacenar un volumen de documentos muy superior al resto), el gestor la reequilibra de forma automática. Las bases de datos orientadas a columnas también realizan el sharding a partir del valor que toma la clave. Recordemos que este modelo se puede ver como una tabla compuesta por filas. Cada fila queda identificada por la clave y representa un agregado. A su vez, cada agregado se puede organizar en columnas y/o familias de columnas. Si se desea que agregados con valores próximos para la clave queden agrupados en un mismo fragmento que, a su vez, se almacena en al menos un nodo, la estrategia seguida para generar las claves es de importancia primordial. A modo de ejemplo, BigTable utiliza URL invertidas como claves (por ejemplo, una URL como www.cnn.com se transformaría en com.cnn.www). Las claves se disponen en orden lexicográfico y se agrupan en rangos (cada rango recibe el nombre de tablet). La tablet (que vendría a ser un shard) es la unidad de distribución. Con esta estrategia, por ejemplo, se consigue que el contenido de páginas web de un mismo dominio se realice de forma eficiente dado que pertenecerán a una misma tablet y estarán, en consecuencia, almacenadas en un mismo nodo. Además, a nivel de cada nodo, BigTable permite que las columnas y familias de columnas de los agregados se puedan segregar en grupos (denominados locality groups), que a su vez, se almacenan localmente de forma separada. En definitiva, permite efectuar una fragmentación vertical. La segregación de columnas (o familias de columnas) que no se acceden de manera conjunta en grupos separados permite mejorar el ratio de datos útiles recuperados en las operaciones de consulta (sólo se leen los grupos de columnas o familias de columnas relevantes).	C00140001202	¿Cómo se selecciona la estrategia de distribución en una base de datos orientada a documentos, y cuáles son las ventajas y desventajas de cada estrategia?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: '¿Cómo se selecciona la estrategia de distribución en una base de datos orientada a documentos, y cuáles son las ventajas y desventajas de cada estrategia?'  
C001400012	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En las bases de datos clave-valor la distribución de los agregados se hace a partir de su clave. Para ello, en algunos casos, se usan técnicas de hash (por ejemplo, consistent hashing) que de manera aleatoria y uniforme distribuyen los agregados entre los diferentes nodos. Por lo tanto, no hay garantía de que agregados relacionados estén en un mismo nodo. Es más, en algunos casos, no existen fragmentos (shards). En otras palabras, la unidad de distribución puede ser el agregado y no conjuntos de agregados. Es por ello que algunos fabricantes (por ejemplo, Riak) afirman que no usan sharding, sino únicamente replicación como estrategia de distribución. En el caso de bases de datos orientadas a documentos, el sharding se puede efectuar, bien aplicando técnicas de hash, bien a partir del valor que toman ciertos atributos que siempre están presentes en el agregado (o documento). Un ejemplo de base de datos que admite ambas posibilidades es MongoDB. En MongoDB, los documentos de un mismo tipo se agrupan en colecciones y la fragmentación (sharding) se efectúa a nivel de colección. Las colecciones se pueden fragmentar según el valor de ciertos atributos, dando lugar a fragmentos (shards) que constituyen la unidad de distribución. Fijémonos que esta estrategia ayuda a resolver consultas por rangos que impliquen a los atributos usados en la fragmentación, dado que documentos con valores cercanos para esos atributos estarán posiblemente en el mismo fragmento. Los fragmentos son distribuidos automáticamente y de forma equitativa por el gestor de la base de datos entre los nodos. Si en algún momento la carga de trabajo se desequilibra (por ejemplo, un nodo pasa a almacenar un volumen de documentos muy superior al resto), el gestor la reequilibra de forma automática. Las bases de datos orientadas a columnas también realizan el sharding a partir del valor que toma la clave. Recordemos que este modelo se puede ver como una tabla compuesta por filas. Cada fila queda identificada por la clave y representa un agregado. A su vez, cada agregado se puede organizar en columnas y/o familias de columnas. Si se desea que agregados con valores próximos para la clave queden agrupados en un mismo fragmento que, a su vez, se almacena en al menos un nodo, la estrategia seguida para generar las claves es de importancia primordial. A modo de ejemplo, BigTable utiliza URL invertidas como claves (por ejemplo, una URL como www.cnn.com se transformaría en com.cnn.www). Las claves se disponen en orden lexicográfico y se agrupan en rangos (cada rango recibe el nombre de tablet). La tablet (que vendría a ser un shard) es la unidad de distribución. Con esta estrategia, por ejemplo, se consigue que el contenido de páginas web de un mismo dominio se realice de forma eficiente dado que pertenecerán a una misma tablet y estarán, en consecuencia, almacenadas en un mismo nodo. Además, a nivel de cada nodo, BigTable permite que las columnas y familias de columnas de los agregados se puedan segregar en grupos (denominados locality groups), que a su vez, se almacenan localmente de forma separada. En definitiva, permite efectuar una fragmentación vertical. La segregación de columnas (o familias de columnas) que no se acceden de manera conjunta en grupos separados permite mejorar el ratio de datos útiles recuperados en las operaciones de consulta (sólo se leen los grupos de columnas o familias de columnas relevantes).	C00140001203	¿Cómo se organiza el almacenamiento de los agregados en una base de datos orientada a columnas, y cómo se utiliza la clave para la distribución de los agregados?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: '¿Cómo se organiza el almacenamiento de los agregados en una base de datos orientada a columnas, y cómo se utiliza la clave para la distribución de los agregados?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001301	What is the main purpose of the first stage of designing a database, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main purpose of the first stage of designing a database, according to the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001302	What type of models are used in the second stage of designing a database, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What type of models are used in the second stage of designing a database, according to the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001303	What is the focus of the third stage of designing a database, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the focus of the third stage of designing a database, according to the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001304	What is the difference between the model lógico and the modelo conceptual in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the difference between the model lógico and the modelo conceptual in the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001305	What is the importance of considering the system manager of the database when transforming the model conceptual into a model lógico, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the importance of considering the system manager of the database when transforming the model conceptual into a model lógico, according to the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001306	What are some strategies that can be used to distribute databases, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What are some strategies that can be used to distribute databases, according to the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001307	How does the author suggest that one should proceed when creating a distributed database, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How does the author suggest that one should proceed when creating a distributed database, according to the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001308	What is the relationship between the modelo de distribución and the modelo lógico in the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the relationship between the modelo de distribución and the modelo lógico in the passage?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001309	According to the passage, what is the current state of research regarding the elaboración del modelo lógico for non-relational databases?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'According to the passage, what is the current state of research regarding the elaboración del modelo lógico for non-relational databases?'  
C001400013	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	14 14 Para finalizar esta presentación queremos repasar brevemente las etapas en las que clásicamente se desglosa el diseño de bases de datos. En la primera etapa se elabora un modelo conceptual de la base de datos, es decir, se obtiene una conceptualización de aquella parte del mundo real que nos interesa representar. El modelo conceptual es independiente de la tecnología de implementación, y para su elaboración podemos utilizar, por ejemplo, diagramas de clases de UML o el modelo ER. Por su parte, en la segunda etapa, se procede a la transformación del modelo conceptual, dando como resultado un modelo lógico de la base de datos. Para la transformación, es necesario considerar el modelo de datos en el que se basa el sistema gestor de la base de datos que se usará. Así pues, el modelo lógico resultante será diferente si se trata de una base de datos relacional, una base de datos basada en un modelo clave-valor, documental, orientado a columnas o en grafo. Si la base de datos va a ser distribuida, en esta etapa, también será necesario diseñar el modelo de distribución. Las estrategias que se pueden usar para su elaboración han sido el foco de interés de esta presentación. Finalmente, en la tercera etapa, es cuando se procede propiamente a la creación de la base de datos. Además de crear estructuras (sea de forma explícita o implícita) e insertar datos, se pueden tomar otro tipo de decisiones, por ejemplo, qué índices crear, dónde y cómo se almacenarán los datos localmente (en qué ficheros y dispositivos de almacenamiento) etc. Los diferentes métodos que se pueden seguir en la primera etapa están bien estudiados y proceden del ámbito de la ingeniería del software. Por su parte, los métodos y técnicas a aplicar en las dos siguientes etapas pertenecen principalmente al ámbito de bases de datos. En el caso de bases de datos relacionales existe una teoría sólida que permite sistematizar el proceso de diseño lógico y físico. En el caso de las bases de datos NoSQL, está bien estudiado (tanto desde un punto de vista teórico como práctico) la elaboración del modelo de distribución y el diseño físico. Sin embargo, hay una cierta ausencia de teoría que indique cuáles serían las técnicas de modelado de datos más apropiadas para la elaboración del modelo lógico. Durante el curso hemos dado algunas indicaciones a este respecto. Aquellos de vosotros que queráis profundizar en estos aspectos, os recomendamos la cuarta de las referencias incluidas al final de esta presentación.	C00140001310	What are some of the decisions that need to be made during the creation of a database, according to the passage?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What are some of the decisions that need to be made during the creation of a database, according to the passage?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001401	What is the main topic discussed in the presented video?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the main topic discussed in the presented video?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001402	According to the presentation, what are two fundamental concepts associated with distributed database design?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'According to the presentation, what are two fundamental concepts associated with distributed database design?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001403	In relation to fragmentation and replication strategies, what type of databases does the presentation focus on (relational or NoSQL)?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'In relation to fragmentation and replication strategies, what type of databases does the presentation focus on (relational or NoSQL)?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001404	Can you list at least three adaptation methods mentioned in the presentation for each strategy (fragmentation and replication)?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Can you list at least three adaptation methods mentioned in the presentation for each strategy (fragmentation and replication)?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001405	What is the purpose of the presentation, according to the final sentence?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the purpose of the presentation, according to the final sentence?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001406	How many references do the authors provide at the end of the presentation for further learning?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'How many references do the authors provide at the end of the presentation for further learning?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001407	What is the title of the document being presented (including the abbreviations used)?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the title of the document being presented (including the abbreviations used)?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001408	Who is the intended audience for this presentation (based on the closing statement)?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Who is the intended audience for this presentation (based on the closing statement)?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001409	What is the estimated time spent watching the video, according to the opening sentence?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'What is the estimated time spent watching the video, according to the opening sentence?'  
C001400014	BDD_Disen╠âo	Estrategias de distribución.  EIMT.U	synthetic_question	En esta presentación hemos estudiado conceptos fundamentales asociados al diseño de bases de datos distribuidas. Entre ellos, destacan las estrategias de fragmentación y replicación que se pueden usar, con sus correspondientes adaptaciones, tanto en bases de datos relacionales como en bases de datos NoSQL. 16 16 Esperamos que hayáis disfrutado y aprendido con este vídeo. A continuación encontraréis algunas referencias que os permitirán profundizar más en los conceptos que hemos tratado. Que tengáis un buen día. 17 17	C00140001410	Does the presentation include any visual aids or examples to illustrate the concepts discussed?	passage: document 'BDD_Disen╠âo'; paragraph: 'Estrategias de distribución.  EIMT.U'; content: 'Does the presentation include any visual aids or examples to illustrate the concepts discussed?'  
