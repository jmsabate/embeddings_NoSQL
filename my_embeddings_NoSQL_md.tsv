chunk_key	doc_name	chunk_title	source	chunk	source_key	source_content	data_point
C002300001	Introduccio a Neo4j	Introducció a Neo4j	source	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000100	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca'  
C002300003	Introduccio a Neo4j	Introducció	source	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000300	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.'  
C002300004	Introduccio a Neo4j	1. Característiques generals	source	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000400	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.'  
C002300005	Introduccio a Neo4j	1.1. Versions	source	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000500	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	source	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000600	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	source	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000700	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	source	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000800	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: '(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	source	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000900	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	source	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001000	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	source	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001100	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	source	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001200	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	source	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001300	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	source	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001400	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	source	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001500	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	source	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001600	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	source	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001700	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	source	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001800	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	source	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001900	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.'  
C002300020	Introduccio a Neo4j	2. Model de dades	source	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002000	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	source	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002100	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:'  
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	source	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002200	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	source	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002300	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;'  "
C002300024	Introduccio a Neo4j	MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs	source	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	C00230002400	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs'; content: 'Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	source	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002500	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	source	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002600	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	source	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002700	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	source	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002800	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	source	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002900	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	"passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;'  "
C002300030	Introduccio a Neo4j	2.3. Restriccions	source	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003000	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	source	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003100	ON (c:Customer) ASSERT c.name IS UNIQUE;	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	source	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003200	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: '• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	source	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003300	ON (p:Product) ASSERT EXISTS (p.name) ;	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'ON (p:Product) ASSERT EXISTS (p.name) ;'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	source	CREATE CONSTRAINT constraint_name3	C00230003400	CREATE CONSTRAINT constraint_name3	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'CREATE CONSTRAINT constraint_name3'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	source	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003500	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	source	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003600	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'Per suprimir una restricció: DROP CONSTRAINT constraint_namel'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	source	Per conèixer les restriccions creades: CALL db.constraints	C00230003700	Per conèixer les restriccions creades: CALL db.constraints	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'Per conèixer les restriccions creades: CALL db.constraints'  
C002300038	Introduccio a Neo4j	CALL db.constraints	source	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003800	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.'  
C002300039	Introduccio a Neo4j	3. Operacions CRUD	source	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003900	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	source	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004000	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	source	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004100	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	source	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004200	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;'  
C002300043	Introduccio a Neo4j	MATCH (p:Product) RETURN p;	source	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	C00230004300	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p;'; content: 'La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	source	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004400	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	source	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004500	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'  
C002300046	Introduccio a Neo4j	MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	source	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	C00230004600	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'; content: 'La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	source	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004700	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)'  
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	source	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004800	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";'  "
C002300049	Introduccio a Neo4j	"MATCH (n) WHERE n.name=""bagpack"";"	source	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	C00230004900	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) WHERE n.name=""bagpack"";'; content: 'A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	source	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005000	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack""'  "
C002300051	Introduccio a Neo4j	RETURN c.customerName;	source	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005100	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: '• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits.'  "
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	source	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005200	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*''  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	source	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005300	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	source	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005400	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	source	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005500	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	source	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005600	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	source	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005700	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	source	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005800	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: '• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	source	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005900	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)'  "
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	source	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006000	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })'  
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	source	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006100	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),'  "
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	source	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006200	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	source	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006300	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;'  
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	source	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006400	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	source	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006500	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: '2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	source	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006600	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()'  
C002300067	Introduccio a Neo4j	DELETE c, r;	source	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006700	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	source	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006800	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	source	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006900	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	source	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007000	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex''  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	source	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007100	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)'  
C002300072	Introduccio a Neo4j	SET p:Customer;	source	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007200	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex''  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	source	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007300	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	source	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007600	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000101	What is the recommended minimum time dedication for learning Neo4j according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'What is the recommended minimum time dedication for learning Neo4j according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000102	Who is the author of the resource creation and coordination at the University Open Catalonia (UOC)?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'Who is the author of the resource creation and coordination at the University Open Catalonia (UOC)?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000103	In which year did the author start collaborating as a consultant teacher at the UOC?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'In which year did the author start collaborating as a consultant teacher at the UOC?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000104	What type of degrees does the author have, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'What type of degrees does the author have, according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000105	What is the focus of the author's career professional, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'What is the focus of the author's career professional, according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000106	What is the name of the course where the author has been teaching related to relational databases, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'What is the name of the course where the author has been teaching related to relational databases, according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000107	What is the name of the assignment where the author acts as a tutor, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'What is the name of the assignment where the author acts as a tutor, according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000108	When was the first edition of this learning resource created, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'When was the first edition of this learning resource created, according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000109	Which license applies to the texts and images published in this work, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'Which license applies to the texts and images published in this work, according to the paragraph?'  
C002300001	Introduccio a Neo4j	Introducció a Neo4j	synthetic_question	PID_00281030 Joan Anton Pérez Braña Temps mínim de dedicació recomanat: 3 hores Enginyer superior d’Informàtica (UOC) i llicenciat en Ciències Biològiques (UB). Ha desenvolupat la seva carrera professional com a professor d’informàtica i, últimament, com a enginyer de dades. Des de l’any 2008 col·labora com a consultor docent a la UOC en assignatures relacionades amb bases de dades relacionals en enginyeria multimèdia, amb bases de dades NoSQL del grau de Ciència de Dades Aplicada (Applied Data Science), i com a tutor de projecte de final de carrera (TFC-XML i Web semàntica) en Informàtica de Gestió. L'encàrrec i la creació d'aquest recurs d'aprenentatge UOC han estat coordinats pel professor: Jordi Conesa Caralt Primera edició: febrer 2022 © d’aquesta edició, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoria: Joan Anton Pérez Braña Producción: FUOC Els textos i imatges publicats en aquesta obra estan subjectes –llevat que s'indiqui el contrari– a una llicència Creative Commons de tipus Reconeixement-Compartir igual (BY-SA) v.3.0. Podeu modificar l'obra, reproduirla, distribuir-la o comunicar-la públicament sempre que en citeu l'autor i la font (Fundació per a la Universitat Oberta de Catalunya), i sempre que l'obra derivada quedi subjecta a la mateixa llicència que l'obra original. La llicència completa es pot consultar a http://creativecommons.org/ licenses/by-sa/3.0/es/legalcode.ca	C00230000110	Can the reader modify, reproduce, distribute, or communicate the work publicly, and if so, under what conditions?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció a Neo4j'; content: 'Can the reader modify, reproduce, distribute, or communicate the work publicly, and if so, under what conditions?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000301	What is the current most popular NoSQL database among graph databases?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'What is the current most popular NoSQL database among graph databases?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000302	How does Neo4j provide flexibility to applications accessing its data?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'How does Neo4j provide flexibility to applications accessing its data?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000303	Does Neo4j support distributed data management?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'Does Neo4j support distributed data management?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000304	Can transactions be replicated in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'Can transactions be replicated in Neo4j?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000305	What type of data model does Neo4j use?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'What type of data model does Neo4j use?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000306	What is Cypher, and what is it used for in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'What is Cypher, and what is it used for in Neo4j?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000307	Can you describe a basic query using Cypher to perform a task such as inserting, modifying, or retrieving data in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'Can you describe a basic query using Cypher to perform a task such as inserting, modifying, or retrieving data in Neo4j?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000308	How does Neo4j handle transactions?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'How does Neo4j handle transactions?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000309	Are there any limitations to the number of nodes or relationships that can be stored in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'Are there any limitations to the number of nodes or relationships that can be stored in Neo4j?'  
C002300003	Introduccio a Neo4j	Introducció	synthetic_question	Neo4j és actualment la base de dades NoSQL en graf més popular. Aquesta base de dades ofereix un entorn de treball que atorga una gran flexibilitat a les aplicacions que accedeixen a les seves dades, permeten una gestió de dades distribuïda, replicació de transaccions i ofereix diferents llenguatges de manipulació de dades. Aquest material ofereix als lectors amb coneixements generals de base de dades NoSQL una introducció a Neo4j, tot enumerant les seves principals característiques, detallant el model de dades que utilitza i explicant el sistema transaccional que ofereix. Finalment, s’introdueix Cypher, el llenguatge de consulta proposat per Neo4j, i es mostra com utilitzar-lo per realitzar tasques bàsiques de consulta, modificació i inserció de dades.	C00230000310	Can you explain the difference between a node and a relationship in Neo4j's data model?	passage: document 'Introduccio a Neo4j'; paragraph: 'Introducció'; content: 'Can you explain the difference between a node and a relationship in Neo4j's data model?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000401	What is the name of the database in graph created by Neo Technology Inc?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'What is the name of the database in graph created by Neo Technology Inc?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000402	According to the passage, what is the current ranking of Neo4j among all databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'According to the passage, what is the current ranking of Neo4j among all databases?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000403	In which year was Neo4j created?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'In which year was Neo4j created?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000404	How many databases does Neo4j currently rank among, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'How many databases does Neo4j currently rank among, according to the passage?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000405	Can you summarize the main idea of the first sentence of the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'Can you summarize the main idea of the first sentence of the paragraph?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000406	What type of database is Neo4j, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'What type of database is Neo4j, according to the passage?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000407	Who is the developer of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'Who is the developer of Neo4j?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000408	What is the purpose of creating Neo4j, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'What is the purpose of creating Neo4j, according to the passage?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000409	Is Neo4j a popular database, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'Is Neo4j a popular database, according to the passage?'  
C002300004	Introduccio a Neo4j	1. Característiques generals	synthetic_question	Neo4j és una base de dades en graf creada per Neo Technology Inc. Actualment, és la base de dades en grafs més popular segons el rànquing DBEngines.com.1 Amb data de 2022, és la número vint de 383 en el rànquing global de bases de dades.	C00230000410	What is the number of Neo4j in the global ranking of databases, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '1. Característiques generals'; content: 'What is the number of Neo4j in the global ranking of databases, according to the passage?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000501	What is the name of the free version of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'What is the name of the free version of Neo4j?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000502	What is the main difference between the Community Edition and the Enterprise Edition of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'What is the main difference between the Community Edition and the Enterprise Edition of Neo4j?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000503	Is there a cloud-based option for running Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'Is there a cloud-based option for running Neo4j?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000504	What is the purpose of Neo4j Sandbox?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'What is the purpose of Neo4j Sandbox?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000505	Can the Enterprise Edition of Neo4j be used for commercial implementations?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'Can the Enterprise Edition of Neo4j be used for commercial implementations?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000506	How many instances of the database can be run on the same server using the Enterprise Edition of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'How many instances of the database can be run on the same server using the Enterprise Edition of Neo4j?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000507	Does the Community Edition of Neo4j support replication?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'Does the Community Edition of Neo4j support replication?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000508	What type of licenses does Neo4j offer for the Enterprise Edition?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'What type of licenses does Neo4j offer for the Enterprise Edition?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000509	Can the Enterprise Edition of Neo4j be deployed on all three major operating systems (Windows, Linux, and OS X)?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'Can the Enterprise Edition of Neo4j be deployed on all three major operating systems (Windows, Linux, and OS X)?'  
C002300005	Introduccio a Neo4j	1.1. Versions	synthetic_question	Neo4j està disponible en sistemes operatius de les famílies Windows, Linux i OS X. Existeix una versió gratuïta anomenada Community Edition, que utilitza la llicència GPL v3, i una versió de subscripció anomenada Enterprise Edition, que està dissenyada per a implementacions comercials on l’escalat i la disponibilitat són importants. La principal diferència entre elles és que la versió Enterprise permet executar més d’una instància de base de dades en un mateix servidor, incorpora suport i proporciona funcionalitats de replicació, monitoratge i alta disponibilitat. En canvi, la versió Community tan sols permet executar una instància de la base de dades a un servidor, i no admet fragmentació ni replicació. Per utilitzar Neo4j Enterprise es pot triar entre la llicència comercial, la llicència de desenvolupador o la llicència d’avaluació. També es pot optar per utilitzar Neo4j Aura Cloud DBaaS com la manera més senzilla d’executar Neo4j al núvol. Neo4j Aura és un producte basat en subscripció, totalment automatitzat i administrat. Finalment, val la pena esmentar Neo4j Sandbox com una excel·lent manera gratuïta de provar Neo4j sense descarregar ni instal·lar res localment. Un cop iniciada la sessió, es pot triar un projecte amb el qual començar a treballar, segons el projecte disposarem d'un conjunt de dades de prova o unes altres.	C00230000510	What is the name of the paragraph we are reading?	passage: document 'Introduccio a Neo4j'; paragraph: '1.1. Versions'; content: 'What is the name of the paragraph we are reading?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000601	What is the main topic discussed in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'What is the main topic discussed in the given paragraph?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000602	According to the passage, what is the purpose of using etiquettes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'According to the passage, what is the purpose of using etiquettes in Neo4j?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000603	Can you describe the type of graph used in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'Can you describe the type of graph used in Neo4j?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000604	How do properties work in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'How do properties work in Neo4j?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000605	What is an example of a property in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'What is an example of a property in Neo4j?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000606	How does Neo4j differ from traditional relational databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'How does Neo4j differ from traditional relational databases?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000607	"What is meant by ""schemaless"" in the context of Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'What is meant by ""schemaless"" in the context of Neo4j?'  "
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000608	"Can you explain the concept of ""tips"" in Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'Can you explain the concept of ""tips"" in Neo4j?'  "
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000609	How do labels and etiquettes contribute to the flexibility of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'How do labels and etiquettes contribute to the flexibility of Neo4j?'  
C002300006	Introduccio a Neo4j	1.2. Model de dades	synthetic_question	El model de dades utilitzat a Neo4j és un graf de propietats etiquetat. Les unitats bàsiques de processament de Neo4j són: nodes, relacions entre nodes, propietats, i etiquetes que permeten definir el tipus de nodes i de les relacions. Les propietats de Neo4j es poden definir sobre els nodes o les relacions. Neo4j es considera una base de dades schemaless i, com a tal, permet afegir informació sense la necessitat d'especificar l’esquema de les dades a priori. Tot i ser schemaless, l’ús d’etiquetes permet associar tipus als elements dels grafs, per (1)<https://db-engines.com/en/ ranking>. exemple, per indicar que un node és de tipus «client», o que una relació que relaciona un client i una adreça és de tipus «adreça principal». El fet que les etiquetes es puguin afegir als nodes i a les relacions per representar el tipus al qual pertanyen permet operacions de consulta o modificació més expressives, i es poden preguntar coses com, per exemple, «Dona’m tots els nodes que són de tipus comanda». L’ús d’etiquetes fa que part de l’esquema estigui definit implícitament en els grafs. És per això que, per evitar ambigüitats i redundàncies, és recomanable planificar de manera ordenada la semàntica a utilitzar (tipus de node i tipus de relació, principalment) abans de la creació dels nodes i les relacions.	C00230000610	In what way does the use of etiquettes facilitate querying and modifying data in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.2. Model de dades'; content: 'In what way does the use of etiquettes facilitate querying and modifying data in Neo4j?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000701	What is the main purpose of Neo4j according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the main purpose of Neo4j according to the given paragraph?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000702	How does Neo4j allow access to its data?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How does Neo4j allow access to its data?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000703	What are the different ways to interact with Neo4j's data, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What are the different ways to interact with Neo4j's data, according to the paragraph?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000704	What is Cypher, and how is it related to Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is Cypher, and how is it related to Neo4j?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000705	What is Gremlin, and how is it specific to graph databases like Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is Gremlin, and how is it specific to graph databases like Neo4j?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000706	What is GQL, and how does it differ from other query languages for graph databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is GQL, and how does it differ from other query languages for graph databases?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000707	How does Neo4j traverse graphs differently than other types of databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How does Neo4j traverse graphs differently than other types of databases?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000708	"Can you explain the concept of ""graph traversal"" in the context of Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Can you explain the concept of ""graph traversal"" in the context of Neo4j?'  "
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000709	How do the various query languages available in Neo4j differ in their approach to solving queries?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How do the various query languages available in Neo4j differ in their approach to solving queries?'  
C002300007	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	Neo4j permet accedir a les seves dades de diverses maneres i utilitzant diferents llenguatges de consulta. Es pot accedir a les seves dades des d’una consola de text, un entorn web (amb sortida gràfica) i mitjançant API. Pel que fa a les API, Neo4j disposa de drivers2 per a molts llenguatges de programació i una API REST,3 la qual permet consultar i modificar les dades de la base de dades mitjançant sol·licituds HTTP. Pel que fa als seus llenguatges de consulta, destaca Cypher,4 que és un llenguatge declaratiu que permet consultar i manipular grafs, i Gremlin,5 que és un llenguatge específic de domini per a la gestió de grafs. Gremlin pot definir amb més detall quin patró de recorregut s'ha de fer servir per resoldre una consulta (o altres algorismes propis), mentre que a Cypher el motor de la base de dades és el que intenta trobar la millor solució de recorregut per si mateix. Actualment, s’està treballant en el desenvolupament de l’estàndard GQL (Graph Query Language),6 que fusiona el millor de Cypher, PGQL i G-CORE7 en un llenguatge de consulta més complet creat específicament per a solucions basades en grafs. La manera amb la qual Neo4j treballa amb les dades a Neo4j és totalment diferent del que s’ha vist fins ara en altres tipus de bases de dades: en bases de dades NoSQL, basades en models d’agregació, s’hi accedia a través de les seves claus i, en les bases de dades relacionals, des dels seus tipus (relacions), les seves interrelacions (claus foranes), els seus identificadors (claus primàries) i els seus atributs. A Neo4j, per identificar un conjunt de dades sobre les quals s'ha aplicar una operació, es realitza el que s’anomena graph traversing. Es podria traduir graph traversing com a «navegació pel graf», que és l’acció de navegar pel graf des d’un punt d’inici (o un conjunt de punts d’inici) per obtenir els resultats desitjats (és a dir, obtenir els elements sobre els quals s'ha de fer una operació o consulta).	C00230000710	In what way is Neo4j's approach to data management unique compared to other database systems?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'In what way is Neo4j's approach to data management unique compared to other database systems?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000801	What is the focus of the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the focus of the paragraph?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000802	What is the advantage of using a native graph database like Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the advantage of using a native graph database like Neo4j?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000803	How does Neo4j store and retrieve data related to nodes?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How does Neo4j store and retrieve data related to nodes?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000804	What is the key feature that enables high performance in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the key feature that enables high performance in Neo4j?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000805	How does Neo4j execute queries on graphs?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How does Neo4j execute queries on graphs?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000806	Can you describe the process of navigating through nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Can you describe the process of navigating through nodes in Neo4j?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000807	What is the time complexity of obtaining related nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the time complexity of obtaining related nodes in Neo4j?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000808	How does Neo4j support large-scale graph processing?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How does Neo4j support large-scale graph processing?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000809	What is the significance of the absence of an index in Neo4j's architecture?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the significance of the absence of an index in Neo4j's architecture?'  
C002300008	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	(2)<https://neo4j.com/developer/language-guides/#neo4j-drivers>. (3)<https://neo4j.com/docs/httpapi/3.5/>. (4)<https://neo4j.com/developer/cypher/>. (5)<https://arxiv.org/ abs/1508.03843>. (6)<https://neo4j.com/press-releases/query-language-graph-databases-international-standard/>. (7)<https://gql.today/wp-content/uploads/2018/05/ytz-030r1Summary-Chart-of-Cypher-PGQLGCore-1.pdf>. Atès que Neo4j és una base de dades en grafs nativa (és a dir, té un graf com a model de dades central), admet grafs d’alt volum on les dades connectades es poden creuar en temps constant. Això es deu al fet que la manera com s’emmagatzemen les dades i s’executen les consultes s’optimitza per a l’ús de grafs, i hi ha una característica clau per aconseguir un alt rendiment: l’adjacència sense índex, index-free adjacency. En comptes de dependre d’un índex global per accedir als nodes connectats, quan els nodes s’emmagatzemen al disc, s’hi afegeix un punter que fa referència a cadascun dels nodes relacionats. Això fa que aconseguir els nodes relacionats a un node en particular sigui immediat. Tot i que la manca d’un índex global per a les relacions dels nodes és el que dona nom a la propietat d’adjacència sense índex, index-free adjacency, es pot pensar que cada node en realitat té un petit índex per a tots els nodes propers, amb la qual cosa s'aconsegueix que les operacions de navegació entre nodes siguin poc costoses. A partir d’aquesta estructura, les bases de dades basades en grafs realitzen consultes de grafs de forma nativa, i es pot executar l’algorisme BFS,8 Breadth First Search, dins del motor de consultes de la base de dades. El cost d’obtenir els nodes relacionats a partir d’un node donat serà O(1), executat en temps constant, ja que tots els nodes relacionats estan referenciats directament al nivell del node.	C00230000810	Can you explain how Neo4j's approach to storing and retrieving data differs from traditional relational databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Can you explain how Neo4j's approach to storing and retrieving data differs from traditional relational databases?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000901	What is the purpose of defining indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'What is the purpose of defining indexes in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000902	How does Neo4j improve the performance of searches using indexes?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How does Neo4j improve the performance of searches using indexes?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000903	Can you access directly to a node containing a specific value for a property defined in an index?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Can you access directly to a node containing a specific value for a property defined in an index?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000904	Is it possible to create an index on multiple properties in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Is it possible to create an index on multiple properties in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000905	How do adjacency and indexing differ in terms of search efficiency in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How do adjacency and indexing differ in terms of search efficiency in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000906	In which situations would you use indexes instead of adjacency in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'In which situations would you use indexes instead of adjacency in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000907	Can you provide an example of how indexes can be used to improve the performance of a search in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Can you provide an example of how indexes can be used to improve the performance of a search in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000908	Are there any limitations or trade-offs associated with using indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Are there any limitations or trade-offs associated with using indexes in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000909	How do you determine which properties to include in an index when working with large datasets in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'How do you determine which properties to include in an index when working with large datasets in Neo4j?'  
C002300009	Introduccio a Neo4j	1.3. Llenguatges de consulta	synthetic_question	No obstant això, Neo4j també permet definir índexs sobre les dades per millorar el rendiment de les consultes. Aquests índexs bàsicament permeten indexar les propietats dels nodes. D’aquesta manera, es pot accedir directament al node que contingui un cert valor per a la propietat definida a l’índex. És a dir, l’adjacència sense índexs permet augmentar l’eficiència en la cerca de dades relacionades i els índexs permeten augmentar-la en la cerca per contingut.	C00230000910	Can you explain the difference between an index and a label in Neo4j, and when each might be more appropriate to use?	passage: document 'Introduccio a Neo4j'; paragraph: '1.3. Llenguatges de consulta'; content: 'Can you explain the difference between an index and a label in Neo4j, and when each might be more appropriate to use?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001001	What is the main idea of the first sentence of the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the main idea of the first sentence of the paragraph?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001002	How do operations executed within a transaction affect the graph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'How do operations executed within a transaction affect the graph?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001003	Can transactions be used when using the browser interface of Neo4J?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Can transactions be used when using the browser interface of Neo4J?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001004	What is the purpose of the BEGIN and COMMIT sentences in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the purpose of the BEGIN and COMMIT sentences in Cypher?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001005	Does Neo4j satisfy the ACID properties?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Does Neo4j satisfy the ACID properties?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001006	What type of replication does Neo4j use?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What type of replication does Neo4j use?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001007	Why might the information stored in the nodes of the replicas not be completely up-to-date?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Why might the information stored in the nodes of the replicas not be completely up-to-date?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001008	What is the purpose of confirming a transaction even if new values have not been propagated to any of the secondary nodes?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the purpose of confirming a transaction even if new values have not been propagated to any of the secondary nodes?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001009	How can transactions be performed using the API?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'How can transactions be performed using the API?'  
C002300010	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	A Neo4j, cada operació que accedeixi al graf o als seus índexs s’ha d’executar dins d’una transacció. Les transaccions poden incorporar múltiples operacions. Avui, l’ús de transaccions només es pot realitzar explícitament accedint a Neo4j des de la seva API o el seu intèrpret de comandes textual. No és possible utilitzar transaccions quan s’utilitza el browser de Neo4J (el seu intèrpret de comandes web); en aquest cas, totes les operacions s’executen com si es tractés d’una transacció (mode autocommit). Tingueu en compte que una sentència a Cypher pot modificar tots els seus nodes o un node del graf, i que tot això s’executarà en una sola transacció. Aquest és un aspecte a tenir en compte a l’hora d’utilitzar sentències d’actualització a Cypher. (8)<https://www.hackerearth.com/ practice/ algorithms/graphs/breadth-firstsearch/tutorial/>. Si utilitzem Cypher des de l’intèrpret de comandes textual o en versions anteriors de l’entorn web, es pot indicar l’inici i el final d’una transacció amb les sentències :BEGIN i :COMMIT. Segons la documentació, el sistema transaccional de Neo4j satisfà les propietats ACID. Encara que les propietats ACID se satisfan en els casos en què la informació s’emmagatzema en una base de dades centralitzada, en un sistema distribuït, ja que a Neo4j la replicació és master-slave asíncrona, ens podem trobar que la informació emmagatzemada en els nodes de rèplica no estigui completament actualitzada. Per tal d’augmentar la disponibilitat de les dades, Neo4j accepta la confirmació de la transacció, fins i tot si els nous valors no s’han pogut propagar a cap de les rèpliques allotjades en els nodes secundaris. En aquest escenari, el sistema proporciona consistència final en el temps. Mitjançant l’ús de l’API, les transaccions es poden realitzar d’acord amb el model de consistència causal. Es diu que A causa potencialment B o que B precedeix causalment A si algun procés efectua una operació d’escriptura A, i algun procés (el mateix o un altre) que ha observat A efectua després una operació d’escriptura B; aleshores, és possible que A sigui la causa de B. La consistència causal garanteix que, si A precedeix causalment B, llavors tot procés del sistema observa A abans d’observar B. En canvi, dues operacions d’escriptura C i D s’anomenen causalment independents si cap de les dues precedeix causalment l’altra. En aquest cas, un procés pot observar C abans de D o D abans de C.	C00230001010	What is the difference between two operations being causally dependent versus independent?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the difference between two operations being causally dependent versus independent?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001101	What is the main condition required for a system to provide consistent behavior?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the main condition required for a system to provide consistent behavior?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001102	What type of consistency model does the system use if this condition is met?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What type of consistency model does the system use if this condition is met?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001103	How do operations written in the system's order of precedence relate to each other?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'How do operations written in the system's order of precedence relate to each other?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001104	Is the system's consistency model more strict or weaker compared to another model?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Is the system's consistency model more strict or weaker compared to another model?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001105	What is the name of the weaker consistency model used by the system?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the name of the weaker consistency model used by the system?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001106	In which scenario would the system's consistency model be more appropriate?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'In which scenario would the system's consistency model be more appropriate?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001107	Can all operations in the system be considered in the order they were issued?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Can all operations in the system be considered in the order they were issued?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001108	Does the system guarantee that all operations will be seen by every process in the correct order?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'Does the system guarantee that all operations will be seen by every process in the correct order?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001109	How does the system ensure consistency across different processes?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'How does the system ensure consistency across different processes?'  
C002300011	Introduccio a Neo4j	1.4. Model transaccional	synthetic_question	Un sistema proporciona consistència causal si es compleix aquesta condició: les operacions d’escriptura que estan causalment relacionades són vistes per cada procés del sistema en el seu ordre de precedència causal. El model de consistència causal és més feble que el model de consistència estricta, que exigeix que totes les operacions es considerin en l’ordre en què es van emetre.	C00230001110	What is the purpose of the system's consistency model, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.4. Model transaccional'; content: 'What is the purpose of the system's consistency model, according to the given paragraph?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001201	What is the main topic of the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'What is the main topic of the paragraph?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001202	According to the paragraph, what type of isolation does Neo4j use by default?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'According to the paragraph, what type of isolation does Neo4j use by default?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001203	What is the difference between read committed isolation and serializable isolation?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'What is the difference between read committed isolation and serializable isolation?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001204	What is an example of a situation where read committed isolation might cause issues?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'What is an example of a situation where read committed isolation might cause issues?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001205	How do shared locks (of type S) work in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'How do shared locks (of type S) work in Neo4j?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001206	Can users directly perform locking operations in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Can users directly perform locking operations in Neo4j?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001207	What is the purpose of using bloqueigs (reserves S, X) in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'What is the purpose of using bloqueigs (reserves S, X) in Neo4j?'  
C002300012	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	Pel que fa a la gestió de concurrència, Neo4j utilitza el típic sistema pessimista de bloquejos (o reserves S, X), on les operacions d’escriptura bloquegen les dades fins a la seva finalització perquè no es perdin canvis. Segons la documentació, el bloqueig es realitza en l’àmbit de nodes i relacions de la base de dades. En particular, en modificar (afegir o suprimir) un node o les seves propietats, el bloqueig es realitza només en el node afectat. No obstant això, quan es modifica (s'afegeix o es suprimeix) una relació, el bloqueig afecta tant la relació com els nodes que participen en la relació. És important esmentar que Neo4j, per defecte, garanteix un nivell d’aïllament read committed. Això vol dir que el sistema garanteix que, sempre que es fa efectiva una operació de lectura, s’obté l’últim valor confirmat. Aquest tipus d’aïllament és més feble que serialitzable, però ofereix importants avantatges de rendiment. En les transaccions a llarg termini, read committed, pot donar lloc a interferències de lectures no repetibles, és a dir, casos en què en una mateixa transacció es llegeixi dues vegades la mateixa dada i se n'obtinguin diferents valors. Això passarà, per exemple, quan en una transacció (T1) es realitzin dues lectures del mateix node (n) en dues ocasions diferents, i una altra transacció (T2) hagi modificat el node (n) entre la primera i la segona lectura. En alguns casos, aquest comportament pot ser problemàtic. Neo4j permet que les persones usuàries realitzin bloquejos directament. Això pot ser útil si es vol reforçar el nivell d’aïllament del sistema per evitar interferències com, per exemple, les lectures no repetibles comentades. Els bloquejos compartits (de tipus S) es realitzen quan es fa una lectura d’un objecte, tot evitant que altres transaccions escriguin o modifiquin aquell objecte. Aquest bloqueig permet lectures concurrents de les dades bloquejades, però no en permet actualitzacions.	C00230001208	When would it be useful to increase the level of isolation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'When would it be useful to increase the level of isolation in Neo4j?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001301	What is the purpose of an exclusive lock in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'What is the purpose of an exclusive lock in Neo4j?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001302	Can multiple transactions acquire an exclusive lock at the same time?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Can multiple transactions acquire an exclusive lock at the same time?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001303	If a transaction attempts to read or modify a node with an exclusive lock, what should it do?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'If a transaction attempts to read or modify a node with an exclusive lock, what should it do?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001304	How does a transaction know if a node has an exclusive lock or not?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'How does a transaction know if a node has an exclusive lock or not?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001305	Is it possible to acquire an exclusive lock on a relationship in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Is it possible to acquire an exclusive lock on a relationship in Neo4j?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001306	Can a transaction hold both an exclusive lock and a shared lock on different nodes or relationships simultaneously?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Can a transaction hold both an exclusive lock and a shared lock on different nodes or relationships simultaneously?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001307	If a transaction holds an exclusive lock on a node, can another transaction still read the node without acquiring its own exclusive lock?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'If a transaction holds an exclusive lock on a node, can another transaction still read the node without acquiring its own exclusive lock?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001308	How does Neo4j handle conflicts when two or more transactions attempt to acquire exclusive locks on the same node or relationship?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'How does Neo4j handle conflicts when two or more transactions attempt to acquire exclusive locks on the same node or relationship?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001309	Are there any scenarios where an exclusive lock might not be released even after a transaction commits or rolls back?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Are there any scenarios where an exclusive lock might not be released even after a transaction commits or rolls back?'  
C002300013	Introduccio a Neo4j	1.5. Gestió de la concurrència	synthetic_question	D’altra banda, un bloqueig s’anomena exclusiu (X) quan només una transacció pot mantenir el bloqueig en un moment donat. El bloqueig exclusiu no es pot adquirir si aquest node o aquesta relació ja té un altre bloqueig. Les transaccions que intenten llegir o modificar un node amb bloqueig exclusiu han d’esperar que el bloqueig exclusiu s’alliberi.	C00230001310	Can exclusive locks be used to implement optimistic concurrency control in Neo4j applications?	passage: document 'Introduccio a Neo4j'; paragraph: '1.5. Gestió de la concurrència'; content: 'Can exclusive locks be used to implement optimistic concurrency control in Neo4j applications?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001401	What is the main advantage of using Neo4j compared to other NoSQL databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'What is the main advantage of using Neo4j compared to other NoSQL databases?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001402	How does Neo4j support scalability, specifically regarding graph data distribution?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does Neo4j support scalability, specifically regarding graph data distribution?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001403	Can you explain the concept of sharding in Neo4j and how it differs from other NoSQL databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'Can you explain the concept of sharding in Neo4j and how it differs from other NoSQL databases?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001404	What are some challenges associated with fragmentation in Neo4j, and how can they be addressed?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'What are some challenges associated with fragmentation in Neo4j, and how can they be addressed?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001405	How does Neo4j handle queries when dealing with distributed graphs, and what techniques do developers need to consider?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does Neo4j handle queries when dealing with distributed graphs, and what techniques do developers need to consider?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001406	In what cases might sharding be considered an anti-pattern in Neo4j, and why?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'In what cases might sharding be considered an anti-pattern in Neo4j, and why?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001407	How does the lack of built-in MapReduce functionality in Neo4j impact query performance, especially when dealing with large datasets?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does the lack of built-in MapReduce functionality in Neo4j impact query performance, especially when dealing with large datasets?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001408	What are some best practices for designing a distributed graph database like Neo4j, and how should developers approach fragmentation?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'What are some best practices for designing a distributed graph database like Neo4j, and how should developers approach fragmentation?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001409	Can you discuss the tradeoffs between horizontal and vertical scaling in Neo4j, and under which circumstances each approach might be more appropriate?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'Can you discuss the tradeoffs between horizontal and vertical scaling in Neo4j, and under which circumstances each approach might be more appropriate?'  
C002300014	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Les peculiaritats dels grafs i el disseny de Neo4j fan que aquesta base de dades suporti millor l’escalabilitat vertical que l’horitzontal. Neo4j permet sharding, és a dir, permet la distribució dels grafs en diferents servidors. No obstant això, el sharding no es fa automàticament, sinó que s’ha de definir al mateix temps que es dissenya la base de dades i requereix un gran coneixement sobre el domini a modelar. Si es vol fer sharding, és important tenir un bon disseny de distribució. En cas contrari, es poden tenir rendiments baixos. El fet és que, si se separen parts relacionades del graf que sovint es consulten juntes, s’haurà d’accedir a diferents nodes del graf per navegar-hi. En el pitjor dels casos, pot ser que la navegació entre N nodes del graf impliqui consultar seqüencialment dades de N servidors diferents (en el cas que cada node del graf estigui en un servidor diferent). El fet que Neo4j no incorpori tècniques MapReduce per defecte fa encara més difícil fer consultes en bases de dades distribuïdes. La fragmentació de dades en un graf és una tasca molt complexa. Alguns dels motius són: La gran mutabilitat dels grafs. La gran quantitat de relacions entre nodes. La dificultat de trobar subgrafs disjunts o subgrafs poc interrelacionats. Aquests factors fan que sigui realment complex identificar diferents fragments del graf que es poden distribuir en els diferents servidors, perquè compleixin aquestes tres condicions: • No generar servidors sobrecarregats. Permetre ajustar fàcilment l’equilibri de càrrega a mesura que el graf creix. • No requerir, com a norma general, la navegació a través de diferents servidors, perquè les dades d’interès estan distribuïdes. Per tot això, la fragmentació no és un dels principals objectius de Neo4j. De fet, alguns experts mantenen que fer sharding en una base de dades de graf és un antipatró, de la mateixa manera que l’ús de combinacions (joins) també és un antipatró en les bases de dades NoSQL d’agregació. És clar que la fragmentació en una base de dades en graf no és tan natural com en les bases de dades NoSQL d’agregació, però en alguns casos també pot ser viable. A Neo4j, la fragmentació s’ha de fer manualment per part de l’equip que dissenya la base de dades.	C00230001410	How does Neo4j compare to other graph databases in terms of fragmentation and sharding capabilities, and what are some key differences that developers should be aware of?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does Neo4j compare to other graph databases in terms of fragmentation and sharding capabilities, and what are some key differences that developers should be aware of?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001501	What is the main objective of using fragmentation in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'What is the main objective of using fragmentation in a graph database?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001502	Why is it essential to identify the set of subgraphs that are less related?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'Why is it essential to identify the set of subgraphs that are less related?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001503	How does fragmentation help improve performance in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does fragmentation help improve performance in a graph database?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001504	Can you give an example of a use case where fragmentation might be useful and viable in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'Can you give an example of a use case where fragmentation might be useful and viable in a graph database?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001505	How does the xarxa de carreteres example illustrate the potential benefits of fragmentation in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does the xarxa de carreteres example illustrate the potential benefits of fragmentation in a graph database?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001506	What is one factor that should be considered when designing a fragmentation strategy for a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'What is one factor that should be considered when designing a fragmentation strategy for a graph database?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001507	According to the passage, what could happen if the design of fragmentation is not well realized?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'According to the passage, what could happen if the design of fragmentation is not well realized?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001508	"In the context of the passage, what does ""sharding"" refer to?"	"passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'In the context of the passage, what does ""sharding"" refer to?'  "
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001509	How does the idea of sharding relate to fragmentation in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'How does the idea of sharding relate to fragmentation in a graph database?'  
C002300015	Introduccio a Neo4j	1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació	synthetic_question	Per proporcionar fragmentació a una base de dades en graf, s’ha d’utilitzar informació del domini representat per identificar quins subgrafs s’han de distribuir a cada servidor. Un dels factors més importants en aquest procés serà identificar el conjunt de subgrafs que estan menys relacionats, amb l’objectiu de minimitzar les navegacions (graph traversals) que impliquen navegar entre nodes del graf emmagatzemats en diferents servidors. Això és important perquè, en el cas que el disseny de fragmentació estigui mal realitzat, hi pot haver casos en què consultar un conjunt de N nodes relacionats del graf impliqui obtenir dades seqüencialment de N servidors diferents, de manera que s’obtingui un rendiment molt baix. No obstant això, també és cert que, en alguns casos, el sharding podria ser útil i viable en una base de dades en graf. Un exemple seria per representar la xarxa de carreteres de diferents països. En aquest cas, la xarxa viària podria fragmentar-se segons el país on es trobi. Atès que les consultes de rutes es realitzen normalment en el context d’un país, les consultes es podrien realitzar localment al servidor que conté les dades i evitar, així els graph traversals entre servidors. D’altra banda, el nombre d’interrelacions entre els nodes dels grafs situats en els diferents servidors seria mínim, ja que en el seu contingut només hi hauria les carreteres que travessen la frontera.	C00230001510	What is the primary benefit of using fragmentation in a graph database, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6. Consideracions respecte a la distribució.  1.6.1. Fragmentació'; content: 'What is the primary benefit of using fragmentation in a graph database, according to the passage?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001601	What is the default replication architecture used by Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What is the default replication architecture used by Neo4j?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001602	How does Neo4j handle write operations in a replicated environment?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j handle write operations in a replicated environment?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001603	Can read operations be performed on both primary and secondary copies in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Can read operations be performed on both primary and secondary copies in Neo4j?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001604	How does Neo4j ensure data consistency across all copies in a cluster?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j ensure data consistency across all copies in a cluster?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001605	What is the purpose of using arbiters in a Neo4j cluster?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What is the purpose of using arbiters in a Neo4j cluster?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001606	How does Neo4j propagate changes from the primary copy to secondary copies?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j propagate changes from the primary copy to secondary copies?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001607	Is it possible to configure Neo4j to automatically propagate changes to secondary copies before completing a transaction?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Is it possible to configure Neo4j to automatically propagate changes to secondary copies before completing a transaction?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001608	What is the difference between asynchronous and optimistic replication in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What is the difference between asynchronous and optimistic replication in Neo4j?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001609	How does Neo4j ensure consistency of data during the transition period when a new primary copy is elected?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j ensure consistency of data during the transition period when a new primary copy is elected?'  
C002300016	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Per defecte, la replicació a Neo4j és gestionada per una arquitectura master-slave asíncrona, semblant a la que s’ha vist per a MongoDB. A Neo4j, actualment, aquesta funcionalitat està inclosa en les anomenades característiques high availability, que només estan disponibles a la versió Enterprise Edition. El seu funcionament és el següent: • Només hi ha un master (o còpia primària). • Les operacions d’escriptura es realitzen, per norma general, a la còpia primària (hi ha una excepció que es veurà més endavant). Les operacions de lectura es poden realitzar tant en la còpia primària com en les secundàries (que es troben en nodes slaves). • Se sincronitzen les dades (o valors) de les còpies (o rèpliques) secundàries a partir de les operacions realitzades a la còpia primària de manera asíncrona. • Es proporciona una còpia secundària com a nova còpia primària en cas que el node que emmagatzema la còpia primària caigui. • Es poden afegir, opcionalment, nodes del tipus àrbitre a un clúster. Aquests àrbitres permetran el desempat de les votacions que puguin sorgir a l’hora d’escollir una nova còpia primària. Les característiques anteriors fan que les rèpliques permetin a Neo4j augmentar la disponibilitat de les dades tot mantenint la consistència final al llarg del temps, això es deu al fet que la propagació dels canvis es realitza de manera asíncrona i que les operacions de consulta també es poden realitzar a les còpies secundàries. Per tant, des del moment en què es fa un canvi a la còpia primària fins que es propaga a les còpies secundàries, aquestes tindran valors diferents. No obstant això, és possible configurar Neo4j de manera que els canvis a la còpia primària es propaguin automàticament a les còpies secundàries abans de completar la transacció. Tanmateix, aquesta propagació es realitza de manera optimista, és a dir, s’accepta la confirmació de la transacció encara que el valor no s’hagi pogut propagar a cap de les rèpliques. Per aquest motiu, tot i que aquesta operació augmenta la consistència de les dades en el cas general, el sistema continua proporcionant consistència final en el temps, en el pitjor dels casos.	C00230001610	Can Neo4j be configured to use a different replication strategy, such as a two-phase commit protocol?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Can Neo4j be configured to use a different replication strategy, such as a two-phase commit protocol?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001701	What is one unique feature of Neo4j's replication management?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What is one unique feature of Neo4j's replication management?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001702	How does Neo4j ensure data consistency between primary and secondary nodes?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j ensure data consistency between primary and secondary nodes?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001703	What happens when a write operation is executed on a slave node in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What happens when a write operation is executed on a slave node in Neo4j?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001704	Why might it be advisable to perform certain operations on a slave node in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Why might it be advisable to perform certain operations on a slave node in Neo4j?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001705	What is the effect of executing an operation on both the primary and slave nodes simultaneously in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What is the effect of executing an operation on both the primary and slave nodes simultaneously in Neo4j?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001706	How does Neo4j guarantee data availability during operations on slave nodes?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j guarantee data availability during operations on slave nodes?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001707	Can you describe the potential drawback of using slave nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'Can you describe the potential drawback of using slave nodes in Neo4j?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001708	In what scenario might it be beneficial to use slave nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'In what scenario might it be beneficial to use slave nodes in Neo4j?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001709	How does Neo4j's replication management differ from other graph databases?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'How does Neo4j's replication management differ from other graph databases?'  
C002300017	Introduccio a Neo4j	1.6.2. Replicació	synthetic_question	Una altra peculiaritat en la gestió de rèpliques de Neo4j és que es permet que els nodes que emmagatzemen còpies secundàries (nodes slave) acceptin operacions d’escriptura. Quan això passa, l’escriptura es fa al node master (que emmagatzema la còpia primària) i al node slave al mateix temps (en una sola transacció), fet que garanteix que la còpia primària tingui el valor actualitzat en tot moment. Abans d’executar una operació d’aquesta mena, el sistema haurà de comprovar que les dades afectades sobre els nodes master i slave siguin les mateixes. En cas contrari, es descartarà l’operació. Aquest mode d’operació augmenta el temps d’execució de l’operació (i, en conseqüència, disminueix el temps de resposta). A més, bloqueja les dades de dos servidors i es redueix la disponibilitat del sistema. No obstant això, pot ser aconsellable realitzar aquest tipus d’operació quan es vulgui garantir que un node slave tingui les dades actualitzades en tot moment.	C00230001710	What is the main advantage of using slave nodes in Neo4j's replication management?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.2. Replicació'; content: 'What is the main advantage of using slave nodes in Neo4j's replication management?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001801	What is the main objective of using causal clustering in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'What is the main objective of using causal clustering in Neo4j?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001802	How does Neo4j ensure consistency across all instances in a cluster?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'How does Neo4j ensure consistency across all instances in a cluster?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001803	What are the two different roles played by servers in a Neo4j cluster?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'What are the two different roles played by servers in a Neo4j cluster?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001804	Where do all operations of writing occur in a Neo4j cluster?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Where do all operations of writing occur in a Neo4j cluster?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001805	How does the system guarantee consistency in the face of failures of multiple node types?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'How does the system guarantee consistency in the face of failures of multiple node types?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001806	Can you describe the quorum mechanism used by Neo4j to manage modifications made by replicas?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Can you describe the quorum mechanism used by Neo4j to manage modifications made by replicas?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001807	Under what circumstances would the system allow only reading operations until affected nodes are recovered?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Under what circumstances would the system allow only reading operations until affected nodes are recovered?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001808	How does the use of causal clustering affect the availability and scalability of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'How does the use of causal clustering affect the availability and scalability of Neo4j?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001809	In what way does the consistency model used by Neo4j differ from other distributed computing systems?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'In what way does the consistency model used by Neo4j differ from other distributed computing systems?'  
C002300018	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Les últimes versions de Neo4j ofereixen una manera alternativa de distribuir les dades del graf en una xarxa d’ordinadors, anomenada causal clustering. L’objectiu és oferir la màxima disponibilitat, proporcionant consistència causal i facilitant l’escalabilitat horitzontal. Recordeu que la consistència causal és un dels molts models de consistència utilitzats en la computació distribuïda. Garanteix que totes les instàncies del sistema vegin les operacions relacionades en el mateix ordre. En conseqüència, es garanteix que un client de la base de dades sempre llegeixi els seus propis escrits, independentment de la instància amb la qual es comuniqui. En aquesta arquitectura, el clúster es compon de servidors amb dos rols diferents, com es mostra a la figura 1: nuclis (core servers) i rèpliques de lectura (replica servers). Per a cadascun d’aquests rols, els servidors funcionaran de manera diferent amb l’objectiu de proporcionar la màxima disponibilitat i consistència en totes les situacions. Simplificant, es pot dir que els nuclis proporcionaran una consistència forta, mentre que les rèpliques de lectura proporcionaran més disponibilitat, però al preu de reduir la consistència a una consistència final en el temps. Font: elaboració pròpia Totes les operacions d’escriptura es realitzen en els nodes de tipus nucli. Un cop acabada una transacció d’escriptura, els canvis realitzats es propaguen de manera asíncrona a les rèpliques de lectura. La principal responsabilitat dels servidors de tipus nucli és protegir les dades. Per això, les modificacions de les rèpliques es gestionen mitjançant una tècnica de quòrum amb una W= (N/2+1), tot garantint que s’accepti una escriptura quan la majoria de les rèpliques han aplicat el canvi. El sistema es comportarà de manera consistent pel que fa a les escriptures, sempre que la majoria dels nodes de tipus nucli estiguin operatius. En el cas que la majoria dels nodes de tipus nucli estiguin caiguts, el clúster ja no serà capaç de processar les escriptures i només permetrà operacions de lectura fins que es recuperin els nuclis afectats.	C00230001810	What is the primary responsibility of nodes in a Neo4j cluster?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'What is the primary responsibility of nodes in a Neo4j cluster?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001901	What is the main purpose of causal clustering in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'What is the main purpose of causal clustering in Neo4j?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001902	How does Neo4j ensure consistency causal when executing transactions?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'How does Neo4j ensure consistency causal when executing transactions?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001903	What type of nodes are more volatile in Neo4j's cluster architecture?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'What type of nodes are more volatile in Neo4j's cluster architecture?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001904	Why might the number of reading replicas be greater than the number of core nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Why might the number of reading replicas be greater than the number of core nodes in Neo4j?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001905	How do clients request a marker (bookmark) in Neo4j to guarantee consistent execution of their transactions?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'How do clients request a marker (bookmark) in Neo4j to guarantee consistent execution of their transactions?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001906	Can you explain how Neo4j's cluster architecture ensures correct semantic from the client's perspective?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Can you explain how Neo4j's cluster architecture ensures correct semantic from the client's perspective?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001907	Who manages the selection of central servers and reading replicas in Neo4j's cluster architecture?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'Who manages the selection of central servers and reading replicas in Neo4j's cluster architecture?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001908	How does Neo4j's cluster architecture handle the loss of nodes during transaction execution?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'How does Neo4j's cluster architecture handle the loss of nodes during transaction execution?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001909	What is the primary benefit of using causal clustering in Neo4j's cluster architecture?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'What is the primary benefit of using causal clustering in Neo4j's cluster architecture?'  
C002300019	Introduccio a Neo4j	1.6.3. Causal clustering	synthetic_question	Com a norma general, les rèpliques de lectura s’encarregaran de les operacions de lectura i vetllaran perquè les càrregues de treball de les consultes realitzades s’escalin. Normalment, el nombre de rèpliques de lectura serà més gran que el nombre de nodes de tipus nucli. Els nodes de lectura poden ser més volàtils, ja que la seva pèrdua, tot i que pot reduir el rendiment general en les consultes, no afectarà la disponibilitat del clúster. Per garantir la consistència causal, en executar una transacció, el client pot sol·licitar un marcador (bookmark) que després presenta com a paràmetre per a les operacions posteriors. Mitjançant l’ús d’aquest marcador, el clúster pot garantir que només els servidors que han processat la transacció marcada del client executin la seva propera transacció. Això proporciona una cadena causal que assegura la correcta semàntica des del punt de vista del client. A part d’aquest marcador, tota la resta és gestionat pel clúster. Els controladors de la base de dades treballen amb l’administrador de topologia del clúster per escollir els servidors centrals i les rèpliques de lectura més adequades per obtenir un millor rendiment del sistema.	C00230001910	In what way does Neo4j's cluster architecture differ from traditional database architectures?	passage: document 'Introduccio a Neo4j'; paragraph: '1.6.3. Causal clustering'; content: 'In what way does Neo4j's cluster architecture differ from traditional database architectures?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002001	What is the main purpose of Neo4j's graph database, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'What is the main purpose of Neo4j's graph database, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002002	How does Neo4j store data differently than a relational database, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'How does Neo4j store data differently than a relational database, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002003	What is an example of a node in Neo4j, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'What is an example of a node in Neo4j, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002004	What are some of the properties that can be associated with nodes in Neo4j, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'What are some of the properties that can be associated with nodes in Neo4j, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002005	Can you describe one way in which Neo4j's graph structure allows for more efficient querying, compared to a relational database, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'Can you describe one way in which Neo4j's graph structure allows for more efficient querying, compared to a relational database, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002006	What is the significance of unique property restrictions in Neo4j, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'What is the significance of unique property restrictions in Neo4j, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002007	How do relationships between nodes work in Neo4j, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'How do relationships between nodes work in Neo4j, according to the passage?'  
C002300020	Introduccio a Neo4j	2. Model de dades	synthetic_question	Un cop introduïda la base de dades Neo4j, es veurà amb més detall el seu model de dades, els índexs que incorpora, i les equivalències entre el seu model de dades i el model relacional. Per explicar el model de dades de Neo4j, s’utilitzarà com a base el model relacional. A Neo4j, les dades s’emmagatzemen en un graf de propietats etiquetat. El graf conté un conjunt de nodes, relacions, etiquetes i propietats. Semànticament, els nodes serien l’equivalent a les files del model relacional, encara que pot haver-hi casos en els quals interessarà definir una relació o un esdeveniment com a node. Els nodes poden tenir un conjunt de propietats associat. Aquestes propietats són parells <nom, valor>, i permeten definir un conjunt de propietats per a cada node i els seus valors. Les propietats serien l’equivalent a les columnes en una base de dades relacional. Font: elaboració pròpia Seguint amb les propietats, des de la versió 2.0 de Neo4j, es poden definir restriccions d’integritat d'unicitat sobre les propietats de la base de dades. Per tant, es pot especificar que una propietat determinada de la base de dades, en el context d’un tipus de node, no pot contenir valors duplicats. En indicar que una propietat és única, Neo4j crea un índex sobre aquesta propietat per tal d’assegurar la unicitat i millorar l’eficiència de la seva consulta. En definir aquest tipus de restriccions sobre les propietats dels nodes, es poden simular claus primàries. Per representar les relacions entre els nodes de la base de dades, s’utilitzen relacions, que serien l’equivalent a les claus foranes del model relacional. És important tenir en compte que també es poden definir propietats sobre les relacions. Les relacions a Neo4j són dirigides i binàries. A Neo4j es pot navegar pel graf a fi d’obtenir dades o fer-hi operacions a sobre els elements del graf. Aquesta navegació permet, entre moltes altres coses, simular l’operació de combinació (join) relacional.	C00230002008	Can you explain how Neo4j's navigation feature allows for more flexible data manipulation, compared to a relational database, according to the passage?	passage: document 'Introduccio a Neo4j'; paragraph: '2. Model de dades'; content: 'Can you explain how Neo4j's navigation feature allows for more flexible data manipulation, compared to a relational database, according to the passage?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002101	What is the purpose of the example given in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the purpose of the example given in the paragraph?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002102	What is the difference between the original model and the transformed model into a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the difference between the original model and the transformed model into a graph database?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002103	How many attributes does each node have in the transformed model?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How many attributes does each node have in the transformed model?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002104	What is the purpose of using conventions for naming entities and relationships in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the purpose of using conventions for naming entities and relationships in Neo4j?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002105	What is the significance of the underlined words in the diagram representing the relationship between entities?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the significance of the underlined words in the diagram representing the relationship between entities?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002106	"Can you explain the meaning of ""la transformación del model conceptual"" mentioned in the paragraph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'Can you explain the meaning of ""la transformación del model conceptual"" mentioned in the paragraph?'  "
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002107	What is the purpose of defining classes for nodes and their properties in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the purpose of defining classes for nodes and their properties in Neo4j?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002108	How do the properties of a node help in understanding the structure of the data in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How do the properties of a node help in understanding the structure of the data in a graph database?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002109	In what way does the figure 5 illustrate the relationship between commands and their related elements in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'In what way does the figure 5 illustrate the relationship between commands and their related elements in a graph database?'  
C002300021	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	La figura 3 recull l’exemple vist en un mòdul anterior corresponent a una aplicació d’e-commerce. Font: elaboració pròpia Si es realitza la transformació al model relacional, s’observarà el gran nombre d’atributs corresponents a claus primàries (en verd i subratllades), i claus foranes (en vermell). Address(addressId, street, zipcode, city, country) Product(productId, name, msrp); Customer(customerId, name, addressId) {addressId} references Address (addressId); Product (productId, name, price); Payment (paymentId, paymentMethod, creditCardNumber, addressId) {addressId} references Address (addressId) ; Order(orderNumber, date, customerId, addressId) {customerId} references Customer(customerId) {addressId} references Address (addressId); OrderLine( orderLineId, orderNumber, productId, units, totalPrice) {orderNumber} references Order( orderNumber) ; {productId} references Product (productId) ; Font: elaboració pròpia La transformació del model conceptual descrit abans del model en graf es po- dria representar de la següent manera: Font: elaboració pròpia S’han utilitzat les convencions de nomenclatura recomanades a Neo4j: • Les relacions inclouen verbs i s’escriuen en majúscules, amb l’ús del subratllat per separar paraules. • Les etiquetes corresponen a noms i estan escrites en format camel-case, és a dir, cada paraula concatenada comença amb un caràcter en majúscules. • Les propietats, que corresponen a atributs de nodes i relacions comencen i continuen en minúscula, excepte les paraules concatenades, que es distingeixen en majúscula. A la figura 5 es pot veure un exemple que representa una comanda de venda i els seus elements relacionats en una base de dades en graf. Les comandes s’emmagatzemen com a nodes i cada comanda constitueix un node separat. En aquest cas, es pot veure com el node o1 determina la comanda que s’ha utilitzat en l’exemple. Es pot observar també que s’ha utilitzat una etiqueta anomenada Order per indicar que el node o1 és de tipus Order. Un cop definit el node de la comanda i la seva classe, es poden indicar les seves dades mitjançant propietats. En l’exemple es pot veure que s’han definit dues propietats:	C00230002110	What is the main idea behind using a graph database like Neo4j to store and manage data?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the main idea behind using a graph database like Neo4j to store and manage data?'  
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002201	What is the purpose of the graph design described in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the purpose of the graph design described in the paragraph?'  
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002202	"How does the ""orderNumber"" property uniquely identify each order in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How does the ""orderNumber"" property uniquely identify each order in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002203	"What type of relationship exists between the ""orderNumber"" property and the ""date"" property in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What type of relationship exists between the ""orderNumber"" property and the ""date"" property in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002204	"How do the ""client"" and ""payment"" nodes relate to each other in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How do the ""client"" and ""payment"" nodes relate to each other in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002205	"What is the purpose of the ""includes"" relationship in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the purpose of the ""includes"" relationship in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002206	"How do the ""product"" nodes relate to the ""order"" node in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How do the ""product"" nodes relate to the ""order"" node in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002207	"What is the significance of the ""name"" and ""msrp"" properties in the ""product"" nodes?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the significance of the ""name"" and ""msrp"" properties in the ""product"" nodes?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002208	"Why were addresses created for the ""client"" and ""payment"" nodes in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'Why were addresses created for the ""client"" and ""payment"" nodes in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002209	"What is the difference between the ""HAS_ADDRESS,"" ""HAS_BILLING_ADDRESS,"" and ""HAS_SHIPPING_ADDRESS"" relationships in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the difference between the ""HAS_ADDRESS,"" ""HAS_BILLING_ADDRESS,"" and ""HAS_SHIPPING_ADDRESS"" relationships in the graph?'  "
C002300022	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	orderNumber: identificador de la comanda. date: data de la comanda. A més, en aquest cas, s’ha decidit definir una restricció d'unicitat a la propietat orderNumber, per tant, no es permetran dues propietats d’orderNumber amb el mateix valor en diferents nodes de tipus order. El client que ha realitzat la comanda ha estat definit per un node c1 de tipus Customer. Per indicar el fet que c1 és el client que va realitzar la comanda, s’ha creat una relació anomenada BELONGS_TO entre els nodes o1 i c1. De la mateixa manera, s’ha creat un node per a les dades de pagament anomenat pa1 de tipus Payment i una relació per indicar que aquestes dades de pagament estan relacionades amb la comanda o1, REFERS_TO. Tingueu en compte que la nomenclatura utilitzada per a les etiquetes dels nodes i les relacions són Pel que fa a les línies de comanda, s’ha optat per crear la relació INCLUDES, que inclou com a atributs units i totalPrice, els quals corresponen al vincle del producte inclòs en la comanda. Els productes han estat definits per un nou tipus de node anomenat Product. En concret, s’han definit dos nodes d’aquest tipus: p1 i p2. Els nodes de tipus Product inclouen dues propietats: el seu nom, name, i el valor de venda al públic recomanat, manufacturer’s suggested retail price o msrp. Atès que, inicialment, es volen incloure les adreces utilitzades pels clients corresponents a les dades de pagament i al lliurament de la comanda, s’ha decidit crear el node adr1 de tipus Address i les relacions HAS_ADDRESS, HAS_BILLING_ADDRESS i HAS_SHIPPING_ADDRESS, respectivament. En aquest exemple, per facilitar les coses, s’ha creat una versió simplificada del possible graf resultant, i s'ha ignorat alguns nodes i propietats que es podrien haver afegit. Encara que incomplet, el nombre de nodes i relacions creades en l’exemple és alt. En un cas real, el nombre d’elements del graf creix ràpida-	C00230002210	In what ways could this graph be expanded or modified to better suit a real-world scenario?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'In what ways could this graph be expanded or modified to better suit a real-world scenario?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002301	What is the purpose of creating a graph in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the purpose of creating a graph in Neo4j?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002302	"Which node represents the product ""bagpack""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'Which node represents the product ""bagpack""?'  "
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002303	"How many units of the product ""folder"" are included in Order 10001?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How many units of the product ""folder"" are included in Order 10001?'  "
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002304	What is the address of Customer Jordi?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the address of Customer Jordi?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002305	What is the type of payment used in Order 10001?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the type of payment used in Order 10001?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002306	How much is the total price of all products in Order 10001?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'How much is the total price of all products in Order 10001?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002307	"Which relationship connects Product ""bagpack"" to Order 10001?"	"passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'Which relationship connects Product ""bagpack"" to Order 10001?'  "
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002308	What is the name of the customer who placed Order 10001?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the name of the customer who placed Order 10001?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002309	Where is the shipping address of Order 10001 located?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'Where is the shipping address of Order 10001 located?'  
C002300023	Introduccio a Neo4j	2.1. Disseny del graf	synthetic_question	"ment. Per aquest motiu, caldrà fer un bon disseny del graf per identificar quins conceptes han de ser representats per nodes, quins per relacions i quins per propietats. També és important fer una bona gestió dels índexs per optimitzar la consulta de les dades. La següent sentència permet crear el graf descrit anteriorment: CREATE (p1:Product { name: ""bagpack"", msrp:35}), (p2:Product { name: ""folder"", msrp:3, description: ""Folder with a picture of a milk bottle.""}), (o1:Order { orderNumber:10001, date:""2020/09/11"" }), (c1:Customer { customerName:""Jordi""}), (adr1:Address{ street:""c. Sant Marti 4"", city:""Girona"", zipCode:""17001"", country:""Spain""}), (pa1:Payment{ paymentType:""XX"", creditCardNumber:""1""}), (p1)<-[r1:INCLUDES{units: 1, totalPrice:25}]-(o1), (p2)<-[r2:INCLUDES{units: 10, totalPrice:30}]-(o1), (o1)-[r3:BELONGS_TO]->(c1), (c1)-[r4:HAS_ADDRESS]->(adr1), (o1)-[r5:HAS_SHIPPING_ADDRESS]->(adr1), (pa1)-[r6:HAS_BILLING_ADDRESS]->(adr1), (pa1)<-[r7:REFERS_TO]-(o1); Atès que, en la sentència anterior, tots els nodes estan interconnectats amb altres per relacions, es podria visualitzar el graf creat per la següent consulta genèrica: MATCH (s)-[r]-(n) RETURN s,r,n;"	C00230002310	What is the total number of units purchased in Order 10001?	passage: document 'Introduccio a Neo4j'; paragraph: '2.1. Disseny del graf'; content: 'What is the total number of units purchased in Order 10001?'  
C002300024	Introduccio a Neo4j	MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs	synthetic_question	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	C00230002401	What is the purpose of creating indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs'; content: 'What is the purpose of creating indexes in Neo4j?'  
C002300024	Introduccio a Neo4j	MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs	synthetic_question	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	C00230002402	How do single-property indexes differ from composite indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs'; content: 'How do single-property indexes differ from composite indexes in Neo4j?'  
C002300024	Introduccio a Neo4j	MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs	synthetic_question	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	C00230002403	Can you create an index over multiple properties for a specific tag in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs'; content: 'Can you create an index over multiple properties for a specific tag in Neo4j?'  
C002300024	Introduccio a Neo4j	MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs	synthetic_question	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	C00230002404	What is the syntax for creating a single-property index in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs'; content: 'What is the syntax for creating a single-property index in Neo4j?'  
C002300024	Introduccio a Neo4j	MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs	synthetic_question	Neo4j també incorpora índexs per agilitzar l’accés a les dades a partir del valor de les propietats del graf. En particular, Cypher permet la creació d’índexs en una o més propietats per a tots els nodes que tinguin una determinada etiqueta: • Un índex que es crea en una sola propietat per a una etiqueta determinada s’anomena índex d’una sola propietat (single-property index). • Un índex que es crea en més d’una propietat per a una etiqueta determinada s’anomena índex compost (composite index). Un cop creat un índex, serà administrat i actualitzat automàticament per Neo4j: • Es pot crear uníndexsobreunasolapropietat per a tots els nodes que tinguin una etiqueta, com per exemple: CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName) ;	C00230002405	How does Neo4j automatically maintain and update indices once they are created?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (s)-[r]-(n) RETURN s,r,n;.  Figura 6. Graf resultant de la consulta.  2.2. Índexs'; content: 'How does Neo4j automatically maintain and update indices once they are created?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002501	What is the purpose of creating an index in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'What is the purpose of creating an index in Neo4j?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002502	Which property or properties should be included when creating an index in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Which property or properties should be included when creating an index in Neo4j?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002503	Can multiple indexes be created in Neo4j for different properties?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Can multiple indexes be created in Neo4j for different properties?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002504	How does one create an index in Neo4j using the Cypher language?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'How does one create an index in Neo4j using the Cypher language?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002505	Is it possible to create an index in Neo4j for a specific node type only?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Is it possible to create an index in Neo4j for a specific node type only?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002506	Can an index be dropped or removed in Neo4j if it is no longer needed?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Can an index be dropped or removed in Neo4j if it is no longer needed?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002507	Are there any performance benefits to creating an index in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Are there any performance benefits to creating an index in Neo4j?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002508	Can an index be used to improve the performance of queries in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Can an index be used to improve the performance of queries in Neo4j?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002509	Are there any limitations or restrictions on creating indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'Are there any limitations or restrictions on creating indexes in Neo4j?'  
C002300025	Introduccio a Neo4j	CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);	synthetic_question	Es pot crear un índex compost per múltiples propietats per a tots els nodes que tinguin una etiqueta Address, i que tinguin una propietat de carrer i ciutat. CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	C00230002510	How do indexes in Neo4j differ from indexes in relational databases?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_customer_name FOR (c:Customer)ON (c.customerName);'; content: 'How do indexes in Neo4j differ from indexes in relational databases?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002601	What is the purpose of creating an index in Neo4j according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'What is the purpose of creating an index in Neo4j according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002602	Which statement should be executed to list all indexes in the database, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'Which statement should be executed to list all indexes in the database, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002603	According to the given paragraph, what is the definition of an index in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'According to the given paragraph, what is the definition of an index in Neo4j?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002604	Can nodes without the specified label be added to the indexed property, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'Can nodes without the specified label be added to the indexed property, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002605	How does one specify the properties to include in the index, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'How does one specify the properties to include in the index, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002606	Is it possible to create an index on multiple labels at once, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'Is it possible to create an index on multiple labels at once, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002607	What happens if a node has more than one label, but only one of those labels is included in the index definition, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'What happens if a node has more than one label, but only one of those labels is included in the index definition, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002608	Can an index be created on a relationship property, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'Can an index be created on a relationship property, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002609	How do you determine which properties to include in the index when there are multiple possible choices, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'How do you determine which properties to include in the index when there are multiple possible choices, according to the given paragraph?'  
C002300026	Introduccio a Neo4j	CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);	synthetic_question	Només s’afegiran a l’índex els nodes etiquetats amb l’etiqueta especificada i que continguin totes les propietats de la definició de l’índex. Per obtenir la llista d’índexs cal cridar el procediment integrat db.indexes, el qual llistarà tots els índexs de la base de dades: CALL db.indexes;	C00230002610	Once an index is created, how can you remove it from the database, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE INDEX i_adress FOR (a:Address) ON (a.street, a.city);'; content: 'Once an index is created, how can you remove it from the database, according to the given paragraph?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002701	"What is the purpose of the sentence ""DROP INDEX index_name;"" in Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'What is the purpose of the sentence ""DROP INDEX index_name;"" in Neo4j?'  "
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002702	How do we suppress an index in Neo4j using the given sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'How do we suppress an index in Neo4j using the given sentence?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002703	Can we use the same sentence to drop multiple indexes at once in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Can we use the same sentence to drop multiple indexes at once in Neo4j?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002704	Is there any difference between dropping an index and deleting it permanently in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Is there any difference between dropping an index and deleting it permanently in Neo4j?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002705	"Will executing the sentence ""DROP INDEX index_name;"" affect any other indexes or data in the graph?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Will executing the sentence ""DROP INDEX index_name;"" affect any other indexes or data in the graph?'  "
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002706	How would we create a new index in Neo4j after dropping an existing one using the given sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'How would we create a new index in Neo4j after dropping an existing one using the given sentence?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002707	Are there any best practices or considerations when dropping indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Are there any best practices or considerations when dropping indexes in Neo4j?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002708	"Can we use Cypher queries to drop indexes in Neo4j instead of using the ""DROP INDEX"" statement?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Can we use Cypher queries to drop indexes in Neo4j instead of using the ""DROP INDEX"" statement?'  "
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002709	Does dropping an index in Neo4j affect the performance of the graph or any running queries?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Does dropping an index in Neo4j affect the performance of the graph or any running queries?'  
C002300027	Introduccio a Neo4j	CALL db.indexes;	synthetic_question	Per suprimir un índex, s’utilitzarà la sentència següent: DROP INDEX index_name;	C00230002710	Can we restore dropped indexes in Neo4j if needed?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.indexes;'; content: 'Can we restore dropped indexes in Neo4j if needed?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002801	What is the purpose of creating an index in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'What is the purpose of creating an index in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002802	How do full-text indexes differ from other types of indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'How do full-text indexes differ from other types of indexes in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002803	What is the benefit of using full-text indexes for searching text within an attribute?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'What is the benefit of using full-text indexes for searching text within an attribute?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002804	Can full-text indexes be used to search for specific phrases or sentences within an attribute?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'Can full-text indexes be used to search for specific phrases or sentences within an attribute?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002805	How does the creation of a full-text index affect the performance of searches in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'How does the creation of a full-text index affect the performance of searches in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002806	Are there any limitations to using full-text indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'Are there any limitations to using full-text indexes in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002807	Can full-text indexes be created on both node and relationship properties in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'Can full-text indexes be created on both node and relationship properties in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002808	Is it possible to create multiple full-text indexes on the same property in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'Is it possible to create multiple full-text indexes on the same property in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002809	How does the Apache Lucene library contribute to the functionality of full-text indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'How does the Apache Lucene library contribute to the functionality of full-text indexes in Neo4j?'  
C002300028	Introduccio a Neo4j	DROP INDEX index_name;	synthetic_question	valors. Milloren les cerques quan es realitzen pel valor complet de la propietat (c.name = “Juan” per exemple), per un rang dels valors de la propietat (c.total >10 AND c.total < 100 per exemple), o per prefixos dels seus camps de text (c.name STARTS WITH “Juan”), però no es poden utilitzar quan es busca una determinada porció de text dins d’un atribut (p.description CONTAINS “milk”). En aquests casos, és millor utilitzar índexs de text complet. Els índexsdetextcomplet, full-search indexes, funcionen amb la biblioteca de cerca i indexació d’Apache Lucene, i es poden utilitzar per indexar propietats de nodes i relacions que continguin text. Un índex de text complet extraurà totes les paraules incloses en un atribut i les indexarà una a una. Això permet fer cerques per qualsevol paraula de manera eficient, com podem veure en el següent codi: CREATE FULLTEXT INDEX productDescription FOR (n:Product) ON EACH [n.description]	C00230002810	In which scenarios might it be more appropriate to use full-text indexes instead of other types of indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP INDEX index_name;'; content: 'In which scenarios might it be more appropriate to use full-text indexes instead of other types of indexes in Neo4j?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002901	What type of nodes can be queried using the fulltext query in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'What type of nodes can be queried using the fulltext query in Neo4j?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002902	What is the purpose of the `indexConfig` property in the fulltext query?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'What is the purpose of the `indexConfig` property in the fulltext query?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002903	Which field in the node data is being searched when using the fulltext query?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'Which field in the node data is being searched when using the fulltext query?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002904	"How many times does the word ""milk"" appear in the provided paragraph content?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'How many times does the word ""milk"" appear in the provided paragraph content?'  "
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002905	Can the fulltext query be used to search for multiple fields in the node data?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'Can the fulltext query be used to search for multiple fields in the node data?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002906	Is it possible to use wildcards in the fulltext query to match more general terms?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'Is it possible to use wildcards in the fulltext query to match more general terms?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002907	How do you retrieve the description of a node that matches the fulltext query?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'How do you retrieve the description of a node that matches the fulltext query?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002908	Can you use the fulltext query to search for nodes that have a specific label or relationship?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'Can you use the fulltext query to search for nodes that have a specific label or relationship?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002909	Are there any performance considerations to keep in mind when using the fulltext query in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'Are there any performance considerations to keep in mind when using the fulltext query in Neo4j?'  
C002300029	Introduccio a Neo4j	OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}	synthetic_question	"CALL db. index. fulltext.queryNodes (""productDescription"", ""milk"") YIELD node RETURN node.description; CALL db.index.fulltext.queryNodes(""productDescription"", ""milk"") YIELD node RETURN node.description;"	C00230002910	Can you use the fulltext query to search for nodes across multiple indexes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'OPTIONS {indexConfig: {`fulltext.analyzer`: 'english'}}'; content: 'Can you use the fulltext query to search for nodes across multiple indexes in Neo4j?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003001	What type of restrictions can be applied to ensure data consistency in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'What type of restrictions can be applied to ensure data consistency in Neo4j?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003002	Can unique restriction rules be added to an existing database?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'Can unique restriction rules be added to an existing database?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003003	How do uniqueness restrictions ensure that data is consistent across all nodes with a specific label?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'How do uniqueness restrictions ensure that data is consistent across all nodes with a specific label?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003004	Are there any exceptions to the rule of uniqueness restrictions, such as nodes without certain properties?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'Are there any exceptions to the rule of uniqueness restrictions, such as nodes without certain properties?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003005	Can multiple uniqueness restrictions be created within a single database?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'Can multiple uniqueness restrictions be created within a single database?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003006	Is it possible to apply uniqueness restrictions retrospectively to already existing data in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'Is it possible to apply uniqueness restrictions retrospectively to already existing data in Neo4j?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003007	How does Neo4j enforce uniqueness restrictions once they have been established?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'How does Neo4j enforce uniqueness restrictions once they have been established?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003008	Can uniqueness restrictions be used in combination with other types of constraints, such as relationship restrictions or property restrictions?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'Can uniqueness restrictions be used in combination with other types of constraints, such as relationship restrictions or property restrictions?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003009	Are there any best practices or guidelines for creating and managing uniqueness restrictions in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'Are there any best practices or guidelines for creating and managing uniqueness restrictions in Neo4j?'  
C002300030	Introduccio a Neo4j	2.3. Restriccions	synthetic_question	A Neo4j es poden utilitzar restriccions per assegurar la consistència de les seves dades i que compleixen amb un conjunt de regles de domini. Una possible regla de domini pot ser: «Si un node té una etiqueta de Customer i una propietat o atribut name, llavors el valor de name ha de ser únic entre tots els nodes que tenen l’etiqueta Customer». Es poden afegir restriccions a una base de dades que ja té dades, sempre i quant les dades existents compleixin amb la restricció que es vol crear. • Les restriccions d’unicitat sobre les propietats asseguren que els valors de propietat són únics per a tots els nodes amb una etiqueta específica. Aquest tipus de restriccions no vol dir que tots els nodes tinguin un valor únic per a les propietats; els nodes sense la propietat no estan subjectes a aquesta regla: CREATE CONSTRAINT cUniqueCustomers	C00230003010	How does Neo4j handle conflicts when attempting to create a new node or relationship that violates an existing uniqueness restriction?	passage: document 'Introduccio a Neo4j'; paragraph: '2.3. Restriccions'; content: 'How does Neo4j handle conflicts when attempting to create a new node or relationship that violates an existing uniqueness restriction?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003101	What is the purpose of the `ASSERT` statement in the given Cypher code?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'What is the purpose of the `ASSERT` statement in the given Cypher code?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003102	Which property of the `Customer` node is being asserted as unique in the given Cypher code?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'Which property of the `Customer` node is being asserted as unique in the given Cypher code?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003103	In which database management system is the given Cypher code written?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'In which database management system is the given Cypher code written?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003104	What is the name of the constraint created by the given Cypher code?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'What is the name of the constraint created by the given Cypher code?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003105	How does the `ASSERT` statement ensure data consistency in the graph database?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'How does the `ASSERT` statement ensure data consistency in the graph database?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003106	Can duplicate values exist in the `name` property of the `Customer` node after running the given Cypher code?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'Can duplicate values exist in the `name` property of the `Customer` node after running the given Cypher code?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003107	Is it possible to create multiple constraints like the one specified in the given Cypher code?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'Is it possible to create multiple constraints like the one specified in the given Cypher code?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003108	What happens if a new `Customer` node is added with a duplicate value in the `name` property?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'What happens if a new `Customer` node is added with a duplicate value in the `name` property?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003109	Can the `ASSERT` statement be used to enforce uniqueness on other properties besides `name` in the `Customer` node?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'Can the `ASSERT` statement be used to enforce uniqueness on other properties besides `name` in the `Customer` node?'  
C002300031	Introduccio a Neo4j	CREATE CONSTRAINT cUniqueCustomers	synthetic_question	ON (c:Customer) ASSERT c.name IS UNIQUE;	C00230003110	How would you modify the given Cypher code to enforce uniqueness on both the `name` and `email` properties of the `Customer` node?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT cUniqueCustomers'; content: 'How would you modify the given Cypher code to enforce uniqueness on both the `name` and `email` properties of the `Customer` node?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003201	What is the purpose of the ON clause in a Neo4j database?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'What is the purpose of the ON clause in a Neo4j database?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003202	How does the existence restriction ensure uniqueness of node properties?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'How does the existence restriction ensure uniqueness of node properties?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003203	Can you create new nodes with an specific label without providing data for a certain property?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Can you create new nodes with an specific label without providing data for a certain property?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003204	Will a query that attempts to create a new node with an specific label but without providing data for a certain property succeed or fail?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Will a query that attempts to create a new node with an specific label but without providing data for a certain property succeed or fail?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003205	Are there any restrictions on creating relationships with a specific type?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Are there any restrictions on creating relationships with a specific type?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003206	Can you delete a relationship if it doesn't have a certain property?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Can you delete a relationship if it doesn't have a certain property?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003207	Is it possible to create a new node with an specific label and also define a property for it at the same time?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Is it possible to create a new node with an specific label and also define a property for it at the same time?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003208	How do the existence restrictions ensure that all nodes with a specific label have a unique property?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'How do the existence restrictions ensure that all nodes with a specific label have a unique property?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003209	Can you modify a relationship if it has a certain property?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Can you modify a relationship if it has a certain property?'  
C002300032	Introduccio a Neo4j	ON (c:Customer) ASSERT c.name IS UNIQUE;	synthetic_question	• Les restriccionsd’existènciadepropietatdenode asseguren que hi hagi una propietat per a tots els nodes amb una etiqueta específica. Les restriccionsd’existènciadepropietatderelació asseguren que hi hagi una propietat per a totes les relacions amb un tipus específic. Les consultes que intenten crear nodes nous de l’etiqueta especificada, o el tipus de relació, però que no proveeixin dades per aquesta propietat, fallaran. El mateix passa amb les consultes que proven de suprimir una propietat definida com obligatòria:	C00230003210	Do all nodes with a specific label have to have the same set of properties?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (c:Customer) ASSERT c.name IS UNIQUE;'; content: 'Do all nodes with a specific label have to have the same set of properties?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003301	What is the purpose of the `ASSERT` statement in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'What is the purpose of the `ASSERT` statement in the given Cypher query?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003302	Which property of the `Product` node is being asserted to exist in the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'Which property of the `Product` node is being asserted to exist in the query?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003303	What is the name of the constraint being created in the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'What is the name of the constraint being created in the query?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003304	Can we use the `EXISTS` keyword instead of `ASSERT` in this query?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'Can we use the `EXISTS` keyword instead of `ASSERT` in this query?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003305	According to the query, which nodes can have the `name` property?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'According to the query, which nodes can have the `name` property?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003306	How would we modify the query to ensure that only nodes with a specific type (e.g., `Book`) have the `name` property?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'How would we modify the query to ensure that only nodes with a specific type (e.g., `Book`) have the `name` property?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003307	Is it possible to create a constraint that references another constraint in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'Is it possible to create a constraint that references another constraint in Cypher?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003308	Can we use the `WITH` clause to define multiple constraints at once in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'Can we use the `WITH` clause to define multiple constraints at once in Cypher?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003309	How does the `ASSERT` statement differ from the `REQUIRE` statement in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'How does the `ASSERT` statement differ from the `REQUIRE` statement in Cypher?'  
C002300033	Introduccio a Neo4j	CREATE CONSTRAINT constraint_name2	synthetic_question	ON (p:Product) ASSERT EXISTS (p.name) ;	C00230003310	In what way(s) could we use the `CREATE CONSTRAINT` statement to enforce data integrity in our graph database?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE CONSTRAINT constraint_name2'; content: 'In what way(s) could we use the `CREATE CONSTRAINT` statement to enforce data integrity in our graph database?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003401	What is the purpose of the `ASSERT` statement in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'What is the purpose of the `ASSERT` statement in Cypher?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003402	What type of relationship is specified in the `ON` clause of the `ASSERT` statement?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'What type of relationship is specified in the `ON` clause of the `ASSERT` statement?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003403	What is the name of the constraint being created in the `CREATE CONSTRAINT` statement?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'What is the name of the constraint being created in the `CREATE CONSTRAINT` statement?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003404	What is the purpose of the `EXISTS` keyword in the `ASSERT` statement?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'What is the purpose of the `EXISTS` keyword in the `ASSERT` statement?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003405	How does the `ASSERT` statement ensure data consistency in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'How does the `ASSERT` statement ensure data consistency in Neo4j?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003406	Can you use the `ASSERT` statement to create a new relationship between two nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'Can you use the `ASSERT` statement to create a new relationship between two nodes?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003407	Must the `NAME` property of the ` Product` node be set before using the `ASSERT` statement?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'Must the `NAME` property of the ` Product` node be set before using the `ASSERT` statement?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003408	Can you use the `ASSERT` statement to modify an existing relationship between two nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'Can you use the `ASSERT` statement to modify an existing relationship between two nodes?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003409	Is it possible to use the `ASSERT` statement to remove a relationship between two nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'Is it possible to use the `ASSERT` statement to remove a relationship between two nodes?'  
C002300034	Introduccio a Neo4j	ON (p:Product) ASSERT EXISTS (p.name);	synthetic_question	CREATE CONSTRAINT constraint_name3	C00230003410	What happens if the `ASSERT` statement encounters a non-existent relationship between two nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (p:Product) ASSERT EXISTS (p.name);'; content: 'What happens if the `ASSERT` statement encounters a non-existent relationship between two nodes?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003501	What is the purpose of the ON ()-[i:INCLUDES]->() ASSERT clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'What is the purpose of the ON ()-[i:INCLUDES]->() ASSERT clause in Neo4j?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003502	According to the given paragraph, what type of restrictions does the INCLUDES relationship have?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'According to the given paragraph, what type of restrictions does the INCLUDES relationship have?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003503	Can you identify the specific property or properties that must be unique according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'Can you identify the specific property or properties that must be unique according to the given paragraph?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003504	How does the ASSERT clause ensure data integrity in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'How does the ASSERT clause ensure data integrity in Neo4j?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003505	In which situations might it be useful to use the ON ()-[i:INCLUDES]->() ASSERT clause in a graph database like Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'In which situations might it be useful to use the ON ()-[i:INCLUDES]->() ASSERT clause in a graph database like Neo4j?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003506	What is the difference between an INCLUDES relationship and another type of relationship in Neo4j (e.g., RELATED TO)?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'What is the difference between an INCLUDES relationship and another type of relationship in Neo4j (e.g., RELATED TO)?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003507	How do the constraints defined using the ASSERT clause differ from those defined using other Neo4j syntax elements (e.g., indexes, labels)?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'How do the constraints defined using the ASSERT clause differ from those defined using other Neo4j syntax elements (e.g., indexes, labels)?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003508	Can you explain how the ON ()-[i:INCLUDES]->() ASSERT clause works when there are multiple relationships between two nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'Can you explain how the ON ()-[i:INCLUDES]->() ASSERT clause works when there are multiple relationships between two nodes?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003509	Are there any potential drawbacks or limitations to using the ON ()-[i:INCLUDES]->() ASSERT clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'Are there any potential drawbacks or limitations to using the ON ()-[i:INCLUDES]->() ASSERT clause in Neo4j?'  
C002300035	Introduccio a Neo4j	ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;	synthetic_question	Les restriccionsd’integritatd’unicitat o claudenode garanteixen que el conjunt de valors establerts en les propietats d’un node d’un tipus donat sigui únic: CREATE CONSTRAINT constraint_name4	C00230003510	How might one go about optimizing the performance of queries that make use of the ON ()-[i:INCLUDES]->() ASSERT clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON ()-[i:INCLUDES]->() ASSERT i.totalPrice IS NOT NULL;'; content: 'How might one go about optimizing the performance of queries that make use of the ON ()-[i:INCLUDES]->() ASSERT clause in Neo4j?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003601	What is the purpose of the ON clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'What is the purpose of the ON clause in the given Cypher query?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003602	What type of relationship is defined between the two nodes in the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'What type of relationship is defined between the two nodes in the query?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003603	How is the order number unique for each node in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'How is the order number unique for each node in the graph?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003604	Can multiple nodes have the same order number in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'Can multiple nodes have the same order number in the graph?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003605	What is the effect of using the DROP CONSTRAINT statement in the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'What is the effect of using the DROP CONSTRAINT statement in the query?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003606	Is it possible to drop a constraint that does not exist in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'Is it possible to drop a constraint that does not exist in the graph?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003607	How would you modify the query to remove all constraints with a specific name?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'How would you modify the query to remove all constraints with a specific name?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003608	Can you use the DROP CONSTRAINT statement without specifying a constraint name?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'Can you use the DROP CONSTRAINT statement without specifying a constraint name?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003609	Will the query produce an error if there are no constraints to drop?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'Will the query produce an error if there are no constraints to drop?'  
C002300036	Introduccio a Neo4j	ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;	synthetic_question	Per suprimir una restricció: DROP CONSTRAINT constraint_namel	C00230003610	What is the difference between the DROP CONSTRAINT statement and the DELETE statement in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'ON (o:Order) ASSERT (o.orderNumber) IS NODE KEY;'; content: 'What is the difference between the DROP CONSTRAINT statement and the DELETE statement in Cypher?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003701	What is the purpose of the DROP CONSTRAINT statement in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'What is the purpose of the DROP CONSTRAINT statement in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003702	What type of constraints can be dropped using the DROP CONSTRAINT statement in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'What type of constraints can be dropped using the DROP CONSTRAINT statement in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003703	How do you check which constraints have been created in a Neo4j database?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'How do you check which constraints have been created in a Neo4j database?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003704	What is the result of calling the CALL db.constraints procedure in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'What is the result of calling the CALL db.constraints procedure in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003705	Can you drop a constraint if it has already been used in a query or transaction in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'Can you drop a constraint if it has already been used in a query or transaction in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003706	If a constraint has been dropped accidentally, how can you restore it in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'If a constraint has been dropped accidentally, how can you restore it in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003707	Are there any limitations on the number of constraints that can be created in a Neo4j database?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'Are there any limitations on the number of constraints that can be created in a Neo4j database?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003708	Can you create a constraint with a name that is not unique in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'Can you create a constraint with a name that is not unique in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003709	How does the DROP CONSTRAINT statement affect other queries or transactions running in the same session in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'How does the DROP CONSTRAINT statement affect other queries or transactions running in the same session in Neo4j?'  
C002300037	Introduccio a Neo4j	DROP CONSTRAINT constraint_name1	synthetic_question	Per conèixer les restriccions creades: CALL db.constraints	C00230003710	Is it possible to drop all constraints at once in Neo4j using a single command?	passage: document 'Introduccio a Neo4j'; paragraph: 'DROP CONSTRAINT constraint_name1'; content: 'Is it possible to drop all constraints at once in Neo4j using a single command?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003801	What edition of Neo4j is required to use certain types of constraints?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'What edition of Neo4j is required to use certain types of constraints?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003802	What are the three types of constraints available in Neo4j Enterprise Edition?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'What are the three types of constraints available in Neo4j Enterprise Edition?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003803	What happens to the indexes when a restriction is added or removed in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'What happens to the indexes when a restriction is added or removed in Neo4j?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003804	Can multiple restrictions be added to the same property in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'Can multiple restrictions be added to the same property in Neo4j?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003805	Is it possible to create an index explicitly if one is removed accidentally in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'Is it possible to create an index explicitly if one is removed accidentally in Neo4j?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003806	How does Neo4j handle searches when certain restrictions are added or removed?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'How does Neo4j handle searches when certain restrictions are added or removed?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003807	What is the best practice for naming restrictions in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'What is the best practice for naming restrictions in Neo4j?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003808	Will creating a restriction trigger an atomic operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'Will creating a restriction trigger an atomic operation in Neo4j?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003809	Can the same restriction be created twice in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'Can the same restriction be created twice in Neo4j?'  
C002300038	Introduccio a Neo4j	CALL db.constraints	synthetic_question	Les restriccions de clau de node, les restriccions d’existència de propietat de node i les restriccions d’existència de propietat de relació només estan disponibles a Neo4j Enterprise Edition. Les bases de dades que contenen un d’aquests tipus de restriccions no es poden obrir amb Neo4j Community Edition. La creació d’una restricció té les següents implicacions per als índexs: • Afegir una restricció de propietat única en una propietat també afegeix un índex únic sobre aquesta propietat. • Afegir una restricció de clau de node per a un conjunt de propietats també afegeix un índex compost sobre aquestes propietats. • Neo4j utilitzarà aquests índexs per a les cerques, com altres índexs. • Si s’elimina una restricció d’unicitat sobre una propietat o una restricció de clau de node, se suprimirà l’índex associat. Si l’índex encara és necessari, s’haurà de crear explícitament. A més, també és cert per a les restriccions: • Una etiqueta determinada pot tenir múltiples restriccions. • Afegir restriccions és una operació atòmica que pot trigar temps: totes les dades existents han de ser avaluades abans que Neo4j pugui activar la restricció. • La millor pràctica és donar un nom a la restricció quan es crea. Si la restricció no s’anomena explícitament, Neo4j generarà un nom automàticament. El nom de la restricció ha de ser únic entre els índexs i les restriccions. La creació de restriccions no és idempotent per defecte i es generarà un error si s’intenta crear la mateixa restricció dues vegades. L’ús de la paraula clau IF NOT EXIST fa que el comandament sigui idempotent i no generarà cap error si prova de crear la mateixa restricció dues vegades.	C00230003810	How can you ensure that a restriction is not created twice accidentally in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'CALL db.constraints'; content: 'How can you ensure that a restriction is not created twice accidentally in Neo4j?'  
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003901	"What is the main topic discussed in the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'What is the main topic discussed in the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003902	"According to the third paragraph of the document ""Introduccio a Neo4j,"" what language does Neo4j support?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'According to the third paragraph of the document ""Introduccio a Neo4j,"" what language does Neo4j support?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003903	"Can you list some of the operations that can be performed using Cypher, as mentioned in the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'Can you list some of the operations that can be performed using Cypher, as mentioned in the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003904	"Where can one find more information about the syntax and features of Cypher, according to the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'Where can one find more information about the syntax and features of Cypher, according to the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003905	"In which language is the Neo4j documentation available, as stated in the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'In which language is the Neo4j documentation available, as stated in the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003906	"What is the purpose of the Neo4j Cypher Refcard, as mentioned in the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'What is the purpose of the Neo4j Cypher Refcard, as mentioned in the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003907	"How does Cypher allow developers to interact with the graph data stored in Neo4j, as described in the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'How does Cypher allow developers to interact with the graph data stored in Neo4j, as described in the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003908	"What is the focus of the third paragraph of the document ""Introduccio a Neo4j"" when discussing Cypher?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'What is the focus of the third paragraph of the document ""Introduccio a Neo4j"" when discussing Cypher?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003909	"Why is it recommended to download the Neo4j Cypher Refcard, according to the third paragraph of the document ""Introduccio a Neo4j""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'Why is it recommended to download the Neo4j Cypher Refcard, according to the third paragraph of the document ""Introduccio a Neo4j""?'  "
C002300039	Introduccio a Neo4j	3. Operacions CRUD	synthetic_question	Tot i que es pot accedir a Neo4j utilitzant diferents llenguatges, aquests materials se centraran en el seu accés a través del llenguatge Cypher. A continuació, es presentaran algunes de les seves operacions de creació (C), lectura (R), actualització (U) i esborrat de dades (D). Per treballar amb Cypher és recomanable descarregar la Neo4j Cypher Refcard, que es troba a la pàgina de documentació de Neo4j.9 La sintaxi de Cypher és complexa i permet moltes possibilitats, per la qual cosa es farà un recorregut introductori de les seves principals característiques.	C00230003910	"What is the main message conveyed in the third paragraph of the document ""Introduccio a Neo4j"" regarding the use of Cypher to interact with Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3. Operacions CRUD'; content: 'What is the main message conveyed in the third paragraph of the document ""Introduccio a Neo4j"" regarding the use of Cypher to interact with Neo4j?'  "
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004001	What is the main purpose of using Cypher to query data in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'What is the main purpose of using Cypher to query data in Neo4j?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004002	How do you define a pattern in Cypher to identify elements of interest in a graph?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'How do you define a pattern in Cypher to identify elements of interest in a graph?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004003	Can you use multiple patterns in a single Cypher query to retrieve different types of data?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'Can you use multiple patterns in a single Cypher query to retrieve different types of data?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004004	What is the function of the MATCH clause in Cypher, and how does it relate to the RETURN clause?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'What is the function of the MATCH clause in Cypher, and how does it relate to the RETURN clause?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004005	How do you specify the starting point for a query using the MATCH clause?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'How do you specify the starting point for a query using the MATCH clause?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004006	Can you use wildcards in Cypher queries to match multiple values or patterns?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'Can you use wildcards in Cypher queries to match multiple values or patterns?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004007	How do you return specific fields or properties from matched nodes and relationships in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'How do you return specific fields or properties from matched nodes and relationships in Cypher?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004008	Is it possible to filter the results of a Cypher query based on specific criteria or conditions?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'Is it possible to filter the results of a Cypher query based on specific criteria or conditions?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004009	Can you use aggregation functions in Cypher to group and summarize data before returning it?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'Can you use aggregation functions in Cypher to group and summarize data before returning it?'  
C002300040	Introduccio a Neo4j	3.1. Operacions de lectura	synthetic_question	Es començarà per veure com consultar dades amb Cypher. Les consultes es fan utilitzant la instrucció MATCH... RETURN. La clàusula MATCH permet definir un patró que identifica els elements del graf en els quals es té interès. La clàusula RETURN permet indicar quins dels elements de la clàusula MATCH haurà de retornar la consulta. Els patrons que es definiran a la clàusula MATCH comencen en un o més nodes. Des d’un node inicial, es pot definir el patró (o els patrons) que han de seguir les dades a retornar. Aquests patrons poden contenir (entre altres) nodes, relacions i etiquetes. A continuació, es mostra els seu funcionament mitjançant alguns exemples.	C00230004010	Are there any limitations or constraints on the complexity of Cypher queries that can be executed in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1. Operacions de lectura'; content: 'Are there any limitations or constraints on the complexity of Cypher queries that can be executed in Neo4j?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004101	What is the purpose of the first query in the introduction to Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'What is the purpose of the first query in the introduction to Neo4j?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004102	How does the first query retrieve all nodes in the database?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'How does the first query retrieve all nodes in the database?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004103	What is the pattern used in the first query to simulate round brackets?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'What is the pattern used in the first query to simulate round brackets?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004104	Why do we use parentheses in the first query?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'Why do we use parentheses in the first query?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004105	What is the result of running the first query without any restrictions?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'What is the result of running the first query without any restrictions?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004106	How many nodes are returned when running the first query without any restrictions?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'How many nodes are returned when running the first query without any restrictions?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004107	Can we use the first query to retrieve specific nodes based on their properties or relationships?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'Can we use the first query to retrieve specific nodes based on their properties or relationships?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004108	If so, how would we modify the first query to retrieve specific nodes?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'If so, how would we modify the first query to retrieve specific nodes?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004109	Are there any limitations or constraints that apply to the first query?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'Are there any limitations or constraints that apply to the first query?'  
C002300041	Introduccio a Neo4j	3.1.1. Consultar nodes de la base de dades	synthetic_question	La primera consulta retorna tots els nodes de la base de dades. En aquesta consulta el patró és n, on n és un node. Per indicar que n és un node es posa entre parèntesis (n), tot simulant les rodones que s’utilitzen per «pintar» nodes. Per tant, el patró seria «tots els nodes». Atès que no hi ha més elements en el patró MATCH no s’apliquen restriccions i, en conseqüència, s’identifiquen tots els nodes de la base de dades. La clàusula RETURN n indica que la consulta ha de retornar els nodes n que satisfacin la consulta. Tingueu en compte que el nom de variable utilitzat en el patró (n) és el que s’utilitza a la clàusula RETURN per identificar que els valors a retornar són els associats al patró indicat a la	C00230004110	How does the first query differ from other queries in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.1. Consultar nodes de la base de dades'; content: 'How does the first query differ from other queries in Neo4j?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004201	What is the purpose of the MATCH clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'What is the purpose of the MATCH clause in the given Cypher query?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004202	Which type of nodes are selected by the query according to the given paragraph content?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'Which type of nodes are selected by the query according to the given paragraph content?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004203	How does the query select the specified nodes according to the given paragraph content?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'How does the query select the specified nodes according to the given paragraph content?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004204	What is the meaning of the etiqueta tag in the given paragraph content?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'What is the meaning of the etiqueta tag in the given paragraph content?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004205	Can you explain the difference between a node and an etiqueta in the context of the given paragraph content?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'Can you explain the difference between a node and an etiqueta in the context of the given paragraph content?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004206	According to the given paragraph content, what is the result of executing the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'According to the given paragraph content, what is the result of executing the given Cypher query?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004207	Why do we need to specify the return statement in the given Cypher query according to the given paragraph content?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'Why do we need to specify the return statement in the given Cypher query according to the given paragraph content?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004208	In which situation might the given Cypher query be useful according to the given paragraph content?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'In which situation might the given Cypher query be useful according to the given paragraph content?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004209	How does the use of the MATCH clause affect the performance of the given Cypher query compared to using a different clause such as FOREACH or WHERE?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'How does the use of the MATCH clause affect the performance of the given Cypher query compared to using a different clause such as FOREACH or WHERE?'  
C002300042	Introduccio a Neo4j	MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.	synthetic_question	A la consulta següent, se selecciona el conjunt de nodes de tipus Product (quan es posa node: etiqueta, s’indica que es vol seleccionar els nodes etiquetats amb etiqueta). En conseqüència, la consulta seleccionaria tots els nodes que representen productes, és a dir, etiquetats amb l’etiqueta Product. En realitzar un RETURN p la consulta retornarà tots els nodes seleccionats, els productes: MATCH (p:Product) RETURN p;	C00230004210	Can you think of a scenario where the given Cypher query could be modified to retrieve additional information about the selected nodes beyond their labels?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) RETURN n;.  (9)<https://neo4j.com/docs/>.'; content: 'Can you think of a scenario where the given Cypher query could be modified to retrieve additional information about the selected nodes beyond their labels?'  
C002300043	Introduccio a Neo4j	MATCH (p:Product) RETURN p;	synthetic_question	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	C00230004301	What is the purpose of the second query in the given code snippet?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p;'; content: 'What is the purpose of the second query in the given code snippet?'  
C002300043	Introduccio a Neo4j	MATCH (p:Product) RETURN p;	synthetic_question	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	C00230004302	According to the code snippet, what property do the nodes of type Product have?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p;'; content: 'According to the code snippet, what property do the nodes of type Product have?'  
C002300043	Introduccio a Neo4j	MATCH (p:Product) RETURN p;	synthetic_question	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	C00230004303	How does the second query differ from the first one in terms of the returned values?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p;'; content: 'How does the second query differ from the first one in terms of the returned values?'  
C002300043	Introduccio a Neo4j	MATCH (p:Product) RETURN p;	synthetic_question	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	C00230004304	Can we use this query to retrieve the names of all products in the database?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p;'; content: 'Can we use this query to retrieve the names of all products in the database?'  
C002300043	Introduccio a Neo4j	MATCH (p:Product) RETURN p;	synthetic_question	La següent consulta és semblant a l’anterior, però en aquest cas no es retornen els nodes dels productes, sinó el valor de la seva propietat name Per tant, aquesta consulta retornarà els noms dels productes de la base de dades: MATCH (p:Product) RETURN p.name;	C00230004305	If we want to retrieve the names of only certain products, how could we modify the query to achieve this?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p;'; content: 'If we want to retrieve the names of only certain products, how could we modify the query to achieve this?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004401	What is the purpose of the MATCH clause in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'What is the purpose of the MATCH clause in Cypher?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004402	How do we indicate relationships between nodes in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'How do we indicate relationships between nodes in Cypher?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004403	Can you explain the difference between a directed relationship (-) and an undirected relationship (+)?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'Can you explain the difference between a directed relationship (-) and an undirected relationship (+)?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004404	In the example query, what does the pattern (a)-->(b) represent?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'In the example query, what does the pattern (a)-->(b) represent?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004405	Why would we use the LIMIT 100 clause in this query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'Why would we use the LIMIT 100 clause in this query?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004406	What type of data can we retrieve using the RETURN keyword in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'What type of data can we retrieve using the RETURN keyword in Cypher?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004407	Can you describe the difference between a node and a relationship in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'Can you describe the difference between a node and a relationship in Cypher?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004408	How do we specify the direction of a relationship in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'How do we specify the direction of a relationship in Cypher?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004409	What is the purpose of the parentheses in the query example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'What is the purpose of the parentheses in the query example?'  
C002300044	Introduccio a Neo4j	MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes	synthetic_question	Les relacions es poden indicar a Cypher si s'afegeixen els caràcters -entre dos nodes. A més, es pot afegir un signe < o > als extrems de la relació per indicar la seva direcció. En conseqüència, si hi ha un patró de la classe (a)--(b), Neo4j l’interpreta com a «seleccionar tots els nodes a i b que estan relacionats»; si el patró és de la classe (a)-->(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va d’a a b»; finalment, si el patró és de la classe (a)<--(b), l'interpreta com a «seleccionar tots els nodes a i b que estan relacionats per una relació (o més) que va de b a a». En el següent cas, se seleccionarà el conjunt de parelles <p, other> tal que p sigui de tipus producte, other sigui de qualsevol tipus i hi hagi almenys una relació que vagi de p a other. Finalment, es retornaran (com es pot veure a la clàusula RETURN) els nodes p i other que compleixin el patró indicat. En aquest cas, el sistema no només mostraria els nodes, sinó també les relacions entre ells. La clàusula LIMIT 100 limita el nombre de resultats que retorna una consulta. En els casos en què la consulta pot retornar un gran nombre de re- MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	C00230004410	Can you explain how the query would return only the first 100 results if there were more than 100 matches?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) RETURN p.name;.  3.1.2. Afegir relacions a les consultes'; content: 'Can you explain how the query would return only the first 100 results if there were more than 100 matches?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004501	What is the purpose of the MATCH clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'What is the purpose of the MATCH clause in the given Cypher query?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004502	What type of relationship is being searched for in the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'What type of relationship is being searched for in the query?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004503	Why do the relationships not return any results when executed?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'Why do the relationships not return any results when executed?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004504	How would you modify the query to retrieve the related nodes instead of just the starting nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'How would you modify the query to retrieve the related nodes instead of just the starting nodes?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004505	Can you explain the difference between using `-->` and `<--` in Cypher queries?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'Can you explain the difference between using `-->` and `<--` in Cypher queries?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004506	In what way does the direction of the relationship affect the query's outcome?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'In what way does the direction of the relationship affect the query's outcome?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004507	How might this knowledge be applied to other Cypher queries involving different types of relationships?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'How might this knowledge be applied to other Cypher queries involving different types of relationships?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004508	Is there anything specific about the `MATCH (p:Product)` part of the query that we should note?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'Is there anything specific about the `MATCH (p:Product)` part of the query that we should note?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004509	If we wanted to retrieve all nodes of a certain type (e.g., only products), how could we modify the query to achieve this?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'If we wanted to retrieve all nodes of a certain type (e.g., only products), how could we modify the query to achieve this?'  
C002300045	Introduccio a Neo4j	MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;	synthetic_question	Si executeu la consulta a la base de dades, podeu verificar que no es retorna cap node. Això es deu al fet que les relacions en què participen els nodes de tipus Product no són de sortida, sinó d’entrada. En el patró de la consulta es demanen els nodes de sortida (usant el símbol -->), de manera que no es retornen resultats. Si torneu a executar la consulta canviant la direcció de la relació, el resultat serà l’esperat: MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	C00230004510	What if we wanted to retrieve all nodes regardless of their type; how would we modify the query to accomplish this?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)-->(other) RETURN p,other LIMIT 100;'; content: 'What if we wanted to retrieve all nodes regardless of their type; how would we modify the query to accomplish this?'  
C002300046	Introduccio a Neo4j	MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	synthetic_question	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	C00230004601	What is the purpose of the second query in the given code snippet?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'; content: 'What is the purpose of the second query in the given code snippet?'  
C002300046	Introduccio a Neo4j	MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	synthetic_question	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	C00230004602	According to the code snippet, what type of data can be retrieved using the first query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'; content: 'According to the code snippet, what type of data can be retrieved using the first query?'  
C002300046	Introduccio a Neo4j	MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	synthetic_question	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	C00230004603	How many results can be returned using the first query, according to the code snippet?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'; content: 'How many results can be returned using the first query, according to the code snippet?'  
C002300046	Introduccio a Neo4j	MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	synthetic_question	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	C00230004604	What is the difference between the two queries in the code snippet, in terms of their functionality?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'; content: 'What is the difference between the two queries in the code snippet, in terms of their functionality?'  
C002300046	Introduccio a Neo4j	MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;	synthetic_question	La següent consulta permet preguntar per dades relacionades, però sense tenir en compte l’adreça de les relacions “--”. En aquest cas, el gestor de la base de dades retornarà la unió dels resultats de les dues consultes anteriors: MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	C00230004605	Can the first query retrieve data related to multiple products at once, based on the given code snippet?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)<--(other) RETURN p,other LIMIT 100;'; content: 'Can the first query retrieve data related to multiple products at once, based on the given code snippet?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004701	What is the purpose of the MATCH clause in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'What is the purpose of the MATCH clause in Cypher?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004702	How does the MATCH clause allow filtering data in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'How does the MATCH clause allow filtering data in Cypher?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004703	What type of relationships can be filtered using the MATCH clause in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'What type of relationships can be filtered using the MATCH clause in Cypher?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004704	Can you explain the difference between a variable defined within brackets [] in a Cypher query versus one defined outside of brackets?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'Can you explain the difference between a variable defined within brackets [] in a Cypher query versus one defined outside of brackets?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004705	In what way do the etiquettes associated with a relationship affect the data returned in a Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'In what way do the etiquettes associated with a relationship affect the data returned in a Cypher query?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004706	"How would you modify the previous example query to only return orders that include at least one product from the category ""Electronics""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'How would you modify the previous example query to only return orders that include at least one product from the category ""Electronics""?'  "
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004707	If you wanted to retrieve all products included in an order, but not the order itself, how would you write the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'If you wanted to retrieve all products included in an order, but not the order itself, how would you write the query?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004708	Can you use the MATCH clause to filter data based on multiple relationship types in a single query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'Can you use the MATCH clause to filter data based on multiple relationship types in a single query?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004709	How might you use the MATCH clause in combination with the WITH clause to perform calculations or aggregations on the data retrieved in a query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'How might you use the MATCH clause in combination with the WITH clause to perform calculations or aggregations on the data retrieved in a query?'  
C002300047	Introduccio a Neo4j	MATCH (p:Product)--(other) RETURN p,other LIMIT 100;	synthetic_question	De vegades, també pot ser interessant retornar les dades emmagatzemades en les propietats de les relacions o aplicar-hi filtres. A la clàusula MATCH, per a cada relació es pot definir: una variable que l’identifiqui i permeti l’accés a les seves dades, i un o més tipus (etiquetes associades). Ambdós elements s’hauran de definir entre claudàtors [] entre el primer i el segon guió de la relació. A la consulta següent podeu veure un exemple en què s’utilitza el tipus de relacions del graf per filtrar les dades retornades. En aquest cas, la consulta anterior es restringeix per seleccionar només les relacions del tipus INCLUDES. Per tant, d’acord amb aquest nou patró, la consulta seleccionarà el conjunt de tripletes del tipus <p, i, o>, on o és un node de tipus Order, p és un node de tipus Product, i i és la relació de tipus INCLUDES que relaciona la comanda o i el producte p. Aquesta consulta retornarà, per a cada comanda, el seu número, el nom dels productes inclosos i la quantitat de cada producte: MATCH (p:Product)<-[i:INCLUDES]-(o:Order)	C00230004710	Is it possible to use the MATCH clause to retrieve data from more than one graph simultaneously in a single Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product)--(other) RETURN p,other LIMIT 100;'; content: 'Is it possible to use the MATCH clause to retrieve data from more than one graph simultaneously in a single Cypher query?'  
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004801	"What is the purpose of the ""WHERE"" clause in Cypher?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'What is the purpose of the ""WHERE"" clause in Cypher?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004802	How do you apply filters to queries in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'How do you apply filters to queries in Cypher?'  
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004803	"What is an example of using the ""WHERE"" clause in a Cypher query?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'What is an example of using the ""WHERE"" clause in a Cypher query?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004804	"Can you give an example of a query that uses the ""WHERE"" clause to filter results based on a specific property value?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'Can you give an example of a query that uses the ""WHERE"" clause to filter results based on a specific property value?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004805	Is it guaranteed that all nodes returned in a Cypher query will have a specific type?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'Is it guaranteed that all nodes returned in a Cypher query will have a specific type?'  
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004806	"What is the difference between a ""MATCH"" statement and a ""WHERE"" clause in Cypher?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'What is the difference between a ""MATCH"" statement and a ""WHERE"" clause in Cypher?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004807	"In what situation might you need to use the ""WHERE"" clause in a Cypher query?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'In what situation might you need to use the ""WHERE"" clause in a Cypher query?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004808	"Can you provide an example of a more complex query that uses multiple ""WHERE"" clauses to filter results?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'Can you provide an example of a more complex query that uses multiple ""WHERE"" clauses to filter results?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004809	"How does the ""WHERE"" clause affect the performance of a Cypher query?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'How does the ""WHERE"" clause affect the performance of a Cypher query?'  "
C002300048	Introduccio a Neo4j	RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes	synthetic_question	"Fins ara s’ha detallat com consultar les dades d’un graf que indica quin és el patró del resultat esperat, és a dir, com es relacionen les dades i quins tipus han de tenir. Ara es veurà com aplicar filtres a les consultes per retornar només aquelles dades que compleixin determinades condicions. Com a SQL, a Cypher podeu definir una clàusula WHERE per seleccionar les dades d’interès. A la clàusula WHERE es pot indicar un conjunt de condicions que les dades hauran de satisfer. Es pot veure un exemple de l’ús d’aquesta clàusula a la primera consulta, que retorna tots els nodes que tenen una propietat amb nom name i el valor del qual és ‘bagpack’. Tingueu en compte que, atès que es tracta d'un tipus schemaless, a Neo4j no es té cap garantia que tots els nodes retornats siguin de tipus producte. Podria donar-se el cas que una persona tingués una propietat amb nom name i valor ‘bagpack’. Aquí, el gestor de la base de dades també retornarà aquest últim element: MATCH (n) WHERE n.name=""bagpack"";"	C00230004810	"Are there any best practices or considerations to keep in mind when using the ""WHERE"" clause in Cypher?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN o.orderNumber, p.name, i.units;.  3.1.3. Afegir condicions per filtrar els resultats de les consultes'; content: 'Are there any best practices or considerations to keep in mind when using the ""WHERE"" clause in Cypher?'  "
C002300049	Introduccio a Neo4j	"MATCH (n) WHERE n.name=""bagpack"";"	synthetic_question	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	C00230004901	What is the purpose of the modified query in the given paragraph?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) WHERE n.name=""bagpack"";'; content: 'What is the purpose of the modified query in the given paragraph?'  "
C002300049	Introduccio a Neo4j	"MATCH (n) WHERE n.name=""bagpack"";"	synthetic_question	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	C00230004902	According to the paragraph, what type of node should the modified query return?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) WHERE n.name=""bagpack"";'; content: 'According to the paragraph, what type of node should the modified query return?'  "
C002300049	Introduccio a Neo4j	"MATCH (n) WHERE n.name=""bagpack"";"	synthetic_question	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	C00230004903	How does the modified query differ from the original query mentioned in the paragraph?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) WHERE n.name=""bagpack"";'; content: 'How does the modified query differ from the original query mentioned in the paragraph?'  "
C002300049	Introduccio a Neo4j	"MATCH (n) WHERE n.name=""bagpack"";"	synthetic_question	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	C00230004904	What is the name of the product being searched for in the modified query?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) WHERE n.name=""bagpack"";'; content: 'What is the name of the product being searched for in the modified query?'  "
C002300049	Introduccio a Neo4j	"MATCH (n) WHERE n.name=""bagpack"";"	synthetic_question	"A continuació, es modifica la consulta per assegurar que el resultat és del tipus Product: MATCH (p:Product) WHERE p.name=""bagpack"";"	C00230004905	Based on the paragraph, how many nodes will the modified query return if there are no matching products?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (n) WHERE n.name=""bagpack"";'; content: 'Based on the paragraph, how many nodes will the modified query return if there are no matching products?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005001	What is the purpose of the second query mentioned in the paragraph?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'What is the purpose of the second query mentioned in the paragraph?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005002	What type of relationship is indicated between the Customer and Order nodes in the second query?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'What type of relationship is indicated between the Customer and Order nodes in the second query?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005003	How does the second query differ from the first query in terms of the condition specified for the Product node?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'How does the second query differ from the first query in terms of the condition specified for the Product node?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005004	Can you identify the two types of products whose names are used in the second query?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'Can you identify the two types of products whose names are used in the second query?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005005	In which way do the two products differ according to their names, as stated in the second query?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'In which way do the two products differ according to their names, as stated in the second query?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005006	"What is the significance of the word ""OR"" in the second query, specifically in relation to the Product node?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'What is the significance of the word ""OR"" in the second query, specifically in relation to the Product node?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005007	How would you describe the overall complexity level of the second query compared to the first one?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'How would you describe the overall complexity level of the second query compared to the first one?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005008	"What specific information about the customers who purchased either ""backpack"" or ""packsack"" products can be obtained through the second query?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'What specific information about the customers who purchased either ""backpack"" or ""packsack"" products can be obtained through the second query?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005009	Can you explain why it might be useful to use the second query instead of the first one when searching for customer data related to these particular products?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'Can you explain why it might be useful to use the second query instead of the first one when searching for customer data related to these particular products?'  "
C002300050	Introduccio a Neo4j	"MATCH (p:Product) WHERE p.name=""bagpack"";"	synthetic_question	"La següent consulta és una mica més complicada: retorna els noms dels clients que han comprat algun dels productes “backpack” o “packsack”. Tingueu en compte que aquesta condició es pot indicar de diferents maneres: • Concatenant un conjunt de comparacions amb operadors de tipus OR lògic: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=""backpack"" OR p.name=""packsack"""	C00230005010	Based on the given paragraph, what conclusion can you draw regarding the versatility of graph databases like Neo4j in handling complex queries involving multiple relationships and conditions?	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Product) WHERE p.name=""bagpack"";'; content: 'Based on the given paragraph, what conclusion can you draw regarding the versatility of graph databases like Neo4j in handling complex queries involving multiple relationships and conditions?'  "
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005101	What is the purpose of the MATCH clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'What is the purpose of the MATCH clause in the given Cypher query?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005102	Which entities are matched using the MATCH clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'Which entities are matched using the MATCH clause in the given Cypher query?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005103	What is the condition used in the WHERE clause of the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'What is the condition used in the WHERE clause of the given Cypher query?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005104	How does the expression regular work in the WHERE clause of the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'How does the expression regular work in the WHERE clause of the given Cypher query?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005105	What is the result of the given Cypher query when executed?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'What is the result of the given Cypher query when executed?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005106	Why do we use the DISTINCT keyword in the result of the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'Why do we use the DISTINCT keyword in the result of the given Cypher query?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005107	What type of data is returned by the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'What type of data is returned by the given Cypher query?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005108	"Can we use the same approach to find customers who have purchased products with other names containing the word ""pack""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'Can we use the same approach to find customers who have purchased products with other names containing the word ""pack""?'  "
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005109	How would we modify the query to retrieve only the customer names instead of the entire customer object?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'How would we modify the query to retrieve only the customer names instead of the entire customer object?'  
C002300051	Introduccio a Neo4j	RETURN c.customerName;	synthetic_question	"• Utilitzant operacions de conjunt: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name IN [""backpack"",""packsack""] RETURN c.customerName; • Utilitzant expressions regulars: MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[:INCLUDES]->(p:Product) WHERE p.name=~'.*pack.*' RETURN DISTINCT c.customerName; Tingueu en compte que l’operador d’expressió regular és =~ i que els caràcters .* indiquen qualsevol seqüència de caràcters. Per tant, la següent consulta retornarà els noms de les persones que han comprat algun producte que contingui el text “pack” en el seu nom; a més, utilitza la clàusula DISTINCT per eliminar valors repetits."	C00230005110	What is the difference between using the ~ operator versus the = operator in an expression regular?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN c.customerName;'; content: 'What is the difference between using the ~ operator versus the = operator in an expression regular?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005201	What is the purpose of the Cypher language in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'What is the purpose of the Cypher language in Neo4j?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005202	What type of queries can be performed using Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'What type of queries can be performed using Cypher?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005203	How does Cypher handle aggregates in queries?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'How does Cypher handle aggregates in queries?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005204	Can you provide an example of a query that uses aggregate functions in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'Can you provide an example of a query that uses aggregate functions in Cypher?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005205	What is the syntax for specifying multiple aggregate functions in a single query?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'What is the syntax for specifying multiple aggregate functions in a single query?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005206	How do you filter results when using aggregate functions in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'How do you filter results when using aggregate functions in Cypher?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005207	Can you explain how the `MATCH` clause works in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'Can you explain how the `MATCH` clause works in Cypher?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005208	What is the difference between `MATCH` and `WHERE` clauses in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'What is the difference between `MATCH` and `WHERE` clauses in Cypher?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005209	How do you use the `WITH` clause to define temporary variables in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'How do you use the `WITH` clause to define temporary variables in Cypher?'  
C002300052	Introduccio a Neo4j	3.1.4. Agrupar dades en una consulta	synthetic_question	Cypher també ofereix algunes funcions per al càlcul d’agregats. A continuació, es mostra un exemple en el qual s’identifica per cada client, el nombre de comandes realitzades que contenen algun producte que tingui “pack” com a part del seu nom. MATCH (c:Customer)<-[:BELONGS_TO]-(o:Order)-[i:INCLUDES]->(p:Product) WHERE p.name=~!'.*pack.*'	C00230005210	Can you give an example of a complex query that combines multiple `MATCH`, `WHERE`, and `RETURN` clauses in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.4. Agrupar dades en una consulta'; content: 'Can you give an example of a complex query that combines multiple `MATCH`, `WHERE`, and `RETURN` clauses in Cypher?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005301	What is the purpose of the COUNT function in the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'What is the purpose of the COUNT function in the given query?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005302	Which field does the COUNT function operate on in the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Which field does the COUNT function operate on in the given query?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005303	How many distinct customer names are there in the results of the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'How many distinct customer names are there in the results of the given query?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005304	What is the name of the product with the highest number of units sold, according to the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'What is the name of the product with the highest number of units sold, according to the given query?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005305	How many units have been sold for each product, according to the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'How many units have been sold for each product, according to the given query?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005306	Is it possible to filter the results of the given query by product name or customer name?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Is it possible to filter the results of the given query by product name or customer name?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005307	Can the given query be modified to display the total amount spent by each customer?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Can the given query be modified to display the total amount spent by each customer?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005308	Are there any products with zero units sold, according to the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Are there any products with zero units sold, according to the given query?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005309	Does the given query include any aggregation functions other than COUNT?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Does the given query include any aggregation functions other than COUNT?'  
C002300053	Introduccio a Neo4j	RETURN DISTINCT c.customerName,count(o);	synthetic_question	Tingueu en compte que el count en aquest cas permet comptar el nombre de comandes, que l’agrupació de dades s’ha realitzat directament a la clàusula RETURN, i implícitament, indicant els camps que s’han de mantenir (els que apareixen a la clàusula RETURN, c.customerName en aquest cas) i els que s’han d’agrupar (que apareixen amb funcions d’agregació, count(o) en aquest cas). A vegades, pot ser interessant realitzar l’agrupació abans de la clàusula WHERE per tal d’aplicar algun filtre sobre les dades agrupades com, per exemple, si demanen obtenir els productes amb més de cent unitats venudes. Així, caldria utilitzar una clàusula WITH que permeti precalcular l’agrupació abans de la clàusula WHERE. La consulta final quedaria de la següent manera: MATCH (o:Order)-[i:INCLUDES]->(p:Product) WITH p.name AS nameProduct, sum(i.units) AS numUnits WHERE numUnits > 100	C00230005310	Could the given query be used to determine the top-selling products overall, regardless of customer?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN DISTINCT c.customerName,count(o);'; content: 'Could the given query be used to determine the top-selling products overall, regardless of customer?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005401	What is the purpose of the MATCH clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'What is the purpose of the MATCH clause in Neo4j?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005402	How do we create two variables in the WITH clause of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'How do we create two variables in the WITH clause of Neo4j?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005403	What is the condition specified in the WHERE clause of Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'What is the condition specified in the WHERE clause of Neo4j?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005404	Why does Neo4j not integrate functionalities of MapReduce like other NoSQL databases?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'Why does Neo4j not integrate functionalities of MapReduce like other NoSQL databases?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005405	What is the native operation that allows us to perform aggregated operations in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'What is the native operation that allows us to perform aggregated operations in Neo4j?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005406	"Can you explain the concept of ""suma d'unitats venudes"" in Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'Can you explain the concept of ""suma d'unitats venudes"" in Neo4j?'  "
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005407	How does Neo4j differ from other NoSQL databases regarding distributed data processing?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'How does Neo4j differ from other NoSQL databases regarding distributed data processing?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005408	In what way does Neo4j enable natively performing aggregated operations?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'In what way does Neo4j enable natively performing aggregated operations?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005409	What is the significance of the fact that Neo4j does not have MapReduce functionality like other NoSQL databases?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'What is the significance of the fact that Neo4j does not have MapReduce functionality like other NoSQL databases?'  
C002300054	Introduccio a Neo4j	RETURN nameProduct, numUnits	synthetic_question	Fixeu-vos que la clàusula MATCH identifica les comandes i els productes d'interès. A continuació, a la clàusula WITH es creen dues variables: nameProduct (amb el nom del producte) i numUnits (amb la suma d’unitats venudes d’aquest producte). Un cop es tenen aquestes dues variables, a la clàusula WHERE s’indica que només interessen els productes amb més de 100 unitats venudes. A diferència d'altres sistemes gestors de bases de dades NoSQL, Neo4j no integra funcionalitats de MapReduce. Aquest fet, que podria semblar estrany en el context NoSQL, té sentit a Neo4j, ja que es tracta d’una base de dades que permet efectuar operacions agregades de forma nativa i no està pensada per oferir una alta distribució de dades.	C00230005410	Can you provide an example use case where Neo4j's lack of MapReduce functionality would be beneficial?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN nameProduct, numUnits'; content: 'Can you provide an example use case where Neo4j's lack of MapReduce functionality would be beneficial?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005501	What is the main purpose of the Graph Data Science Library for Neo4J?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'What is the main purpose of the Graph Data Science Library for Neo4J?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005502	How does the library provide algorithms for graph analysis?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'How does the library provide algorithms for graph analysis?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005503	Can you describe one of the six categories of algorithms provided by the library?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'Can you describe one of the six categories of algorithms provided by the library?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005504	What is an example of a mètrica used to determine centrality in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'What is an example of a mètrica used to determine centrality in the graph?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005505	How does the similarity algorithm work in the library?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'How does the similarity algorithm work in the library?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005506	Can you explain how pathfinding works in the library?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'Can you explain how pathfinding works in the library?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005507	What is node embedding, and how does it reduce the dimensionality of the graph?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'What is node embedding, and how does it reduce the dimensionality of the graph?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005508	Are there any examples of real-world applications using the Graph Data Science Library for Neo4J?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'Are there any examples of real-world applications using the Graph Data Science Library for Neo4J?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005509	Can you discuss the advantages of using this library for graph data science tasks?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'Can you discuss the advantages of using this library for graph data science tasks?'  
C002300055	Introduccio a Neo4j	3.1.5. Consultes avançades	synthetic_question	D’altra banda, Graph Data Science Library for Neo4J és una biblioteca que permet executar algoritmes de grafs i d’anàlisi de xarxes sobre les dades de la base de dades. Els algoritmes d'aquesta llibreria proporcionen mètodes d’aprenentatge automàtic i heurístics sense supervisió, que aprenen i descriuen sobre la topologia del graf. Els algoritmes proporcionats per la llibreria es poden classificar en sis categories: • Detecciódecomunitats: permet agrupar els nodes del graf en diferents comunitats o clústers. • Centralitat: determina la importància dels diferents nodes del graf respecte a diferents mètriques, com per exemple centralitat o intermediació. Semblança: avalua la similitud dels nodes segons diferents mètriques. • Predicciód’enllaços: estima la probabilitat que dos nodes estiguin relacionats en un futur. • Pathfindingicerca: troba camins òptims; avalua la disponibilitat de rutes i la seva qualitat. • NodeEmbedding: aprèn la topologia del graf per reduir la seva dimensionalitat per a l’aprenentatge automàtic.	C00230005510	How does the library support advanced consultation and exploration of graph data?	passage: document 'Introduccio a Neo4j'; paragraph: '3.1.5. Consultes avançades'; content: 'How does the library support advanced consultation and exploration of graph data?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005601	What is the purpose of creating nodes and relationships in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'What is the purpose of creating nodes and relationships in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005602	How do we create a new node in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'How do we create a new node in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005603	Can we create multiple nodes at once in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Can we create multiple nodes at once in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005604	What is the syntax for creating a new node in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'What is the syntax for creating a new node in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005605	Can we specify properties for our nodes when creating them in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Can we specify properties for our nodes when creating them in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005606	Are there any examples of sentences for creating nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Are there any examples of sentences for creating nodes in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005607	Can we create nodes without specifying any properties or relationships in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Can we create nodes without specifying any properties or relationships in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005608	Is it possible to create nodes with different types in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Is it possible to create nodes with different types in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005609	Can we use the same sentence to create multiple nodes with different types in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'Can we use the same sentence to create multiple nodes with different types in Neo4j?'  
C002300056	Introduccio a Neo4j	3.2. Creació de nodes i relacions	synthetic_question	Per crear un node (o més d’un, si se separen amb comes) a Neo4j s’utilitza la sentència CREATE. Per a cada node a crear, la persona usuària podrà indicar els seus tipus i les seves propietats. Les propietats es defineixen en format JSON. A continuació, es poden veure tres exemples de sentències de creació de nodes. La primera permet crear un node de tipus Customer sense cap propietat o relació associada: CREATE (c:Customer	C00230005610	What happens if we try to create a node with an invalid type or property in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.2. Creació de nodes i relacions'; content: 'What happens if we try to create a node with an invalid type or property in Neo4j?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005701	What is the purpose of the second operation in the sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'What is the purpose of the second operation in the sentence?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005702	What type of node is created in the first operation?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'What type of node is created in the first operation?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005703	What is the name of the property defined in the first operation?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'What is the name of the property defined in the first operation?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005704	What is the value assigned to the named property in the first operation?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'What is the value assigned to the named property in the first operation?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005705	Is there a return statement at the end of the sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'Is there a return statement at the end of the sentence?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005706	If yes, what does the return statement return?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'If yes, what does the return statement return?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005707	What is the data type of the element returned by the return statement?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'What is the data type of the element returned by the return statement?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005708	Can we create multiple nodes of the same type using this sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'Can we create multiple nodes of the same type using this sentence?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005709	Will the return statement always return an element if the operation is successful?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'Will the return statement always return an element if the operation is successful?'  
C002300057	Introduccio a Neo4j	CREATE (c:Customer)	synthetic_question	"La segona operació permet crear un node de tipus Customer que té una propietat amb nom name i Maria com a valor. Tingueu en compte que, en aquest cas, hi ha un RETURN al final de l’operació. Amb aquest RETURN s’està demanant a Cypher que retorni l’element creat com a resultat d’executar la sentència: CREATE (c:Customer{name:""Maria""}) RETURN c;"	C00230005710	How can we specify the value of the named property in the first operation if it is not explicitly mentioned?	passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer)'; content: 'How can we specify the value of the named property in the first operation if it is not explicitly mentioned?'  
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005801	What is the purpose of the third operation in the given code snippet?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What is the purpose of the third operation in the given code snippet?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005802	What type of node is created using the third operation?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What type of node is created using the third operation?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005803	What are the two properties defined for the created node?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What are the two properties defined for the created node?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005804	What is the value of the first property defined for the created node?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What is the value of the first property defined for the created node?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005805	What is the value of the second property defined for the created node?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What is the value of the second property defined for the created node?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005806	Why might creating nodes with incorrect labels be dangerous?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'Why might creating nodes with incorrect labels be dangerous?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005807	What is an example of incorrect labeling that could cause issues?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What is an example of incorrect labeling that could cause issues?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005808	How does Neo4j handle nodes with incorrect labels?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'How does Neo4j handle nodes with incorrect labels?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005809	Can you describe the behavior of Neo4j when encountering nodes with incorrect labels?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'Can you describe the behavior of Neo4j when encountering nodes with incorrect labels?'  "
C002300058	Introduccio a Neo4j	"CREATE (c:Customer{name:""Maria""}) RETURN c;"	synthetic_question	"• La tercera operació permet crear un node de classe persona amb dues propietats que denoten, respectivament, el nom, amb valor Alex, i la data de naixement (amb valor “2002-05-09”). Assumim que el tipus de node Person no existeix a la base de dades. En aquest cas, atès que Neo4j no tenia definit aquest tipus de node, el crearà a l’hora d’executar l’operació. Aquest comportament pot ser perillós, perquè si s’assignen nodes a etiquetes errònies(Peson en comptes de Person, per exemple) pot passar que no es trobin les dades quan estan mal classificades: CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	C00230005810	"What is the significance of the date ""2002-05-09"" in the given code snippet?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (c:Customer{name:""Maria""}) RETURN c;'; content: 'What is the significance of the date ""2002-05-09"" in the given code snippet?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005901	What is the purpose of creating relationships between nodes in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'What is the purpose of creating relationships between nodes in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005902	How do we identify which nodes to relate in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'How do we identify which nodes to relate in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005903	What is the syntax for creating a relationship between two nodes in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'What is the syntax for creating a relationship between two nodes in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005904	Can we create a relationship between two nodes without specifying a property or label in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'Can we create a relationship between two nodes without specifying a property or label in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005905	"What is the meaning of the keyword ""WHERE"" in the context of creating relationships in Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'What is the meaning of the keyword ""WHERE"" in the context of creating relationships in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005906	How does the example sentence in the paragraph illustrate the use of the MATCH and CREATE commands in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'How does the example sentence in the paragraph illustrate the use of the MATCH and CREATE commands in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005907	"What is the purpose of the ""since"" property in the example sentence?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'What is the purpose of the ""since"" property in the example sentence?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005908	Can we create a relationship between two nodes using a different label or property in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'Can we create a relationship between two nodes using a different label or property in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005909	How would we modify the previous example sentence to create a relationship between three or more nodes in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'How would we modify the previous example sentence to create a relationship between three or more nodes in Neo4j?'  "
C002300059	Introduccio a Neo4j	"CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;"	synthetic_question	"A Neo4j, els nodes poden estar aïllats, és a dir, no han de participar en relacions. No obstant això, les relacions s’han de crear entre nodes. Per tant, abans de crear una relació, s’haurà d’identificar a quins nodes relaciona. Per fer-ho, s’utilitzarà la sentència MATCH ... WHERE, com s’ha vist anteriorment. No obstant això, en aquest cas, la sentència finalitzarà amb una clàusula CREATE (o la seva alternativa MERGE) que li permetrà especificar quina relació s’ha de crear i entre quins nodes. L’exemple següent utilitza aquesta sintaxi per crear una relació entre els dos nodes que s’acaben de crear. A la sentència, primer s’identifiquen els nodes a relacionar (el client amb nom “Maria” i la persona amb nom “Alex”). Posteriorment, la clàusula CREATE indica que es vol crear una relació entre aquests dos nodes i se li assigna una propietat que representa la data en què es van conèixer. Es pot veure que la relació també s’ha associat amb una nova etiqueta: KNOWS. Com en el cas anterior, si el tipus de relació KNOWS no existeix a la base de dades, es crearà a conseqüència de l’execució d’aquesta operació: MATCH (a:Customer),(b:Person) WHERE a.name = ""Maria"" AND b.name = ""Alex"" CREATE (a)-[k:KNOWS { since: ""2020-01-01""}]->(b)"	C00230005910	Is it possible to create a relationship between a node and itself in Neo4j?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p:Person{name:""Alex"", birthday:""2002-05-09""}) RETURN p;'; content: 'Is it possible to create a relationship between a node and itself in Neo4j?'  "
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006001	What is the purpose of the `MATCH` clause in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'What is the purpose of the `MATCH` clause in Cypher?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006002	What type of node is created when using the `CREATE` statement in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'What type of node is created when using the `CREATE` statement in Cypher?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006003	How do we specify the properties of a new node in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'How do we specify the properties of a new node in Cypher?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006004	What is the difference between `MERGE` and `CREATE` statements in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'What is the difference between `MERGE` and `CREATE` statements in Cypher?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006005	Can we create a relationship between two nodes without creating a new node?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'Can we create a relationship between two nodes without creating a new node?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006006	How do we reference an existing node in a query using Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'How do we reference an existing node in a query using Cypher?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006007	What does the `name` property represent in the example given in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'What does the `name` property represent in the example given in the paragraph?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006008	Is it possible to create a relationship between two nodes without specifying the `FROM` keyword?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'Is it possible to create a relationship between two nodes without specifying the `FROM` keyword?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006009	How do we use the `WITH` clause in Cypher to define a subquery?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'How do we use the `WITH` clause in Cypher to define a subquery?'  
C002300060	Introduccio a Neo4j	RETURN Type(k), k.since;	synthetic_question	També es pot crear un nou node i una relació associada a un node preexistent: MATCH (p:Person { name: 'Alex' })	C00230006010	What is the purpose of the `RETURN` statement in Cypher?	passage: document 'Introduccio a Neo4j'; paragraph: 'RETURN Type(k), k.since;'; content: 'What is the purpose of the `RETURN` statement in Cypher?'  
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006101	"What is the purpose of the ""CREATE"" clause in Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'What is the purpose of the ""CREATE"" clause in Neo4j?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006102	"How many elements can be created using the ""CREATE"" clause in Neo4j?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'How many elements can be created using the ""CREATE"" clause in Neo4j?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006103	"What type of relationship is created between ""Juan"" and ""Pedro"" in the given example?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'What type of relationship is created between ""Juan"" and ""Pedro"" in the given example?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006104	"What is the value of the ""orderNumber"" property in the ""Order"" node created in the example?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'What is the value of the ""orderNumber"" property in the ""Order"" node created in the example?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006105	"What is the date associated with the ""Order"" node created in the example?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'What is the date associated with the ""Order"" node created in the example?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006106	Who is the customer in the given example?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'Who is the customer in the given example?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006107	What is the name of the person who placed the order in the given example?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'What is the name of the person who placed the order in the given example?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006108	When was the order placed, according to the given example?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'When was the order placed, according to the given example?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006109	"What is the type of relationship between ""Juan"" and ""Pedro""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'What is the type of relationship between ""Juan"" and ""Pedro""?'  "
C002300061	Introduccio a Neo4j	"CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});"	synthetic_question	"A vegades, es pot aprofitar que la clàusula CREATE permet crear múltiples elements per facilitar la creació de les relacions. Per exemple, a la següent consulta es crea d’una tirada un client, una persona, una relació entre ambdós del tipus KNOWS, una comanda, i s’indica que la comanda pertany a Juan, una de les persones creades. Fixeu-vos que els nodes que participen en la relació no s’han de buscar perquè han estat creats en el mateix CREATE i, per tant, la seva variable segueix essent accessible: CREATE (j:Customer{customerName:""Juan""}), (p:Person{ name:""Pedro"", birthday:""1980-04-19""}), (o:Order{ orderNumber:1003, date:""2020-11-25""}), (j)-[k:KNOWS{since: ""2019-12-31""}]->(p),"	C00230006110	Can you identify the node that represents the order in the given example?	"passage: document 'Introduccio a Neo4j'; paragraph: 'CREATE (p)<-[:BELONGS_TO]-(o2:Order{orderNumber:1002,date:""2020-09-01""});'; content: 'Can you identify the node that represents the order in the given example?'  "
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006201	What is the purpose of the MERGE operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'What is the purpose of the MERGE operation in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006202	Can existing nodes be created using the MERGE operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'Can existing nodes be created using the MERGE operation in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006203	How does the MERGE operation differ from other creation operations in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'How does the MERGE operation differ from other creation operations in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006204	When would it be appropriate to use the MERGE operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'When would it be appropriate to use the MERGE operation in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006205	Is there a way to ensure that only unique nodes are created using the MERGE operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'Is there a way to ensure that only unique nodes are created using the MERGE operation in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006206	Can the MERGE operation be used to create relationships between nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'Can the MERGE operation be used to create relationships between nodes in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006207	Are there any performance considerations when using the MERGE operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'Are there any performance considerations when using the MERGE operation in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006208	How does the MERGE operation affect the data integrity of the graph in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'How does the MERGE operation affect the data integrity of the graph in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006209	Can the MERGE operation be rolled back if errors occur during the creation process in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'Can the MERGE operation be rolled back if errors occur during the creation process in Neo4j?'  
C002300062	Introduccio a Neo4j	(o)-[:BELONGS_TO]->(j)	synthetic_question	Finalment, s’ha de comentar que hi ha una operació anomenada MERGE, la qual permet crear elements en el graf, sempre que aquests no existeixin.	C00230006210	What happens if a node or relationship already exists and is tried to be merged again using the MERGE operation in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '(o)-[:BELONGS_TO]->(j)'; content: 'What happens if a node or relationship already exists and is tried to be merged again using the MERGE operation in Neo4j?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006301	"What is the purpose of the sentence ""A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero""?"	"passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'What is the purpose of the sentence ""A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero""?'  "
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006302	How can nodes be eliminated in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'How can nodes be eliminated in Neo4j?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006303	What is the difference between using MATCH and WHERE clauses in a DELETE statement?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'What is the difference between using MATCH and WHERE clauses in a DELETE statement?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006304	Can you eliminate a relationship in Neo4j using DELETE clause?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'Can you eliminate a relationship in Neo4j using DELETE clause?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006305	What happens if you try to delete a node or relationship that does not exist in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'What happens if you try to delete a node or relationship that does not exist in the graph?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006306	Is it possible to delete multiple nodes or relationships at once in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'Is it possible to delete multiple nodes or relationships at once in Neo4j?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006307	Can you delete all nodes or relationships in a graph using a single DELETE statement?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'Can you delete all nodes or relationships in a graph using a single DELETE statement?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006308	What is the effect of deleting a node or relationship on other related nodes or relationships in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'What is the effect of deleting a node or relationship on other related nodes or relationships in the graph?'  
C002300063	Introduccio a Neo4j	3.3. Operacions d’esborrat	synthetic_question	A Neo4j no es pot esborrar un node d’un graf, si no és que el grau d’entrada i de sortida del node és zero. En altres paraules, només es podran eliminar nodes que no participin en relacions. Per eliminar un node o una relació a Neo4j, primer s’utilitza la sentència MATCH per identificar les dades d’interès i, després, una clàusula DELETE per indicar quin element s’ha d’eliminar. A les clàusules MATCH i WHERE s’indicaran els patrons i les condicions que permeten identificar els elements a eliminar. La clàusula DELETE indicarà quins elements s’han d’eliminar. Aquí es poden veure un parell d’exemples per eliminar les dades creades anteriorment. El primer exemple intenta esborrar el node Customer, que té un atribut anomenat “name” amb valor “Maria”. Per fer-ho, s’indica que l’element a eliminar és un node c (clàusula DELETE), de tipus Customer (clàusula MATCH) i el nom del qual és Maria (en comptes d’utilitzar la clàusula WHERE, el seu valor es filtra en la definició del patró): MATCH (c:Customer { name: 'Maria' }) DELETE c;	C00230006309	How do you ensure that only relevant data is deleted when using DELETE statements in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: '3.3. Operacions d’esborrat'; content: 'How do you ensure that only relevant data is deleted when using DELETE statements in Neo4j?'  
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006401	What is the purpose of the `DELETE` statement in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'What is the purpose of the `DELETE` statement in the given Cypher query?'  
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006402	Why does executing the `DELETE` statement result in an error, according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Why does executing the `DELETE` statement result in an error, according to the given paragraph?'  
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006403	"How can we eliminate the node labeled ""Maria"" without causing errors, as described in the given paragraph?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'How can we eliminate the node labeled ""Maria"" without causing errors, as described in the given paragraph?'  "
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006404	"What is the difference between the two methods for eliminating the node labeled ""Maria""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'What is the difference between the two methods for eliminating the node labeled ""Maria""?'  "
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006405	"In which relationships does the node labeled ""Maria"" participate, according to the given paragraph?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'In which relationships does the node labeled ""Maria"" participate, according to the given paragraph?'  "
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006406	"How would you modify the `DELETE` statement to eliminate the node labeled ""Maria"" while preserving the relationships it participates in?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'How would you modify the `DELETE` statement to eliminate the node labeled ""Maria"" while preserving the relationships it participates in?'  "
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006407	"Can you explain why the second method for eliminating the node labeled ""Maria"" is preferred over the first one, based on the given paragraph?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Can you explain why the second method for eliminating the node labeled ""Maria"" is preferred over the first one, based on the given paragraph?'  "
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006408	According to the given paragraph, what is the main reason for avoiding the use of the `DELETE` statement when deleting nodes?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'According to the given paragraph, what is the main reason for avoiding the use of the `DELETE` statement when deleting nodes?'  
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006409	How does the use of the `DELETE` statement differ from the use of the `MERGE` statement when updating nodes, as discussed in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'How does the use of the `DELETE` statement differ from the use of the `MERGE` statement when updating nodes, as discussed in the given paragraph?'  
C002300064	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	Si s’executa aquesta operació, es veurà que Neo4j dona un error. Això es deu al fet que el node a eliminar encara manté relacions amb altres nodes. Es podria eliminar el node Maria de dues maneres diferents: 1) Eliminar primer les relacions en les quals participa el node i, a continuació, eliminar el node: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r;	C00230006410	Based on the given paragraph, what is the best practice for deleting nodes in Neo4j, and why?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Based on the given paragraph, what is the best practice for deleting nodes in Neo4j, and why?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006501	What is the purpose of the MATCH command in the given graph database example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'What is the purpose of the MATCH command in the given graph database example?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006502	Which node(s) will be deleted using the MATCH command in the given example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Which node(s) will be deleted using the MATCH command in the given example?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006503	What is the condition specified in the MATCH command to identify the nodes to be deleted?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'What is the condition specified in the MATCH command to identify the nodes to be deleted?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006504	What type of relationships will also be deleted along with the identified nodes using the MATCH command in the given example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'What type of relationships will also be deleted along with the identified nodes using the MATCH command in the given example?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006505	Can you explain the significance of the parentheses in the MATCH command in the given example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Can you explain the significance of the parentheses in the MATCH command in the given example?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006506	How does the DELETE clause work in conjunction with the MATCH command in the given example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'How does the DELETE clause work in conjunction with the MATCH command in the given example?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006507	What is the net effect of executing the given MATCH and DELETE commands in the graph database?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'What is the net effect of executing the given MATCH and DELETE commands in the graph database?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006508	Are there any other ways to achieve the same result as the given MATCH and DELETE commands in the graph database?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Are there any other ways to achieve the same result as the given MATCH and DELETE commands in the graph database?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006509	Can you describe the difference between the MATCH command and other query languages such as Cypher or Gremlin?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'Can you describe the difference between the MATCH command and other query languages such as Cypher or Gremlin?'  
C002300065	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' }) DELETE c;	synthetic_question	2) Eliminar també, al mateix temps (amb la mateixa operació), el node i les seves relacions: MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	C00230006510	In what scenarios might it be beneficial to use the MATCH command instead of other query languages like Cypher or Gremlin in a graph database?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' }) DELETE c;'; content: 'In what scenarios might it be beneficial to use the MATCH command instead of other query languages like Cypher or Gremlin in a graph database?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006601	What is the purpose of the MATCH clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'What is the purpose of the MATCH clause in the given Cypher query?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006602	Which node is selected by the MATCH clause in the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'Which node is selected by the MATCH clause in the given Cypher query?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006603	What is the condition specified in the WHERE clause of the given Cypher query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'What is the condition specified in the WHERE clause of the given Cypher query?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006604	How many relationships are matched by the query in the given example?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'How many relationships are matched by the query in the given example?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006605	"Can the query delete nodes that are not related to the customer ""Maria""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'Can the query delete nodes that are not related to the customer ""Maria""?'  "
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006606	How does the use of the OPTIONAL MATCH clause affect the behavior of the query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'How does the use of the OPTIONAL MATCH clause affect the behavior of the query?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006607	What is the difference between using MATCH (c) versus MATCH (c:Customer) in the given query?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'What is the difference between using MATCH (c) versus MATCH (c:Customer) in the given query?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006608	Can the query be modified to delete all relationships instead of just one?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'Can the query be modified to delete all relationships instead of just one?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006609	Is it possible to modify the query to delete only certain types of relationships?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'Is it possible to modify the query to delete only certain types of relationships?'  
C002300066	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;	synthetic_question	No obstant això, si el node no estigués relacionat, la sentència anterior no funcionaria, ja que Maria no seria seleccionada a la clàusula MATCH. Per assegurar que un node i totes les seves relacions associades s’esborren en una sola sentència, es pot utilitzar: MATCH (c:Customer { name: 'Maria' }) OPTIONAL MATCH (c)-[r]-()	C00230006610	"How would the query change if the goal was to delete all nodes and relationships associated with the customer ""Maria"" instead of just the relationship(s)?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })-[r]-() DELETE r,c;'; content: 'How would the query change if the goal was to delete all nodes and relationships associated with the customer ""Maria"" instead of just the relationship(s)?'  "
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006701	What is the purpose of the DETACH DELETE clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'What is the purpose of the DETACH DELETE clause in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006702	How does the DETACH DELETE clause differ from the traditional MATCH and DELETE clauses in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'How does the DETACH DELETE clause differ from the traditional MATCH and DELETE clauses in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006703	According to the documentation, what should one do before using the DETACH DELETE clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'According to the documentation, what should one do before using the DETACH DELETE clause in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006704	Can you explain the difference between the MATCH (c:Customer { name: 'Maria' }) and MATCH (c:Customer) syntax in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'Can you explain the difference between the MATCH (c:Customer { name: 'Maria' }) and MATCH (c:Customer) syntax in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006705	In which situations would you use the DETACH DELETE clause instead of the traditional MATCH and DELETE clauses in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'In which situations would you use the DETACH DELETE clause instead of the traditional MATCH and DELETE clauses in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006706	How does the DETACH DELETE clause affect the relationships between nodes in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'How does the DETACH DELETE clause affect the relationships between nodes in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006707	Is it possible to use the DETACH DELETE clause with other clauses in Neo4j, such as the MERGE or CREATE clauses?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'Is it possible to use the DETACH DELETE clause with other clauses in Neo4j, such as the MERGE or CREATE clauses?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006708	Can you provide an example of a real-world scenario where the DETACH DELETE clause might be useful in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'Can you provide an example of a real-world scenario where the DETACH DELETE clause might be useful in Neo4j?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006709	Are there any performance considerations when using the DETACH DELETE clause in Neo4j compared to other query methods?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'Are there any performance considerations when using the DETACH DELETE clause in Neo4j compared to other query methods?'  
C002300067	Introduccio a Neo4j	DELETE c, r;	synthetic_question	Es recomana consultar la documentació de Cypher per veure el funcionament d’OPTIONAL MATCH i entendre la consulta en profunditat. A les últimes versions de Neo4j s’ha afegit una clàusula DETACH DELETE, que permet eliminar un node i totes les relacions en les quals participa directament. Per tant, les consultes anteriors serien equivalents a: MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;	C00230006710	How does the DETACH DELETE clause impact the data modeling approach in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'DELETE c, r;'; content: 'How does the DETACH DELETE clause impact the data modeling approach in Neo4j?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006801	What is the purpose of the MATCH clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'What is the purpose of the MATCH clause in Neo4j?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006802	How do you modify properties in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'How do you modify properties in Neo4j?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006803	What is the effect of using the SET clause in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'What is the effect of using the SET clause in Neo4j?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006804	Can you create new properties in Neo4j using the SET clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'Can you create new properties in Neo4j using the SET clause?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006805	How do you eliminate properties in Neo4j using the REMOVE clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'How do you eliminate properties in Neo4j using the REMOVE clause?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006806	What is an example of adding a property to a node in Neo4j using the SET clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'What is an example of adding a property to a node in Neo4j using the SET clause?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006807	What is an example of modifying a property in Neo4j using the SET clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'What is an example of modifying a property in Neo4j using the SET clause?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006808	Can you remove all occurrences of a particular property in Neo4j using the REMOVE clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'Can you remove all occurrences of a particular property in Neo4j using the REMOVE clause?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006809	Is it possible to delete a property completely from a node in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'Is it possible to delete a property completely from a node in Neo4j?'  
C002300068	Introduccio a Neo4j	MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització	synthetic_question	Pel que fa a la modificació de grafs, Neo4j permet afegir, modificar i eliminar propietats d’un graf, d’una banda, i afegir, modificar i esborrar els tipus dels nodes i de les relacions, de l’altra. L’addició (o modificació) de propietats es fa afegint la clàusula SET al final d’una sentència MATCH. La clàusula SET indicarà el nom i la ubicació de la propietat, i el nou valor que ha de tenir. En el cas que la propietat no existís, es crearia. D’altra banda, per eliminar una propietat d’un o més nodes, s’utilitza la clàusula REMOVE. Cal indicar el conjunt de propietats a eliminar. A continuació es presenten tres exemples. En el primer cas, s’afegeix una propietat amb nom job i valor lawyer a la persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	C00230006810	How do you distinguish between adding and removing properties in Neo4j using the SET and REMOVE clauses?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (c:Customer { name: 'Maria' })DETACH DELETE c;.  3.4. Operacions d’actualització'; content: 'How do you distinguish between adding and removing properties in Neo4j using the SET and REMOVE clauses?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006901	What is the purpose of the first sentence in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'What is the purpose of the first sentence in the given paragraph?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006902	What is the name of the property being set in the third sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'What is the name of the property being set in the third sentence?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006903	Who or what is the subject of the fourth sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'Who or what is the subject of the fourth sentence?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006904	What is the effect of running the fifth sentence on the nodes with the specified label?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'What is the effect of running the fifth sentence on the nodes with the specified label?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006905	In which language is the code written in the sixth sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'In which language is the code written in the sixth sentence?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006906	"What is the meaning of the term ""REMOVE"" in the seventh sentence?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'What is the meaning of the term ""REMOVE"" in the seventh sentence?'  "
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006907	How many sentences are there in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'How many sentences are there in the given paragraph?'  
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006908	"Which sentence contains the term ""LAWYER""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'Which sentence contains the term ""LAWYER""?'  "
C002300069	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';	synthetic_question	La segona sentència elimina la propietat job dels nodes de tipus persona amb nom “Alex”: MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	C00230006909	What is the main topic discussed in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' SET p.job='lawyer';'; content: 'What is the main topic discussed in the given paragraph?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007001	What is the purpose of the third sentence in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'What is the purpose of the third sentence in the given paragraph?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007002	How does the third sentence modify the previous statements in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'How does the third sentence modify the previous statements in the paragraph?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007003	What is the effect of running the command mentioned in the third sentence?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'What is the effect of running the command mentioned in the third sentence?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007004	Why do we need to remove the job property before adding it back with a new value?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'Why do we need to remove the job property before adding it back with a new value?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007005	What is the difference between the original value of the job property and the new value added after removal?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'What is the difference between the original value of the job property and the new value added after removal?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007006	Can we assume that all persons have a gender property?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'Can we assume that all persons have a gender property?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007007	How would you describe the relationship between the person and their job according to the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'How would you describe the relationship between the person and their job according to the given paragraph?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007008	Is there any implicit assumption about the data type of the job property in the given paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'Is there any implicit assumption about the data type of the job property in the given paragraph?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007009	Can we use this command to update multiple properties at once for different individuals in the graph?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'Can we use this command to update multiple properties at once for different individuals in the graph?'  
C002300070	Introduccio a Neo4j	MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;	synthetic_question	La tercera sentència permet afegir dues propietats a la mateixa persona, el seu gènere i la classe de treball que fa, job. En el cas que la propietat job ja existeixi (imagineu que no s’hagués esborrat en l’operació anterior), el seu valor es modificarà en comptes d’afegir la propietat: MATCH (p:Person) WHERE p.name='Alex'	C00230007010	What is the significance of using the MATCH clause instead of another Cypher statement to achieve the desired result?	passage: document 'Introduccio a Neo4j'; paragraph: 'MATCH (p:Person) WHERE p.name='Alex' REMOVE p.job;'; content: 'What is the significance of using the MATCH clause instead of another Cypher statement to achieve the desired result?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007101	What is the purpose of using the SET and REMOVE clauses in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'What is the purpose of using the SET and REMOVE clauses in Neo4j?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007102	How do we use the SET clause to modify the labels of a node?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'How do we use the SET clause to modify the labels of a node?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007103	Can we remove labels from a node using the REMOVE clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'Can we remove labels from a node using the REMOVE clause?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007104	How does the MATCH statement work in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'How does the MATCH statement work in Neo4j?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007105	What is the difference between the MATCH and THE statements in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'What is the difference between the MATCH and THE statements in Neo4j?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007106	Can we use the SET clause to add or remove multiple labels at once?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'Can we use the SET clause to add or remove multiple labels at once?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007107	Is it possible to add or remove labels from a relationship using the SET clause?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'Is it possible to add or remove labels from a relationship using the SET clause?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007108	How do we use the REMOVE clause to delete a label from a node?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'How do we use the REMOVE clause to delete a label from a node?'  
C002300071	Introduccio a Neo4j	SET p.job='lawyer', p.gender='male';	synthetic_question	Com s’ha comentat, també es poden afegir o eliminar etiquetes als nodes o relacions d’un graf. Per fer-ho, també s’utilitzen les clàusules SET o REMOVE, tot indicant el node o la relació a modificar i el conjunt de tipus a afegir o eliminar. Per exemple, es podria afegir l’etiqueta Customer als clients, tot entenent com a clients aquelles persones que participen en una relació de tipus BELONGS_TO com a node de destinació. Com a resultat, després de l’execució d’aquesta operació, la persona el nom de la qual és “Alex” tindrà dues etiquetes associades: Person i Customer: MATCH (p:Person)<-[:BELONGS_TO]-(o)	C00230007109	Can we use the SET clause to change the property values of a node?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p.job='lawyer', p.gender='male';'; content: 'Can we use the SET clause to change the property values of a node?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007201	What is the purpose of the example given in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'What is the purpose of the example given in the paragraph?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007202	Who is the person mentioned in the example?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'Who is the person mentioned in the example?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007203	What is the current label associated with the person in the example?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'What is the current label associated with the person in the example?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007204	How does the example modify the node for the person mentioned?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'How does the example modify the node for the person mentioned?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007205	What is the result of executing the operation shown in the example?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'What is the result of executing the operation shown in the example?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007206	Will the person mentioned still be considered a customer after the execution of the example?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'Will the person mentioned still be considered a customer after the execution of the example?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007207	Why is the person mentioned no longer considered a person in the database after the execution of the example?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'Why is the person mentioned no longer considered a person in the database after the execution of the example?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007208	"What is the difference between the original label ""Person"" and the modified label ""Customer""?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'What is the difference between the original label ""Person"" and the modified label ""Customer""?'  "
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007209	Can the person mentioned still have any properties or relationships associated with them after the modification?	passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'Can the person mentioned still have any properties or relationships associated with them after the modification?'  
C002300072	Introduccio a Neo4j	SET p:Customer;	synthetic_question	El següent exemple permet modificar el node de la persona “Alex” desassignant-li l’etiqueta Person. Per tant, després de l’execució d’aquesta operació, Alex deixaria de ser considerat com una persona a la base de dades i seria considerat simplement com un client: MATCH (p:Person) WHERE p.name='Alex'	C00230007210	"Is there any way to restore the original label ""Person"" for the modified node?"	"passage: document 'Introduccio a Neo4j'; paragraph: 'SET p:Customer;'; content: 'Is there any way to restore the original label ""Person"" for the modified node?'  "
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007301	What is the main idea discussed in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'What is the main idea discussed in the paragraph?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007302	According to the paragraph, what is the purpose of using etiquettes in graph databases like Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'According to the paragraph, what is the purpose of using etiquettes in graph databases like Neo4j?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007303	Can you simulate multiple classifications or inheritances in Neo4j using etiquettes?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'Can you simulate multiple classifications or inheritances in Neo4j using etiquettes?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007304	How does assigning multiple labels to an element in a graph database differ from simulating multiple classifications or inheritances?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'How does assigning multiple labels to an element in a graph database differ from simulating multiple classifications or inheritances?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007305	What are some potential uses of this feature in Neo4j, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'What are some potential uses of this feature in Neo4j, according to the paragraph?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007306	Can you provide an example of a real-world scenario where simulating multiple classifications or inheritances would be useful?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'Can you provide an example of a real-world scenario where simulating multiple classifications or inheritances would be useful?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007307	How do the etiquettes assigned to elements in a graph database affect the search functionality?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'How do the etiquettes assigned to elements in a graph database affect the search functionality?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007308	Is it possible to remove etiquettes from elements in Neo4j?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'Is it possible to remove etiquettes from elements in Neo4j?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007309	Can you explain the difference between removing an etiquette and deleting an element entirely from the graph database?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'Can you explain the difference between removing an etiquette and deleting an element entirely from the graph database?'  
C002300073	Introduccio a Neo4j	REMOVE p:Person;	synthetic_question	Com podeu veure, el nombre d’etiquetes que es poden assignar (o esborrar) a un element del graf pot ser superior a un. Això permet simular que un element del graf pertanyi a més d’un tipus, la qual cosa seria útil per simular models de classificació múltiple o d’herència múltiple. Un bon ús d’aquesta característica permet moltes possibilitats en la classificació i la cerca de dades.	C00230007310	In which situations might it be beneficial to use this feature in Neo4j, compared to simply deleting elements altogether?	passage: document 'Introduccio a Neo4j'; paragraph: 'REMOVE p:Person;'; content: 'In which situations might it be beneficial to use this feature in Neo4j, compared to simply deleting elements altogether?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007601	What is the title of the book mentioned in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'What is the title of the book mentioned in the paragraph?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007602	Who are the authors of the book mentioned in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'Who are the authors of the book mentioned in the paragraph?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007603	When was the book mentioned in the paragraph published?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'When was the book mentioned in the paragraph published?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007604	What is the name of the machine described in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'What is the name of the machine described in the paragraph?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007605	Who wrote the article mentioned in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'Who wrote the article mentioned in the paragraph?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007606	When was the article mentioned in the paragraph written?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'When was the article mentioned in the paragraph written?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007607	Where can the article mentioned in the paragraph be found?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'Where can the article mentioned in the paragraph be found?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007608	What is the main topic of the article mentioned in the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'What is the main topic of the article mentioned in the paragraph?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007609	What is the purpose of the Gremlin graph traversal machine, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'What is the purpose of the Gremlin graph traversal machine, according to the paragraph?'  
C002300076	Introduccio a Neo4j	Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.	synthetic_question	Rodriguez, Marko A. (2015, 16 d'agost). «The Gremlin Graph Traversal Machine and Language». ACM Proceedings of the 15th Symposium on Database Programming Languages (pàgs. 1-10). Disponible a: <https://arxiv.org/abs/1508.03843>. Scifo, Estelle (2020). Hands-On Graph Analytics with Neo4j: Perform graph processing and visualization techniques using connected data across your Enterprise. Birmingham: Packt Publishing.	C00230007610	What is the name of the company that developed the Gremlin graph traversal machine, according to the paragraph?	passage: document 'Introduccio a Neo4j'; paragraph: 'Robinson, Ian; Webber, Jim; Eifrem, Emil (2015). Graph Databases. Newton, MA: O’Reilly Media, Inc.'; content: 'What is the name of the company that developed the Gremlin graph traversal machine, according to the paragraph?'  
C002100001	Introduccion a MongoDB	Introducción a MongoDB	source	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000100	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es'  
C002100002	Introduccion a MongoDB	Índice	source	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000200	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................'  
C002100003	Introduccion a MongoDB	Introducción	source	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000300	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	source	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000400	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.'  
C002100005	Introduccion a MongoDB	1.1. Versiones	source	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000500	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	source	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000600	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	source	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000700	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	source	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000800	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	source	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000900	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: '(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	source	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001000	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	source	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001100	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.'  
C002100012	Introduccion a MongoDB	Ejemplo	source	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001200	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.'  
C002100013	Introduccion a MongoDB	lookup	source	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	C00210001300	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	passage: document 'Introduccion a MongoDB'; paragraph: 'lookup'; content: 'Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	source	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001400	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-'  
C002100015	Introduccion a MongoDB	cumentos.	source	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001500	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	source	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001600	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.'  
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	source	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001700	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"",'  "
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	source	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001800	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	"passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas.'  "
C002100019	Introduccion a MongoDB	2.3. Índices	source	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001900	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.'  
C002100020	Introduccion a MongoDB	2.3. Índices	source	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002000	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	"passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	source	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002100	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: '(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.'  "
C002100022	Introduccion a MongoDB	3. Sistema transaccional	source	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002200	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	source	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002300	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.'  
C002100024	Introduccion a MongoDB	Transacción compleja	source	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002400	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.'  
C002100025	Introduccion a MongoDB	Transacción compleja	source	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002500	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	source	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002600	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	source	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002700	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	source	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002800	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.'  
C002100029	Introduccion a MongoDB	Parámetros	source	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002900	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.'  
C002100030	Introduccion a MongoDB	Parámetros	source	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003000	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: '2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	source	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003100	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.'  
C002100032	Introduccion a MongoDB	4.1. Creación	source	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003200	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.'  
C002100033	Introduccion a MongoDB	Ejemplo	source	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003300	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	"passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento.'  "
C002100034	Introduccion a MongoDB	4.2. Consulta	source	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003400	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	"passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	source	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003500	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	source	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003600	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad.'  "
C002100037	Introduccion a MongoDB	4.3. Actualización	source	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003700	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.'  
C002100038	Introduccion a MongoDB	4.3. Actualización	source	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003800	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.'  
C002100039	Introduccion a MongoDB	Ejemplo	source	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003900	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });'  "
C002100040	Introduccion a MongoDB	4.4. Borrado	source	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004000	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.'  
C002100041	Introduccion a MongoDB	Ejemplo	source	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004100	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	source	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004200	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.'  "
C002100043	Introduccion a MongoDB	e	source	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004300	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	source	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004400	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	source	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004500	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	source	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004600	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	source	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004700	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	source	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004800	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	source	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004900	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	source	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005000	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.'  
C002100051	Introduccion a MongoDB	5.3.2. Read concern	source	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005100	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: '• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	source	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005200	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	source	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005300	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: '• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	source	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005400	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	source	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005500	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	source	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005600	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	source	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005700	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	source	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005800	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	source	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005900	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.'  
C002100060	Introduccion a MongoDB	Ejemplos	source	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006000	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.'  
C002100061	Introduccion a MongoDB	Clave de distribución	source	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006100	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	source	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006200	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	source	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006300	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	source	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006400	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	source	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006500	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.'  
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000101	What is the recommended minimum time dedication for learning MongoDB according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'What is the recommended minimum time dedication for learning MongoDB according to the passage?'  
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000102	"Who is the author of the article ""Introduction to MongoDB""?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'Who is the author of the article ""Introduction to MongoDB""?'  "
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000103	"Where was the article ""Introduction to MongoDB"" published for the first time?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'Where was the article ""Introduction to MongoDB"" published for the first time?'  "
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000104	"When was the article ""Introduction to MongoDB"" last updated?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'When was the article ""Introduction to MongoDB"" last updated?'  "
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000105	"What type of license does the article ""Introduction to MongoDB"" have?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'What type of license does the article ""Introduction to MongoDB"" have?'  "
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000106	"Can the work derived from the article ""Introduction to MongoDB"" be subjected to the same license as the original work?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'Can the work derived from the article ""Introduction to MongoDB"" be subjected to the same license as the original work?'  "
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000107	What is the full name of the foundation responsible for coordinating the creation of this learning resource?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'What is the full name of the foundation responsible for coordinating the creation of this learning resource?'  
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000108	What is the address of the foundation responsible for coordinating the creation of this learning resource?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'What is the address of the foundation responsible for coordinating the creation of this learning resource?'  
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000109	Who is the professor mentioned in the passage as the coordinator of the project?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'Who is the professor mentioned in the passage as the coordinator of the project?'  
C002100001	Introduccion a MongoDB	Introducción a MongoDB	synthetic_question	PID_00281046 Joan Anton Pérez Braña Tiempo mínimo de dedicación recomendado: 3 horas Ingeniero superior de Informática (UOC) y licenciado en Ciencias Biológicas (UB). Ha desarrollado su carrera profesional como profesor de informática y, últimamente, como ingeniero de datos. Desde el año 2008 colabora como consultor docente en la UOC en asignaturas relacionadas con bases de datos relacionales en ingeniería Multimedia, con bases de datos NoSQL del grado de Ciencia de Datos Aplicada (Applied Data Science), y como tutor de proyecto de final de carrera (TFC-XML y Web semántica) en Informática de Gestión. El encargo y la creación de este recurso de aprendizaje UOC han sido coordinados por el profesor: Jordi Conesa Caralt Primera edición: febrero 2022 © de esta edición, Fundació Universitat Oberta de Catalunya (FUOC) Av. Tibidabo, 39-43, 08035 Barcelona Autoría: Joan Anton Pérez Braña Producción: FUOC Los textos e imágenes publicados en esta obra están sujetos –excepto que se indique lo contrario– a una licencia Creative Commons de tipo Reconocimiento-Compartir igual (BY-SA) v.3.0. Se puede modificar la obra, reproducirla, distribuirla o comunicarla públicamente siempre que se cite el autor y la fuente (Fundació per a la Universitat Oberta de Catalunya), y siempre que la obra derivada quede sujeta a la misma licencia que la obra original. La licencia completa se puede consultar en: http:// creativecommons.org/licenses/by-sa/3.0/es/legalcode.es	C00210000110	"What is the title of the course where the article ""Introduction to MongoDB"" is used as a teaching tool?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción a MongoDB'; content: 'What is the title of the course where the article ""Introduction to MongoDB"" is used as a teaching tool?'  "
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000201	What is the main topic introduced in the first sentence of the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'What is the main topic introduced in the first sentence of the paragraph?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000202	According to the paragraph, what is the purpose of introducing MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'According to the paragraph, what is the purpose of introducing MongoDB?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000203	The paragraph mentions different versions of MongoDB. How many versions are supported currently?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'The paragraph mentions different versions of MongoDB. How many versions are supported currently?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000204	Which storage engines are supported by MongoDB, according to the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'Which storage engines are supported by MongoDB, according to the paragraph?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000205	What is the difference between fragmentation and replication strategies mentioned in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'What is the difference between fragmentation and replication strategies mentioned in the paragraph?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000206	Can you summarize the transactional system described in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'Can you summarize the transactional system described in the paragraph?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000207	What are the four basic operations (CRUD) available in MongoDB, as stated in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'What are the four basic operations (CRUD) available in MongoDB, as stated in the paragraph?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000208	Does the paragraph mention anything about distribution and replication strategies?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'Does the paragraph mention anything about distribution and replication strategies?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000209	What is the purpose of the bibliography section at the end of the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'What is the purpose of the bibliography section at the end of the paragraph?'  
C002100002	Introduccion a MongoDB	Índice	synthetic_question	Introducción............................................................................................... 1. Introducción a MongoDB................................................................ 1.1. Versiones ...................................................................................... 1.2. Motores de almacenamiento soportados .................................... 8 1.3. Estrategias de fragmentación y replicación permitidas ............... 8 2. Modelo de datos.................................................................................. 3. Sistema transaccional....................................................................... 4. Operaciones CRUD............................................................................. 5. Estrategias de distribución y replicación.................................... Bibliografía.................................................................................................	C00210000210	In which year was MongoDB first released, according to the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Índice'; content: 'In which year was MongoDB first released, according to the paragraph?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000301	What is the main purpose of MongoDB according to the introduction?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'What is the main purpose of MongoDB according to the introduction?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000302	What type of database does MongoDB offer?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'What type of database does MongoDB offer?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000303	What is the advantage of using MongoDB over traditional relational databases?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'What is the advantage of using MongoDB over traditional relational databases?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000304	How does MongoDB handle data distribution and replication?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'How does MongoDB handle data distribution and replication?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000305	Can you describe the transactionality level offered by MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'Can you describe the transactionality level offered by MongoDB?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000306	What operations can be performed on data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'What operations can be performed on data in MongoDB?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000307	How can you configure the consistency and availability of a MongoDB database?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'How can you configure the consistency and availability of a MongoDB database?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000308	What components make up a distributed and replicated MongoDB database?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'What components make up a distributed and replicated MongoDB database?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000309	What strategies does MongoDB use for distributing and replicating data?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'What strategies does MongoDB use for distributing and replicating data?'  
C002100003	Introduccion a MongoDB	Introducción	synthetic_question	MongoDB es actualmente la base de datos NoSQL de agregación documental más popular. Esta base de datos ofrece un entorno de trabajo que otorga una gran flexibilidad a las aplicaciones que acceden a sus datos, permitiendo una gestión de datos distribuida, replicación de datos, un cierto nivel de transaccionalidad, una disponibilidad y consistencia configurables y un lenguaje de acceso y manipulación de datos potente. Este material pretende ofrecer a los lectores, con conocimientos generales de bases de datos NoSQL, una introducción a MongoDB. En particular, se introduce la base de datos, sus principales características y el modelo de datos que utiliza. Posteriormente, se explica cómo gestiona las transacciones MongoDB y se introducen las principales operaciones que ofrece MongoDB para consultar, actualizar, modificar y eliminar datos. Finalmente, se detallan las estrategias de distribución y replicación que utiliza, se indica cómo configurar la consistencia y disponibilidad de la base de datos y qué componentes componen una base de datos MongoDB distribuida y replicada. Este material sienta las bases conceptuales sobre MongoDB para que los lectores puedan profundizar en el uso de MongoDB en futuros materiales.	C00210000310	How does MongoDB provide flexibility to applications accessing its data?	passage: document 'Introduccion a MongoDB'; paragraph: 'Introducción'; content: 'How does MongoDB provide flexibility to applications accessing its data?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000401	What is the name of the company that created MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'What is the name of the company that created MongoDB?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000402	When was MongoDB released as open-source software?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'When was MongoDB released as open-source software?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000403	What is the unit of storage in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'What is the unit of storage in MongoDB?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000404	How does MongoDB store data?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'How does MongoDB store data?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000405	What is the default data structure used in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'What is the default data structure used in MongoDB?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000406	Can you create an index on text or coordinates in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'Can you create an index on text or coordinates in MongoDB?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000407	Does MongoDB provide APIs and drivers for various programming languages?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'Does MongoDB provide APIs and drivers for various programming languages?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000408	In what year did MongoDB become one of the most popular databases according to DB-Engines?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'In what year did MongoDB become one of the most popular databases according to DB-Engines?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000409	Is MongoDB a NoSQL database?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'Is MongoDB a NoSQL database?'  
C002100004	Introduccion a MongoDB	1. Introducción a MongoDB	synthetic_question	MongoDB es una base de datos documental creada en 2007 por la empresa 10gen, ahora MongoDB Inc. MongoDB fue creada como un componente para un sistema Platform as a Service (PaaS), o plataforma como servicio. En 2009, la empresa decidió evolucionar la base de datos a código abierto, liberando MongoDB y ofreciendo soporte comercial para la misma. Desde ese momento se ha convertido en una de las bases de datos NoSQL más populares. De hecho, en 2022 es la quinta base de datos más popular (de 383) según el ranking de DB-Engines,1 siendo la base de datos NoSQL más popular según dicha clasificación. MongoDB sigue un modelo de datos de agregación orientado a documentos y schemaless. Por lo tanto, la unidad básica de almacenamiento en MongoDB son los documentos y no es necesario crear a priori el esquema de datos de los documentos que se van a almacenar. En MongoDB los documentos se almacenan en formato BSON, que es una estructura JSON en formato binario con soporte para los tipos de datos básicos. Proporciona varios tipos de índices que permiten indexar, además de la información más común, texto y coordenadas geográficas. Asimismo, MongoDB proporciona API y drivers para gran cantidad de lenguajes de programación actuales, facilitando su uso sea cual sea el lenguaje que utilice el programa cliente que desea acceder a los datos.	C00210000410	What is the name of the paragraph we are analyzing?	passage: document 'Introduccion a MongoDB'; paragraph: '1. Introducción a MongoDB'; content: 'What is the name of the paragraph we are analyzing?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000501	What is the development language of MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'What is the development language of MongoDB?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000502	In which operating systems is MongoDB available?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'In which operating systems is MongoDB available?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000503	What are the two versions of MongoDB offered by the company?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'What are the two versions of MongoDB offered by the company?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000504	What is the difference between MongoDB Community and MongoDB Enterprise?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'What is the difference between MongoDB Community and MongoDB Enterprise?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000505	Does MongoDB Enterprise offer additional features compared to MongoDB Community?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'Does MongoDB Enterprise offer additional features compared to MongoDB Community?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000506	What are some of the enterprise-focused features included in MongoDB Enterprise?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'What are some of the enterprise-focused features included in MongoDB Enterprise?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000507	Is there a subscription required for using MongoDB Enterprise?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'Is there a subscription required for using MongoDB Enterprise?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000508	Can LDAP and Kerberos be integrated with MongoDB Enterprise?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'Can LDAP and Kerberos be integrated with MongoDB Enterprise?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000509	Does MongoDB provide disk encryption in its Enterprise version?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'Does MongoDB provide disk encryption in its Enterprise version?'  
C002100005	Introduccion a MongoDB	1.1. Versiones	synthetic_question	MongoDB está desarrollado en C++ y está disponible en multitud de sistemas operativos: Linux, Windows, OS X y Solaris. MongoDB se ofrece en dos versiones: • MongoDB Community: edición gratuita de MongoDB con disponibilidad de uso del código fuente. • MongoDB Enterprise: disponible como parte de la suscripción a MongoDB Enterprise Advanced e incluye soporte completo para la implementación de MongoDB. MongoDB Enterprise también agrega funciones centradas en la empresa, como compatibilidad con LDAP y Kerberos, cifrado en disco y auditoría. __ | (1)<https://db-engines.com/en/ ranking>.	C00210000510	Are there any auditing capabilities available in MongoDB Enterprise?	passage: document 'Introduccion a MongoDB'; paragraph: '1.1. Versiones'; content: 'Are there any auditing capabilities available in MongoDB Enterprise?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000601	What is the purpose of the link provided in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'What is the purpose of the link provided in the paragraph?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000602	How can one access the data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'How can one access the data in MongoDB?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000603	Is it possible to write atomic operations on each document in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Is it possible to write atomic operations on each document in MongoDB?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000604	What is MongoDB Atlas, and what does it offer?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'What is MongoDB Atlas, and what does it offer?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000605	Can one host a MongoDB database on the cloud using MongoDB Atlas?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Can one host a MongoDB database on the cloud using MongoDB Atlas?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000606	Does MongoDB provide an official console for accessing and managing databases?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Does MongoDB provide an official console for accessing and managing databases?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000607	Are there any third-party graphical consoles available for working with MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Are there any third-party graphical consoles available for working with MongoDB?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000608	Can one use APIs to interact with MongoDB data programmatically?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Can one use APIs to interact with MongoDB data programmatically?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000609	What kind of data can be consulted through the console or APIs in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'What kind of data can be consulted through the console or APIs in MongoDB?'  
C002100006	Introduccion a MongoDB	API y drivers de MongoDB	synthetic_question	Para tener información actualizada sobre los drivers disponibles, podéis consultar el siguiente enlace: <https:// docs.mongodb.com/drivers/>. Los datos se pueden consultar bien utilizando la consola del sistema, a través de consolas externas gráficas (como por ejemplo Studio3T)2 o a través de un programa utilizando una de las múltiples API que proporciona. Por defecto, las escrituras de los documentos se realizan de forma atómica en la base de datos para cada documento. MongoDB también ofrece Atlas, una opción de servicio de MongoDB Enterprise que permite alojar y acceder a una base de datos MongoDB alojada en la nube y que, por tanto, no requiere gastos generales de instalación ni de mantenimiento de servidor.	C00210000610	Are there any default settings for writing data to MongoDB documents?	passage: document 'Introduccion a MongoDB'; paragraph: 'API y drivers de MongoDB'; content: 'Are there any default settings for writing data to MongoDB documents?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000701	What is the purpose of the Motor de Almacenamiento in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'What is the purpose of the Motor de Almacenamiento in MongoDB?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000702	Which motor de almacenamiento is predetermined in MongoDB since version 3.2?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'Which motor de almacenamiento is predetermined in MongoDB since version 3.2?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000703	How does WiredTiger offer advanced concurrency features?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'How does WiredTiger offer advanced concurrency features?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000704	Does In-Memory Storage Engine require an index file on disk?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'Does In-Memory Storage Engine require an index file on disk?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000705	What is the primary advantage of using In-Memory Storage Engine in MongoDB Enterprise?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'What is the primary advantage of using In-Memory Storage Engine in MongoDB Enterprise?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000706	Can WiredTiger compress data stored in MongoDB collections?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'Can WiredTiger compress data stored in MongoDB collections?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000707	Is encryption available for data stored in MongoDB using WiredTiger?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'Is encryption available for data stored in MongoDB using WiredTiger?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000708	How do the functionalities of WiredTiger differ from those of In-Memory Storage Engine?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'How do the functionalities of WiredTiger differ from those of In-Memory Storage Engine?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000709	When was the MMAPv1 engine considered obsolete in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'When was the MMAPv1 engine considered obsolete in MongoDB?'  
C002100007	Introduccion a MongoDB	1.2. Motores de almacenamiento soportados	synthetic_question	El motor de almacenamiento es el componente de la base de datos que se encarga de administrar cómo se almacenan los datos, tanto en la memoria como en el disco duro. MongoDB admite múltiples motores de almacenamiento, ya que diferentes motores pueden funcionar mejor para cargas de trabajo, máquinas o situaciones específicas. La elección del motor de almacenamiento adecuado para cada situación puede afectar significativamente el rendimiento del sistema. Inicialmente, MongoDB utilizaba el motor MMAPv1, que desde la versión 4.0 se considera obsoleto y que se ha eliminado a partir de la versión 4.2. En el año 2022, MongoDB ofrece dos motores de almacenamiento, uno para almacenar los datos en disco y otro para almacenar los datos en memoria: • WiredTiger es el motor de almacenamiento predeterminado que se empieza a utilizar desde la versión 3.2. WiredTiger ofrece funciones de concurrencia avanzadas, así como compresión, cifrado y otras funciones internas. Cada colección y cada índice requieren un archivo en disco. • In-Memory Storage Engine es el motor de almacenamiento en memoria disponible en MongoDB Enterprise. En lugar de almacenar documentos en disco, los retiene en memoria para lograr latencias de datos más predecibles.	C00210000710	As of which version of MongoDB did the company start offering two storage engines?	passage: document 'Introduccion a MongoDB'; paragraph: '1.2. Motores de almacenamiento soportados'; content: 'As of which version of MongoDB did the company start offering two storage engines?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000801	What type of fragmentation does MongoDB provide?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'What type of fragmentation does MongoDB provide?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000802	Can the fragmentation in MongoDB be defined by the database designer?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Can the fragmentation in MongoDB be defined by the database designer?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000803	Does MongoDB have automatic fragmentation distribution?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Does MongoDB have automatic fragmentation distribution?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000804	How does MongoDB's automatic fragmentation distribution work?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'How does MongoDB's automatic fragmentation distribution work?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000805	Is there a difference between horizontal fragmentation and auto-sharding in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Is there a difference between horizontal fragmentation and auto-sharding in MongoDB?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000806	Can the person designing the database define the origin of the fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Can the person designing the database define the origin of the fragmentation in MongoDB?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000807	What are some characteristics of replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'What are some characteristics of replication in MongoDB?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000808	Does MongoDB support both manual and automatic replication?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Does MongoDB support both manual and automatic replication?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000809	Can the person designing the database control the replication process in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Can the person designing the database control the replication process in MongoDB?'  
C002100008	Introduccion a MongoDB	1.3. Estrategias de fragmentación y replicación permitidas	synthetic_question	MongoDB proporciona características de replicación y fragmentación. Respecto a la fragmentación, MongoDB permite realizar una fragmentación horizontal, definida por la persona diseñadora, que tenga su origen en algunos atributos de la base de datos y una fragmentación automática (o auto-sharding) que distribuya los documentos automáticamente entre los distintos nodos.	C00210000810	Are there any limitations or restrictions on using fragmentation and replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '1.3. Estrategias de fragmentación y replicación permitidas'; content: 'Are there any limitations or restrictions on using fragmentation and replication in MongoDB?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000901	What is the default replication system used by MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'What is the default replication system used by MongoDB?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000902	How does MongoDB ensure data consistency across replicas?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'How does MongoDB ensure data consistency across replicas?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000903	In what situations may MongoDB become partially inoperative due to network partitions?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'In what situations may MongoDB become partially inoperative due to network partitions?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000904	What is the purpose of the quorum-based replication management system in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'What is the purpose of the quorum-based replication management system in MongoDB?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000905	Can the behavior of the database be adapted to different needs using the quorum-based replication management system?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'Can the behavior of the database be adapted to different needs using the quorum-based replication management system?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000906	What is the relationship between consistency and availability in MongoDB's replication strategy?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'What is the relationship between consistency and availability in MongoDB's replication strategy?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000907	How does MongoDB handle fragmentation, and what are some strategies for managing it?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'How does MongoDB handle fragmentation, and what are some strategies for managing it?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000908	"What is figure 1 in the ""Estrategias de distribución y replicación"" section of this module, and what does it represent?"	"passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'What is figure 1 in the ""Estrategias de distribución y replicación"" section of this module, and what does it represent?'  "
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000909	Can the system be configured to prioritize availability over consistence, or vice versa?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'Can the system be configured to prioritize availability over consistence, or vice versa?'  
C002100009	Introduccion a MongoDB	<https://studio3t.com>.	synthetic_question	(2)<https://studio3t.com>. Respecto a la replicación, sigue un sistema de tipo nodo primario / nodo secundario (o master slave) asíncrono en el que una escritura, por defecto, se considera duradera cuando se ha escrito en la mayoría de las réplicas. Por lo tanto, respecto a las tres propiedades del teorema CAP (consistencia, disponibilidad y tolerancia a particiones), MongoDB está enfocado a mantener la consistencia de las réplicas de unos mismos datos y la tolerancia a particiones. Esto quiere decir que, en algunas situaciones, el sistema puede quedar parcialmente inoperativo en caso de particiones en la red. No obstante, MongoDB utiliza un sistema de gestión de réplicas orientado a cuórums, que puede configurarse para adaptar el comportamiento de la base de datos a distintas necesidades, permitiendo promocionar la disponibilidad a costa de relajar la consistencia. En el apartado «5. Estrategias de distribución y replicación» de este módulo se da más información sobre la fragmentación en MongoDB, y sobre cómo ajustarla a distintas necesidades de datos. Nota figura 1 Por defecto, el sistema contiene una visión consistente de los datos, aunque no esté totalmente disponible en presencia de particiones.	C00210000910	What are some potential trade-offs between consistency, availability, and partition tolerance in MongoDB's replication strategy?	passage: document 'Introduccion a MongoDB'; paragraph: '<https://studio3t.com>.'; content: 'What are some potential trade-offs between consistency, availability, and partition tolerance in MongoDB's replication strategy?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001001	What is the main purpose of MongoDB's data storage components?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'What is the main purpose of MongoDB's data storage components?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001002	How does MongoDB structure its data within each collection?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'How does MongoDB structure its data within each collection?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001003	Can you explain the difference between a database and a collection in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Can you explain the difference between a database and a collection in MongoDB?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001004	How do documents in MongoDB contain both structured and unstructured data?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'How do documents in MongoDB contain both structured and unstructured data?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001005	What is the significance of using a hierarchical structure for storing data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'What is the significance of using a hierarchical structure for storing data in MongoDB?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001006	In what way does MongoDB use a relational model as a basis for its data storage?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'In what way does MongoDB use a relational model as a basis for its data storage?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001007	How do indexes and constraints contribute to maintaining data integrity in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'How do indexes and constraints contribute to maintaining data integrity in MongoDB?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001008	Can you describe an example scenario where using a document-based data model like MongoDB would be beneficial?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Can you describe an example scenario where using a document-based data model like MongoDB would be beneficial?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001009	How does the use of BSON format affect the efficiency of data storage and retrieval in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'How does the use of BSON format affect the efficiency of data storage and retrieval in MongoDB?'  
C002100010	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Una vez introducidas las características generales de MongoDB, se verá más en detalle su modelo de datos. Para ello, se estudiará cómo estructura sus datos y sus equivalencias con las bases de datos relacionales, se verá cómo modelar en MongoDB el caso de la cesta de la compra, se introducirán los índices y las restricciones de integridad que soporta y, finalmente, se tratará el formato de datos que utiliza. Para explicar el modelo de datos de MongoDB, se utilizará el modelo relacional como base. Fuente: elaboración propia Los componentes de almacenamiento de MongoDB se estructuran de forma jerárquica del siguiente modo: • Una instancia de MongoDB puede tener diferentes bases de datos. • Cada base de datos, a su vez, puede contener distintas colecciones. Las colecciones son el equivalente a las tablas del modelo relacional y se utilizan para agrupar elementos con semántica o características comunes como, por ejemplo, los pedidos de venta de una empresa. • Una colección contiene un conjunto de documentos. • Cada documento define un conjunto de datos para un individuo de la colección. En el caso de ejemplo, si la colección define a los clientes de una empresa, cada uno de sus documentos indicaría los datos relevantes de cada uno de sus clientes. Los documentos se almacenan en formato BSON y contienen un conjunto de campos (es decir, atributos o propiedades, o columnas en términos de una base de datos relacional). Cada campo consta de un nombre de campo y un valor asociado. Los documentos no necesitan seguir ningún tipo de esquema predeterminado. Es decir, distintos documentos de una misma colección pueden tener estructuras y campos diferentes. No obstante, es necesario recordar que, en las bases de datos basadas en el modelo de agregación, las consultas son las que dirigen el diseño de los agregados. Ello implica que el agregado, en este caso el documento, debe contener toda la información necesaria para poder resolver adecuadamente las consultas planteadas. Por ello, los documentos de cada colección comparten semántica, es decir, se corresponden a objetos de un mismo tipo o son respuesta a una misma pregunta del mundo real.	C00210001010	In what ways can the flexibility of MongoDB's data model be leveraged to accommodate changing business needs or requirements?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'In what ways can the flexibility of MongoDB's data model be leveraged to accommodate changing business needs or requirements?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001101	What is the primary key field in a MongoDB document?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'What is the primary key field in a MongoDB document?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001102	Can the value of the primary key field be informed by the user or generated automatically by the database?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Can the value of the primary key field be informed by the user or generated automatically by the database?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001103	What are embedded subdocuments in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'What are embedded subdocuments in MongoDB?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001104	How do embedded subdocuments affect data normalization in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'How do embedded subdocuments affect data normalization in MongoDB?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001105	Are there any alternatives to embedding subdocuments in the main document?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Are there any alternatives to embedding subdocuments in the main document?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001106	What is the equivalent of foreign keys in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'What is the equivalent of foreign keys in MongoDB?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001107	How can references to other documents be established in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'How can references to other documents be established in MongoDB?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001108	What is the purpose of the `$lookup` operator in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'What is the purpose of the `$lookup` operator in MongoDB?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001109	Can the `$lookup` operator be used to combine documents with referenced documents?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Can the `$lookup` operator be used to combine documents with referenced documents?'  
C002100011	Introduccion a MongoDB	2. Modelo de datos	synthetic_question	Todo documento tiene un campo que lo identifica unívocamente entre los demás documentos de la colección (lo que se conoce como clave primaria en el modelo relacional). Esta clave primaria se representa mediante el campo _id. Su valor puede ser informado por la persona usuaria o, en caso contrario, será asignado por la base de datos de forma automática. MongoDB permite definir (o, si se prefiere, incrustar) subdocumentos dentro de un documento (embedded subdocument). Estos subdocumentos son conjuntos de datos relacionados con el elemento a representar. Como consecuencia, los documentos que incorporan subdocumentos pueden ser vistos como documentos (u objetos) compuestos, de tal manera que se están aplicando técnicas de desnormalización de los datos que permiten evitar la ejecución de operaciones de JOIN del álgebra relacional para dar respuesta a una pregunta concreta. En caso de que no sea posible (o aconsejable) incrustar los subdocumentos en el documento principal, MongoDB también permite utilizar campos en los documentos que sean referencias a otros documentos, lo que sería el equivalente a las claves foráneas del modelo relacional. Dichas referencias pueden explotarse de forma manual o mediante operaciones de combinación en MongoDB, como por ejemplo la operación $lookup o derivadas.	C00210001110	Is it advisable to use embedded subdocuments or reference fields to avoid joining operations in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2. Modelo de datos'; content: 'Is it advisable to use embedded subdocuments or reference fields to avoid joining operations in MongoDB?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001201	What is the main topic discussed in the example given in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the main topic discussed in the example given in the paragraph?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001202	What is the purpose of the example in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the purpose of the example in the paragraph?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001203	Which elements of MongoDB does the example describe?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Which elements of MongoDB does the example describe?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001204	In which module was the previous example seen before?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'In which module was the previous example seen before?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001205	What type of application is being used in the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What type of application is being used in the example?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001206	What is the focus of the paragraph's discussion?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the focus of the paragraph's discussion?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001207	Can you summarize the key points mentioned in the paragraph about MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Can you summarize the key points mentioned in the paragraph about MongoDB?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001208	How does the example relate to the previous module?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'How does the example relate to the previous module?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001209	What is the significance of the example in understanding MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the significance of the example in understanding MongoDB?'  
C002100012	Introduccion a MongoDB	Ejemplo	synthetic_question	A continuación se verán con un ejemplo los distintos elementos de MongoDB que se acaban de describir retomando el ejemplo visto en un módulo anterior, correspondiente a una aplicación de e-commerce.	C00210001210	Based on the example, what are some potential uses of MongoDB in an e-commerce application?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Based on the example, what are some potential uses of MongoDB in an e-commerce application?'  
C002100013	Introduccion a MongoDB	lookup	synthetic_question	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	C00210001301	What is the main purpose of the lookup operation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'lookup'; content: 'What is the main purpose of the lookup operation in MongoDB?'  
C002100013	Introduccion a MongoDB	lookup	synthetic_question	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	C00210001302	According to the example document, what is the primary key used in the Order collection?	passage: document 'Introduccion a MongoDB'; paragraph: 'lookup'; content: 'According to the example document, what is the primary key used in the Order collection?'  
C002100013	Introduccion a MongoDB	lookup	synthetic_question	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	C00210001303	How does the example document structure reflect the needs of the application and the characteristics of the database engine?	passage: document 'Introduccion a MongoDB'; paragraph: 'lookup'; content: 'How does the example document structure reflect the needs of the application and the characteristics of the database engine?'  
C002100013	Introduccion a MongoDB	lookup	synthetic_question	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	C00210001304	What type of data is stored in the references field in the example document?	passage: document 'Introduccion a MongoDB'; paragraph: 'lookup'; content: 'What type of data is stored in the references field in the example document?'  
C002100013	Introduccion a MongoDB	lookup	synthetic_question	Descripción de la operación lookup en el manual de MongoDB: <https:// docs.mongodb.com/manual/ reference/operator/aggregation/ lookup/>. Fuente: elaboración propia El desafío clave en el modelado de datos es equilibrar las necesidades de la aplicación, las características de rendimiento del motor de la base de datos y los patrones de recuperación de datos. Al diseñar modelos de datos, siempre se debe considerar el uso de los datos por parte de la aplicación (es decir, consultas, actualizaciones y procesamiento de los datos), así como la estructura inherente de los datos en sí. A continuación se expone un ejemplo de documento que representa un pedido de venta. Los diferentes pedidos se almacenarán en una colección denominada Order. Cada pedido estará representado por un documento. El documento de ejemplo contiene una clave primaria (_id) con valor 10001, un campo que permite indicar la fecha en la que se efectúa el pedido y un par de referencias que apuntan a los documentos que contienen información del cliente que realizó el pedido, y de los datos del pago. Fuente: elaboración propia Estas referencias podrían haberse definido de forma distinta, ya que podría haber incluido toda la información del cliente y de los datos de pago dentro del documento actual. No obstante, por decisiones de diseño, se ha preferido utilizar referencias, y gestionar los datos de clientes y de pago mediante documentos (y, en consecuencia, colecciones) aparte. En el pedido también se pueden ver ejemplos de subdocumentos incrustados como, por ejemplo, las líneas del pedido y la dirección de envío del pedido.	C00210001305	Why might it be beneficial to use separate collections for storing information about clients and payment details instead of including all the information within the order document itself?	passage: document 'Introduccion a MongoDB'; paragraph: 'lookup'; content: 'Why might it be beneficial to use separate collections for storing information about clients and payment details instead of including all the information within the order document itself?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001401	What is the structure of MongoDB documents?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'What is the structure of MongoDB documents?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001402	Can MongoDB documents include other documents?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Can MongoDB documents include other documents?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001403	Do MongoDB documents support arrays or lists?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Do MongoDB documents support arrays or lists?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001404	Are there any restrictions on the types of values that can be stored in a MongoDB document?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Are there any restrictions on the types of values that can be stored in a MongoDB document?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001405	How does MongoDB handle nested data structures such as objects and arrays?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'How does MongoDB handle nested data structures such as objects and arrays?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001406	Is it possible to store multiple documents within a single collection in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Is it possible to store multiple documents within a single collection in MongoDB?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001407	Can MongoDB documents contain missing or null values?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Can MongoDB documents contain missing or null values?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001408	How does MongoDB enforce data consistency across multiple documents in a collection?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'How does MongoDB enforce data consistency across multiple documents in a collection?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001409	What is the maximum size limit for a MongoDB document?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'What is the maximum size limit for a MongoDB document?'  
C002100014	Introduccion a MongoDB	2.1. Estructura de los documentos	synthetic_question	Los documentos de MongoDB son similares a los objetos JSON. Los valores de los campos pueden incluir otros documentos, matrices y matrices de do-	C00210001410	Can MongoDB documents be indexed for faster querying?	passage: document 'Introduccion a MongoDB'; paragraph: '2.1. Estructura de los documentos'; content: 'Can MongoDB documents be indexed for faster querying?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001501	What is the topic of the current paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'What is the topic of the current paragraph?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001502	What is the name of the document being introduced in this paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'What is the name of the document being introduced in this paragraph?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001503	What is the name of the paragraph within this document?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'What is the name of the paragraph within this document?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001504	Who is the author of the document?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'Who is the author of the document?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001505	What is the main idea of the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'What is the main idea of the paragraph?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001506	According to the paragraph, what is the purpose of comments in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'According to the paragraph, what is the purpose of comments in MongoDB?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001507	How does the author suggest implementing the comment feature in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'How does the author suggest implementing the comment feature in MongoDB?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001508	"What is the significance of the phrase ""fuente: elaboración propia"" in the paragraph?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'What is the significance of the phrase ""fuente: elaboración propia"" in the paragraph?'  "
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001509	In which section of the document is this paragraph located?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'In which section of the document is this paragraph located?'  
C002100015	Introduccion a MongoDB	cumentos.	synthetic_question	La implementación del modelo anterior sería la siguiente (figura 5). Fuente: elaboración propia	C00210001510	Does the paragraph contain any references or citations?	passage: document 'Introduccion a MongoDB'; paragraph: 'cumentos.'; content: 'Does the paragraph contain any references or citations?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001601	What type of database does MongoDB provide?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'What type of database does MongoDB provide?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001602	What allows MongoDB to validate data integrity?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'What allows MongoDB to validate data integrity?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001603	Where do MongoDB's data integrity rules execute?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'Where do MongoDB's data integrity rules execute?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001604	How can you specify data integrity rules when creating a new collection?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'How can you specify data integrity rules when creating a new collection?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001605	What is an example of using data integrity rules in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'What is an example of using data integrity rules in MongoDB?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001606	Can you create a collection without specifying data integrity rules in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'Can you create a collection without specifying data integrity rules in MongoDB?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001607	Will MongoDB automatically validate data integrity for all collections?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'Will MongoDB automatically validate data integrity for all collections?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001608	Is it possible to add data integrity rules after a collection has been created in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'Is it possible to add data integrity rules after a collection has been created in MongoDB?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001609	How do data integrity rules affect the creation of new documents in a collection in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'How do data integrity rules affect the creation of new documents in a collection in MongoDB?'  
C002100016	Introduccion a MongoDB	2.2. Validación del esquema	synthetic_question	Aunque MongoDB sea una base de datos de tipo schemaless, también proporciona mecanismos para integrar restricciones de integridad en las colecciones, permitiendo validar que los datos de una colección cumplan con determinadas condiciones que garanticen su validez. Las reglas de integridad en MongoDB se ejecutarán a nivel de colección. Para especificar reglas de integridad al crear una nueva colección, se debe emplear db.createCollection() con la opción de validación. A continuación, se ofrece un ejemplo.	C00210001610	Can you modify existing documents to satisfy data integrity rules in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.2. Validación del esquema'; content: 'Can you modify existing documents to satisfy data integrity rules in MongoDB?'  
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001701	"What type of data should be stored in the ""date"" field according to the provided JSON schema?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'What type of data should be stored in the ""date"" field according to the provided JSON schema?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001702	"Which field in the ""orders"" collection is defined as an array of objects?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'Which field in the ""orders"" collection is defined as an array of objects?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001703	"What is the data type of the ""units"" field in the ""orderLines"" array?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'What is the data type of the ""units"" field in the ""orderLines"" array?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001704	"Can the ""customer"" field be missing or null in the ""orders"" collection?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'Can the ""customer"" field be missing or null in the ""orders"" collection?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001705	"What is the purpose of the ""$jsonSchema"" validator in the provided example?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'What is the purpose of the ""$jsonSchema"" validator in the provided example?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001706	"Is the ""totalPrice"" field mandatory in the ""orderLines"" array?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'Is the ""totalPrice"" field mandatory in the ""orderLines"" array?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001707	"How many strings must be present in the ""orderLines"" array?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'How many strings must be present in the ""orderLines"" array?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001708	"What is the data type of the ""product"" field in the ""orderLines"" array?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'What is the data type of the ""product"" field in the ""orderLines"" array?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001709	"Must the ""orderLines"" array contain at least one object with a ""name"" field?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'Must the ""orderLines"" array contain at least one object with a ""name"" field?'  "
C002100017	Introduccion a MongoDB	"db.createCollection.  db.createCollection ( ""Orders"",{"	synthetic_question	"validator:{ $jsonSchema:{ bsonType: ""object"", required: [""date"",""customer"",""orderLines""], properties:{ _id: { }, date:{ bsonType: ""string"", description: ""'date' is a required string"" }, customer: { bsonType: ""string"", description: ""'customer' is a required string"" }, orderLines: { bsonType: ""array"", items: { bsonType: [""object""], required: [ ""product"",""units"",""totalPrice"" ], properties: { product: { bsonType: ""object"", required: [ ""name"" ], properties: { name: { bsonType: ""string"", description: ""must be a string and is required"" } } }, units:{ bsonType: ""int"","	C00210001710	"According to the provided JSON schema, what is the minimum number of fields required in each object within the ""orderLines"" array?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.createCollection.  db.createCollection ( ""Orders"",{'; content: 'According to the provided JSON schema, what is the minimum number of fields required in each object within the ""orderLines"" array?'  "
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001801	"What type of data should be stored in the ""date"" field according to the given example?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'What type of data should be stored in the ""date"" field according to the given example?'  "
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001802	Can you identify the primary key attributes in the provided JSON schema?	passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'Can you identify the primary key attributes in the provided JSON schema?'  
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001803	How many arrays does the provided JSON schema contain?	passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'How many arrays does the provided JSON schema contain?'  
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001804	"What is the data type of the ""totalPrice"" attribute in the provided JSON schema?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'What is the data type of the ""totalPrice"" attribute in the provided JSON schema?'  "
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001805	Which attributes in the provided JSON schema have a description?	passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'Which attributes in the provided JSON schema have a description?'  
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001806	"What is the purpose of the ""validationLevel"" option in the provided example?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'What is the purpose of the ""validationLevel"" option in the provided example?'  "
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001807	What happens if an operation violates the defined integrity constraints, according to the provided example?	passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'What happens if an operation violates the defined integrity constraints, according to the provided example?'  
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001808	Can you list all the mandatory attributes in the provided JSON schema?	passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'Can you list all the mandatory attributes in the provided JSON schema?'  
C002100018	Introduccion a MongoDB	validator:{.  $jsonSchema:{	synthetic_question	"bsonType: ""object"", description: ""must be a integer and is required"" }, totalPrice:{ bsonType: ""double"", description: ""must be a double and is required"" } } } } } } } }); En este ejemplo se indica que los atributos date, customer y orderLines son obligatorios y que date y customer son de tipo string. Asimismo, orderLines es un array que contiene los siguientes atributos: product (de tipo object), units (de tipo entero) y totalPrice (de tipo real). Finalmente, cabe destacar que para cada elemento product se requiere un atributo name (de tipo string). Si se quieren añadir reglas de integridad a una colección ya existente, se debe usar el comando collMod con la opción de validación. A continuación, se ofrece un ejemplo. db.runCommand( { collMod: ""Payments"", validator: { $jsonSchema: { bsonType: ""object"", required: [ ""paymentMethod"", ""creditCardNumber"" ], properties: { paymentMethod: { bsonType: ""string"", description: ""must be a string and is required"" }, creditCardNumber: { bsonType: ""string"", description: ""must be a string and is required"" } } } }, validationLevel: ""moderate"" } ) En caso de que alguna de las restricciones definidas no se cumpla a la hora de insertar o modificar un documento, el sistema gestor de bases de datos podrá rechazar la operación o permitir la operación, pero indicando que se ha violado la restricción de integridad definida. Para configurarlo de una forma u otra se pueden utilizar las siguientes opciones: validationLevel: determina cuán estrictamente MongoDB aplica las reglas de validación a los documentos existentes durante una actualización. • validationAction: determina si MongoDB debe generar errores y rechazar los documentos que violan las reglas de validación, o bien aceptar sus datos advirtiendo sobre las violaciones incurridas."	C00210001809	"What is the difference between ""validationAction"" and ""validationLevel"" in the provided example?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'validator:{.  $jsonSchema:{'; content: 'What is the difference between ""validationAction"" and ""validationLevel"" in the provided example?'  "
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001901	What type of indexing does MongoDB use to optimize data access?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What type of indexing does MongoDB use to optimize data access?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001902	How many types of indexes can be created in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How many types of indexes can be created in MongoDB?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001903	What is the default index created by MongoDB for each collection?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What is the default index created by MongoDB for each collection?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001904	Can duplicate values be included in an index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'Can duplicate values be included in an index in MongoDB?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001905	What is an example of a sparse index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What is an example of a sparse index in MongoDB?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001906	How do language-specific collations affect text indices in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How do language-specific collations affect text indices in MongoDB?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001907	What is the purpose of the unique index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What is the purpose of the unique index in MongoDB?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001908	How can an index be defined to include only specific fields in a document?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How can an index be defined to include only specific fields in a document?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001909	What is the difference between an ascending and descending index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What is the difference between an ascending and descending index in MongoDB?'  
C002100019	Introduccion a MongoDB	2.3. Índices	synthetic_question	MongoDB utiliza distintos índices para optimizar el acceso a datos y evitar consultar todos los documentos de una colección para satisfacer las consultas. Los índices se definen a nivel de colección. Por defecto, para cada colección siempre se crea un índice único sobre su clave primaria, es decir, sobre el campo _id. Eso evita que se puedan dar de alta, en una colección, dos documentos con el mismo identificador. MongoDB contiene una gran variedad de índices que pueden clasificarse según el número de campos indexados (sobre un campo, sobre un conjunto de campos o sobre un campo que contiene una lista de valores –un array o subdocumento incrustado–) y según el tipo de datos indexados (índices espaciales o de texto, básicamente). Los índices en MongoDB pueden definirse como unique y sparse. Los índices únicos no permiten valores duplicados. Los índices sparse no almacenan entradas en el índice para los documentos que no tienen valores para los campos indexados. Este último tipo de índice puede ser muy conveniente debido a la falta de esquema de los documentos. Los índices de texto permiten indexar cualquier campo cuyo valor sea de tipo string o un array de elementos de tipo string. En el caso de los índices de texto, se puede especificar el idioma mediante la opción collation. Eso permitirá que los índices consideren las reglas idiomáticas, como mayúsculas, plurales y acentos, en las operaciones de comparación de cadenas de texto. Para se comando db.collection.createIndex(<keys>,<options>) con los parámetros: • keys: documento JSON con pares de atributos clave-valor, donde la clave especifica qué campos forman parte de la clave del índice y el valor describe el orden del índice para ese campo. Para un índice ascendente se especifica un valor de 1 y para un índice descendente -1.	C00210001910	How can an index be created using the createIndex() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How can an index be created using the createIndex() method in MongoDB?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002001	What is the purpose of creating an index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What is the purpose of creating an index in MongoDB?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002002	What type of index does MongoDB support for geospatial queries?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What type of index does MongoDB support for geospatial queries?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002003	How do you create a unique index in MongoDB using the command line interface?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How do you create a unique index in MongoDB using the command line interface?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002004	"In which field of the collection ""Customers"" did you create a unique index in the example given?"	"passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'In which field of the collection ""Customers"" did you create a unique index in the example given?'  "
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002005	Can you explain the difference between a 2D index and a 2DSphere index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'Can you explain the difference between a 2D index and a 2DSphere index in MongoDB?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002006	When would it be convenient to create a GeoHaystack index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'When would it be convenient to create a GeoHaystack index in MongoDB?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002007	How do you specify the spatial reference system (SRS) for a GeoHaystack index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How do you specify the spatial reference system (SRS) for a GeoHaystack index in MongoDB?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002008	What is the default SRS used by MongoDB for geospatial queries if no SRS is specified?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'What is the default SRS used by MongoDB for geospatial queries if no SRS is specified?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002009	Can you describe the benefits of using a unique index in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'Can you describe the benefits of using a unique index in MongoDB?'  
C002100020	Introduccion a MongoDB	2.3. Índices	synthetic_question	"options: define el nombre del índice y otras propiedades como el tipo de índice, unique, sparse, collation. Para consultar información geoespacial es conveniente crear un índice sobre las coordenadas a utilizar durante la búsqueda. MongoDB admite tres tipos de índices para consultas geoespaciales: 2d, 2dsphere y Geo Haystack.3 A continuación, un ejemplo de creación de un índice único sobre el campo name de la colección Customers: db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	C00210002010	How do you drop all indexes created on a collection in MongoDB using the command line interface?	passage: document 'Introduccion a MongoDB'; paragraph: '2.3. Índices'; content: 'How do you drop all indexes created on a collection in MongoDB using the command line interface?'  
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002101	What is the purpose of creating an index in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'What is the purpose of creating an index in MongoDB?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002102	How does the `unique` parameter work in the `createIndex()` method?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'How does the `unique` parameter work in the `createIndex()` method?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002103	In which version of MongoDB was the `discontinuous` index removed?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'In which version of MongoDB was the `discontinuous` index removed?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002104	Can you create an index on multiple columns in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'Can you create an index on multiple columns in MongoDB?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002105	Is it possible to create a compound index in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'Is it possible to create a compound index in MongoDB?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002106	How do you specify the order of columns in an index in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'How do you specify the order of columns in an index in MongoDB?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002107	Can you drop an index in MongoDB using the `dropIndex()` method?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'Can you drop an index in MongoDB using the `dropIndex()` method?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002108	How do you check if an index exists in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'How do you check if an index exists in MongoDB?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002109	Can you create a unique index on a specific column in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'Can you create a unique index on a specific column in MongoDB?'  "
C002100021	Introduccion a MongoDB	"db.Customers.createIndex( { ""name"": 1 }, { unique: true } );"	synthetic_question	(3)Este último índice está discontinuado y se ha eliminado a partir de MongoDB 5.0.	C00210002110	How do you update an existing index in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.createIndex( { ""name"": 1 }, { unique: true } );'; content: 'How do you update an existing index in MongoDB?'  "
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002201	What is the current state of transactional management in MongoDB as of 2021?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'What is the current state of transactional management in MongoDB as of 2021?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002202	How does MongoDB handle transactions at different levels?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'How does MongoDB handle transactions at different levels?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002203	What is the default behavior of MongoDB when it comes to concurrent access to documents?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'What is the default behavior of MongoDB when it comes to concurrent access to documents?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002204	Can multiple clients modify different documents within the same collection simultaneously?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'Can multiple clients modify different documents within the same collection simultaneously?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002205	How does MongoDB ensure data consistency during concurrent modifications?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'How does MongoDB ensure data consistency during concurrent modifications?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002206	What is the purpose of the MVCC system in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'What is the purpose of the MVCC system in MongoDB?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002207	How do operations work in MongoDB using the console, Mongo shell, or APIs?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'How do operations work in MongoDB using the console, Mongo shell, or APIs?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002208	Are operations in MongoDB atomic at the document level?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'Are operations in MongoDB atomic at the document level?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002209	What happens if a document contains embedded subdocuments during an operation?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'What happens if a document contains embedded subdocuments during an operation?'  
C002100022	Introduccion a MongoDB	3. Sistema transaccional	synthetic_question	En MongoDB, la gestión de transacciones complejas se incorporó de forma tardía y aún está en vías de consolidación, con algunas características disponibles solo en las últimas versiones. A continuación se hace un breve repaso del funcionamiento transaccional de MongoDB y el estado actual del mismo a fecha de 2021. MongoDB usa un bloqueo de granularidad múltiple que permite, por defecto, bloqueos a tres niveles: global, de base de datos o de colección. Los motores de almacenamiento pueden implementar su propio control de concurrencia por debajo del nivel de colección, por ejemplo, a nivel de documento. WiredTiger permite utilizar control de concurrencia a nivel de documento para operaciones de escritura. Como resultado, varios clientes pueden modificar diferentes documentos de una misma colección al mismo tiempo. MongoDB utiliza un sistema de control de concurrencia multiversión (MVCC) que usa el aislamiento de instantáneas para implementar un control de concurrencia optimista. En MongoDB, los datos se pueden consultar y modificar bien utilizando la consola, Mongo shell, o a través de un programa utilizando una de las múltiples API que proporciona. Mediante Mongo shell las operaciones son de tipo autocommit. Es decir, cada operación se ejecuta en una única transacción. En MongoDB, una operación de escritura es atómica a nivel de un solo documento. En el caso de que un documento contenga subdocumentos incrustados, la transacción se ejecuta a nivel del documento principal y, por tanto, de forma atómica para todos sus subdocumentos. Cuando una operación de escritura modifica varios documentos, como por ejemplo db.collection.updateMany(), la modificación de cada documento es atómica, pero la operación en su conjunto no es atómica. Al realizar operaciones de escritura de varios documentos, ya sea a través de una sola operación de escritura o de varias operaciones de escritura, se pueden intercalar otras operaciones. Eso puede conllevar que aparezcan los típicos problemas de interferencias y que generen inconsistencias en la base de datos. Esta es la operación por defecto de MongoDB, pero puede modificarse utilizando transacciones de tipo multidocumento, como se verá a continuación.	C00210002210	Can multiple document updates be performed atomically in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3. Sistema transaccional'; content: 'Can multiple document updates be performed atomically in MongoDB?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002301	"What is the main topic discussed in paragraph 3.1 of the document ""Introducción a MongoDB""?"	"passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'What is the main topic discussed in paragraph 3.1 of the document ""Introducción a MongoDB""?'  "
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002302	According to the paragraph, what is the purpose of transactions in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'According to the paragraph, what is the purpose of transactions in MongoDB?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002303	Can you identify the type of transactions that are discussed in paragraph 3.1?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'Can you identify the type of transactions that are discussed in paragraph 3.1?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002304	How do multiple document transactions differ from single document transactions in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'How do multiple document transactions differ from single document transactions in MongoDB?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002305	What is the significance of transactional support for multiple documents in MongoDB, according to the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'What is the significance of transactional support for multiple documents in MongoDB, according to the paragraph?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002306	In which scenario might it be necessary to use multiple document transactions in MongoDB, as described in paragraph 3.1?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'In which scenario might it be necessary to use multiple document transactions in MongoDB, as described in paragraph 3.1?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002307	How does MongoDB ensure consistency during multi-document transactions, as mentioned in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'How does MongoDB ensure consistency during multi-document transactions, as mentioned in the paragraph?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002308	Can you summarize the key points about multi-document transactions in MongoDB, as presented in paragraph 3.1?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'Can you summarize the key points about multi-document transactions in MongoDB, as presented in paragraph 3.1?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002309	What is the difference between single document transactions and multi-document transactions in MongoDB, as stated in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'What is the difference between single document transactions and multi-document transactions in MongoDB, as stated in the paragraph?'  
C002100023	Introduccion a MongoDB	3.1. Transacciones sobre múltiples documentos	synthetic_question	A continuación se analizará la necesidad de realizar transacciones que involucren múltiples documentos.	C00210002310	Why is it important to understand the concepts of transactions and consistency in MongoDB, as emphasized in paragraph 3.1?	passage: document 'Introduccion a MongoDB'; paragraph: '3.1. Transacciones sobre múltiples documentos'; content: 'Why is it important to understand the concepts of transactions and consistency in MongoDB, as emphasized in paragraph 3.1?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002401	What is the main idea of the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is the main idea of the paragraph?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002402	According to the paragraph, what is the difference between traditional relational databases and MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'According to the paragraph, what is the difference between traditional relational databases and MongoDB?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002403	Why is it important to consider transactions that involve multiple documents in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'Why is it important to consider transactions that involve multiple documents in MongoDB?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002404	What is an example of a case where transaction guarantees should be applied to a set of documents or operations involving multiple documents?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is an example of a case where transaction guarantees should be applied to a set of documents or operations involving multiple documents?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002405	How does MongoDB handle transactions by default?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'How does MongoDB handle transactions by default?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002406	What is the purpose of using transaction isolation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is the purpose of using transaction isolation in MongoDB?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002407	Can you describe a scenario where transaction isolation would be necessary in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'Can you describe a scenario where transaction isolation would be necessary in MongoDB?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002408	How do transaction isolation and snapshot isolation differ in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'How do transaction isolation and snapshot isolation differ in MongoDB?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002409	In which cases might snapshot isolation be more appropriate than transaction isolation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'In which cases might snapshot isolation be more appropriate than transaction isolation in MongoDB?'  
C002100024	Introduccion a MongoDB	Transacción compleja	synthetic_question	Transacción compuesta por más de una operación de lectura o escritura. El primer principio del modelado de datos relacionales es normalizar sus datos en tablas. Esto significa que determinadas operaciones comunes en las bases de datos requieren actualizaciones atómicas en muchas filas y columnas que corresponden a distintas tablas. En MongoDB, el modelo de datos es fundamentalmente diferente. El modelo documental anima a las personas usuarias a almacenar datos relacionados en el mismo documento. Por tanto, por defecto podría pensarse que no es necesario permitir transacciones que involucren modificaciones en múltiples documentos, ya que todos los datos relevantes para una operación se encontrarán en el agregado de interés. Siguiendo esa filosofía, MongoDB, por defecto gestiona las transacciones a nivel de documento. En la mayoría de los casos eso será suficiente, pero en otros es probable que se tenga que acceder a datos relacionados en distintos documentos, poniendo sobre la mesa la necesidad de considerar transacciones que involucren múltiples documentos. Permitir transacciones de múltiples documentos permite a las personas desarrolladoras abordar un mayor espectro de casos de uso con MongoDB. A través del aislamiento de instantáneas, las transacciones brindan una vista consistente de los datos y hacen cumplir la ejecución de todo o nada para mantener la integridad de los datos. Algunos casos en los que las garantías transaccionales deben aplicarse a un conjunto documentos (o de operaciones que involucran múltiples documentos) serían, por ejemplo: • Procesar eventos de la aplicación cuando las personas usuarias realizan acciones importantes, por ejemplo, actualizar el estado de una cuenta como morosa en todos los documentos de los propietarios de la cuenta. • Registro de acciones de aplicaciones personalizadas: por ejemplo, cuando una persona usuaria transfiere la propiedad de una entidad, la escritura no debería ser exitosa si el registro no lo es.	C00210002410	What is the relationship between transaction isolation and data consistency in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is the relationship between transaction isolation and data consistency in MongoDB?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002501	What type of relationships does the paragraph describe as being complex?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What type of relationships does the paragraph describe as being complex?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002502	How do the data fit naturally into objects according to the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'How do the data fit naturally into objects according to the paragraph?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002503	What is an example of a complex transaction described in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is an example of a complex transaction described in the paragraph?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002504	According to the paragraph, how are positions calculated?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'According to the paragraph, how are positions calculated?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002505	What is the purpose of updating positions each time there are added or modified operations?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is the purpose of updating positions each time there are added or modified operations?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002506	"Can you explain the meaning of ""agregado de cientos de miles de operaciones"" mentioned in the paragraph?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'Can you explain the meaning of ""agregado de cientos de miles de operaciones"" mentioned in the paragraph?'  "
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002507	In what context might it be important to update positions frequently, as suggested in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'In what context might it be important to update positions frequently, as suggested in the paragraph?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002508	How does the paragraph relate to the topic of introducing MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'How does the paragraph relate to the topic of introducing MongoDB?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002509	What is the main idea of the paragraph regarding transactions?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'What is the main idea of the paragraph regarding transactions?'  
C002100025	Introduccion a MongoDB	Transacción compleja	synthetic_question	Relaciones de muchos a muchos en las que los datos encajan naturalmente en objetos definidos; por ejemplo, las posiciones, calculadas mediante un agregado de cientos de miles de operaciones, deben actualizarse cada vez que se agregan o modifican operaciones.	C00210002510	Can you summarize the key points of the paragraph in one sentence?	passage: document 'Introduccion a MongoDB'; paragraph: 'Transacción compleja'; content: 'Can you summarize the key points of the paragraph in one sentence?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002601	What is the purpose of using explicit transactions in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'What is the purpose of using explicit transactions in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002602	How do you execute a transaction of multiple documents in MongoDB using the API for Java?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'How do you execute a transaction of multiple documents in MongoDB using the API for Java?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002603	What happens when a transaction is canceled in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'What happens when a transaction is canceled in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002604	Can external processes see the changes made during a canceled transaction in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'Can external processes see the changes made during a canceled transaction in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002605	How does the startTransaction() method initiate a transaction in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'How does the startTransaction() method initiate a transaction in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002606	What is the difference between a commitTransaction() and a rollbackTransaction() in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'What is the difference between a commitTransaction() and a rollbackTransaction() in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002607	In which situations should explicit transactions be used in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'In which situations should explicit transactions be used in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002608	How can you ensure atomicity across multiple documents in a single transaction in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'How can you ensure atomicity across multiple documents in a single transaction in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002609	Is it possible to perform a transaction on multiple collections simultaneously in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'Is it possible to perform a transaction on multiple collections simultaneously in MongoDB?'  
C002100026	Introduccion a MongoDB	3.2. Transacciones explícitas	synthetic_question	Si se quiere crear una transacción que incorpore múltiples operaciones (o documentos), se deberá gestionar desde los propios programas, utilizando la API correspondiente al lenguaje de programación. Las operaciones en una transacción pueden utilizar los parámetros read concern, write concern y read preference a nivel de transacción para una gestión de réplicas personalizada. En MongoDB, las transacciones explícitas solo deben usarse en partes de código que se consideren críticas, donde varios documentos relacionados deban actualizarse juntos de forma atómica. varios documentos en la misma colección o en una colección diferente, entonces esta se define con un inicio explícito, START, y un final explícito, ya sea de confirmación o de cancelación COMMIT/ROLLBACK. Para realizar dicha transacción habría que ejecutar una transacción de múltiples documentos. El siguiente fragmento muestra cómo ejecutar una transacción de múltiples documentos utilizando la API de transacciones para Java. try (ClientSession clientSession = client.startSession()) { clientSession.startTransaction(); collection.insertOne(clientSession, docOne); collection.insertOne(clientSession, docTwo); clientSession.commitTransaction(); } Cuando las transacciones se cancelan, todos los cambios realizados en la transacción se descartan por completo sin que ningún otro proceso externo a la transacción los pueda ver. Se podrá ver este comportamiento más a fondo en los siguientes apartados.	C00210002610	What is the significance of the readConcern and writeConcern parameters in MongoDB transactions?	passage: document 'Introduccion a MongoDB'; paragraph: '3.2. Transacciones explícitas'; content: 'What is the significance of the readConcern and writeConcern parameters in MongoDB transactions?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002701	What is the new feature added in MongoDB 4.2 that allows transactions on fragmented collections?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'What is the new feature added in MongoDB 4.2 that allows transactions on fragmented collections?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002702	What is the purpose of using transactions on fragmented collections in MongoDB 4.2?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'What is the purpose of using transactions on fragmented collections in MongoDB 4.2?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002703	How do transactions on fragmented collections incur additional costs in terms of processing power and operation latency?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'How do transactions on fragmented collections incur additional costs in terms of processing power and operation latency?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002704	Under what circumstances should transactions on fragmented collections only be used?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'Under what circumstances should transactions on fragmented collections only be used?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002705	Can you describe the difference between transactions on fragmented collections in MongoDB 4.2 compared to previous versions?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'Can you describe the difference between transactions on fragmented collections in MongoDB 4.2 compared to previous versions?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002706	How does the support for transactions on fragmented collections in MongoDB 4.2 affect the performance of the database?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'How does the support for transactions on fragmented collections in MongoDB 4.2 affect the performance of the database?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002707	Are there any limitations or restrictions on using transactions on fragmented collections in MongoDB 4.2?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'Are there any limitations or restrictions on using transactions on fragmented collections in MongoDB 4.2?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002708	Can you provide an example scenario where transactions on fragmented collections would be beneficial in MongoDB 4.2?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'Can you provide an example scenario where transactions on fragmented collections would be beneficial in MongoDB 4.2?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002709	How does the use of transactions on fragmented collections impact the consistency and accuracy of data in MongoDB 4.2?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'How does the use of transactions on fragmented collections impact the consistency and accuracy of data in MongoDB 4.2?'  
C002100027	Introduccion a MongoDB	3.3. Transacciones sobre colecciones fragmentadas	synthetic_question	MongoDB 4.2 agregó soporte para transacciones de documentos múltiples en colecciones fragmentadas, es decir, colecciones que están distribuidas entre distintos nodos. Estas transacciones incurren en un coste adicional en términos de potencia de procesamiento y latencia de una operación, y solo deben usarse cuando sea absolutamente necesario.	C00210002710	In what ways can developers optimize the use of transactions on fragmented collections in MongoDB 4.2 to improve performance and minimize potential issues?	passage: document 'Introduccion a MongoDB'; paragraph: '3.3. Transacciones sobre colecciones fragmentadas'; content: 'In what ways can developers optimize the use of transactions on fragmented collections in MongoDB 4.2 to improve performance and minimize potential issues?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002801	What is the purpose of WiredTiger's write-ahead journal file in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'What is the purpose of WiredTiger's write-ahead journal file in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002802	How does WiredTiger ensure data durability in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'How does WiredTiger ensure data durability in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002803	What is the combination of components used by WiredTiger for data durability in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'What is the combination of components used by WiredTiger for data durability in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002804	Can you describe the function of points of control (checkpoints) in WiredTiger's data durability mechanism in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'Can you describe the function of points of control (checkpoints) in WiredTiger's data durability mechanism in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002805	How often does WiredTiger create a new checkpoint in the write-ahead journal file during operation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'How often does WiredTiger create a new checkpoint in the write-ahead journal file during operation in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002806	In what situation might WiredTiger use an existing checkpoint instead of creating a new one in the write-ahead journal file in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'In what situation might WiredTiger use an existing checkpoint instead of creating a new one in the write-ahead journal file in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002807	If a crash occurs before a checkpoint is committed, which actions would WiredTiger take to recover in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'If a crash occurs before a checkpoint is committed, which actions would WiredTiger take to recover in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002808	How does WiredTiger handle concurrent writes during the recovery process after a crash in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'How does WiredTiger handle concurrent writes during the recovery process after a crash in MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002809	Can you explain the relationship between the write-ahead journal file and checkpoints in ensuring data durability in WiredTiger's implementation of MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'Can you explain the relationship between the write-ahead journal file and checkpoints in ensuring data durability in WiredTiger's implementation of MongoDB?'  
C002100028	Introduccion a MongoDB	3.4. Gestión de la durabilidad	synthetic_question	WiredTiger utiliza un archivo de diario de escritura por anticipado, write-ahead journal file, en combinación con puntos de control, checkpoints, para garantizar la durabilidad de los datos.	C00210002810	Under what circumstances might it be necessary to manually trigger a checkpoint commit in WiredTiger's MongoDB implementation?	passage: document 'Introduccion a MongoDB'; paragraph: '3.4. Gestión de la durabilidad'; content: 'Under what circumstances might it be necessary to manually trigger a checkpoint commit in WiredTiger's MongoDB implementation?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002901	What are the two parameters that indicate the number of nodes required to complete an operation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What are the two parameters that indicate the number of nodes required to complete an operation in MongoDB?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002902	What is the purpose of the read preference parameter in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the purpose of the read preference parameter in MongoDB?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002903	How often do changes made in memory get written to disk in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'How often do changes made in memory get written to disk in MongoDB?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002904	What is the point of control in MongoDB, and what does it ensure?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the point of control in MongoDB, and what does it ensure?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002905	Can MongoDB recover from a disaster using the last point of control?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'Can MongoDB recover from a disaster using the last point of control?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002906	What is the difference between WiredTiger and the standard MongoDB storage engine?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the difference between WiredTiger and the standard MongoDB storage engine?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002907	How does WiredTiger improve performance in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'How does WiredTiger improve performance in MongoDB?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002908	What is the purpose of the diary in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the purpose of the diary in MongoDB?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002909	How does the diary aid in recovery after a disaster?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'How does the diary aid in recovery after a disaster?'  
C002100029	Introduccion a MongoDB	Parámetros	synthetic_question	Los términos read concern y write concern indican el número de nodos que deben realizar una operación (de lectura para el read concern y escritura para el write concern) para que la transacción tenga éxito. Estos parámetros son los homólogos a los parámetros W y R de la estrategia de gestión de réplicas a través de cuórums. El read preference se refiere al nodo del que se espera que se obtengan los valores (nodo primario, nodos secundarios, etc.). Cuando una aplicación cliente envía una operación de escritura sobre la base de datos, primero se aplica en la memoria, luego se escribe en el diario del disco y tras ello, aproximadamente cada sesenta segundos, todos los cambios en la cola de la memoria (incluidos los índices) se trasladan al disco creando un punto de control duradero. En el caso de WiredTiger, al escribir en el disco se escriben en él todos los datos de una instantánea en todos los archivos de datos. Este punto actúa como un punto de control de la base de datos. El punto de control asegura que los archivos de datos sean consistentes hasta el último punto de control inclusive; es decir, en caso de desastre, los puntos de control pueden actuar como puntos de recuperación. Al poner en cola primero los cambios en la memoria, MongoDB puede lograr un rendimiento mucho mayor, ya que puede descartar cualquier cambio obsoleto (por ejemplo, cuando el campo del mismo documento se cambia dos veces en sesenta segundos) y luego agrupar todas las operaciones de entrada y salida restantes. Usando WiredTiger, MongoDB puede recuperarse desde el último punto de control; sin embargo, para recuperar los cambios realizados después del último punto de control, siempre será necesario ejecutar el registro de diario. Con el diario, el proceso de recuperación es el siguiente: 1) Buscar en los archivos de datos el identificador del último punto de control.	C00210002910	What is the identifier used to locate the last point of control in the diary?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the identifier used to locate the last point of control in the diary?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003001	What is the purpose of the last point of control identifier in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the purpose of the last point of control identifier in MongoDB?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003002	How often should writes be performed to the diary files in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'How often should writes be performed to the diary files in MongoDB?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003003	What happens if there are no writings in the diary files during a session in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What happens if there are no writings in the diary files during a session in MongoDB?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003004	Can a single node MongoDB independently perform operations on the diary files?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'Can a single node MongoDB independently perform operations on the diary files?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003005	How does MongoDB ensure data durability when writing to the diary files?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'How does MongoDB ensure data durability when writing to the diary files?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003006	What is the frequency at which MongoDB checks the diary files during the initialization process?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'What is the frequency at which MongoDB checks the diary files during the initialization process?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003007	Are there any operational consequences if there are no entries in the diary files during a session in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'Are there any operational consequences if there are no entries in the diary files during a session in MongoDB?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003008	Can the diary files be used to recover previous states of the database in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'Can the diary files be used to recover previous states of the database in MongoDB?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003009	How do the diary files affect the performance of MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'How do the diary files affect the performance of MongoDB?'  
C002100030	Introduccion a MongoDB	Parámetros	synthetic_question	2) Buscar en los archivos del diario el registro que coincide con el identificador del último punto de control. 3) Aplicar las operaciones en los archivos de diario desde el último punto de control. Para un único nodo MongoDB independiente, se puede considerar que una escritura es duradera una vez se ha escrito en el diario, lo que debería ocurrir al menos cada cincuenta milisegundos. Como parte del proceso de inicio de MongoDB, se comprueba el diario y se aplica cualquier operación pendiente que se haya escrito allí durante una sesión anterior.	C00210003010	In what ways can the diary files be useful for troubleshooting purposes in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Parámetros'; content: 'In what ways can the diary files be useful for troubleshooting purposes in MongoDB?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003101	"What is the main topic discussed in paragraph 4 of the document ""Introducción a MongoDB""?"	"passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'What is the main topic discussed in paragraph 4 of the document ""Introducción a MongoDB""?'  "
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003102	According to paragraph 4, what is the purpose of MongoDB's operations?	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'According to paragraph 4, what is the purpose of MongoDB's operations?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003103	Can you identify the type of data storage used in MongoDB, based on paragraph 4?	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'Can you identify the type of data storage used in MongoDB, based on paragraph 4?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003104	How do MongoDB's operations work, according to paragraph 4?	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'How do MongoDB's operations work, according to paragraph 4?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003105	What is the difference between reading and writing operations in MongoDB, as stated in paragraph 4?	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'What is the difference between reading and writing operations in MongoDB, as stated in paragraph 4?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003106	In which part of a document does MongoDB perform operations, as mentioned in paragraph 4?	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'In which part of a document does MongoDB perform operations, as mentioned in paragraph 4?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003107	"What is the significance of the phrase ""recordad que en MongoDB las operaciones se realizan siempre a nivel de documento"" in paragraph 4?"	"passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'What is the significance of the phrase ""recordad que en MongoDB las operaciones se realizan siempre a nivel de documento"" in paragraph 4?'  "
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003108	"What is the focus of the sentence ""Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis"" in paragraph 4?"	"passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'What is the focus of the sentence ""Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis"" in paragraph 4?'  "
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003109	Based on paragraph 4, how would you describe the syntax proposed for the console of MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'Based on paragraph 4, how would you describe the syntax proposed for the console of MongoDB?'  
C002100031	Introduccion a MongoDB	4. Operaciones CRUD	synthetic_question	Una vez vistas las características generales de MongoDB y su modelo de datos, a continuación se presentarán algunas de sus operaciones de creación, lectura, actualización y borrado de datos.4 Las operaciones de lectura y escritura de MongoDB se ejecutan siempre en el ámbito de una colección, y permiten crear, modificar, consultar y borrar documentos. Recordad que en MongoDB las operaciones se realizan siempre a nivel de documento. En este apartado se verá una simplificación de la sintaxis propuesta para la consola de MongoDB. Las llamadas a las API en algunos lenguajes pueden diferir ligeramente de esta sintaxis.	C00210003110	"What is the overall theme of paragraph 4 in the document ""Introducción a MongoDB""?"	"passage: document 'Introduccion a MongoDB'; paragraph: '4. Operaciones CRUD'; content: 'What is the overall theme of paragraph 4 in the document ""Introducción a MongoDB""?'  "
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003201	What is the purpose of the `insertOne()` method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'What is the purpose of the `insertOne()` method in MongoDB?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003202	How does MongoDB handle writings operations at the level of a single document?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'How does MongoDB handle writings operations at the level of a single document?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003203	What is the difference between `insertOne()` and `insertMany()` methods in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'What is the difference between `insertOne()` and `insertMany()` methods in MongoDB?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003204	Can you specify the number of nodes where MongoDB performs writing operations using the `write concern` parameter?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'Can you specify the number of nodes where MongoDB performs writing operations using the `write concern` parameter?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003205	What happens if MongoDB cannot complete a writing operation due to a lack of available nodes?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'What happens if MongoDB cannot complete a writing operation due to a lack of available nodes?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003206	Is it possible to increase the consistency and durability of data in MongoDB by increasing the value of `write concern`?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'Is it possible to increase the consistency and durability of data in MongoDB by increasing the value of `write concern`?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003207	What is the effect of increasing the value of `write concern` on the availability of data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'What is the effect of increasing the value of `write concern` on the availability of data in MongoDB?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003208	How do the `insertOne()`, `insertMany()`, and `insert()` methods differ in terms of inserting multiple documents into a collection?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'How do the `insertOne()`, `insertMany()`, and `insert()` methods differ in terms of inserting multiple documents into a collection?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003209	Can you use the `insertOne()` method to insert a single document or multiple documents into a collection?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'Can you use the `insertOne()` method to insert a single document or multiple documents into a collection?'  
C002100032	Introduccion a MongoDB	4.1. Creación	synthetic_question	Las operaciones de creación o inserción agregan nuevos documentos a una colección. Si la colección no existe, se creará automáticamente antes de realizar la inserción de datos. En MongoDB, las operaciones de inserción tienen como objetivo una sola colección. Por defecto, todas las operaciones de escritura en MongoDB son atómicas al nivel de un solo documento. Mongo shell proporciona los siguientes métodos para insertar documentos en una colección: • db.collection.insertOne(<document>,<write concern>): inserta un solo documento en una colección (denominada como collection). Es necesario pasar como parámetro un documento en formato JSON al método. • db.collection.insertMany([<document 1>,..,<document n>],<write concern>): puede insertar varios documentos en una colección. Es necesario pasar como parámetro un array de documentos al método. db.collection.insert([<document 1>,..,<document n>]): inserta un solo documento o varios documentos en una colección. Opcionalmente, en las operaciones de escritura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de escritura, write concern. Este parámetro permite definir el número de nodos sobre los que debe hacerse la escritura antes de aceptar la transacción y, si es obligatorio, haber (4)Para obtener un detalle de estas operaciones, se puede consultar <https://docs.mongodb.com/ manual/crud/>. escrito los datos en disco antes de aceptar la transacción. Como se verá más adelante, aumentar el valor de write concern permite aumentar la consistencia y la durabilidad de los datos, pero puede reducir su disponibilidad.	C00210003210	What is the default behavior of MongoDB when it comes to writing operations, and how can you change this behavior using the `write concern` parameter?	passage: document 'Introduccion a MongoDB'; paragraph: '4.1. Creación'; content: 'What is the default behavior of MongoDB when it comes to writing operations, and how can you change this behavior using the `write concern` parameter?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003301	What is the purpose of the examples shown in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the purpose of the examples shown in the paragraph?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003302	What type of operations can be performed on a collection in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What type of operations can be performed on a collection in MongoDB?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003303	How can new documents be added to a collection using the update() method?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'How can new documents be added to a collection using the update() method?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003304	What is the difference between updateOne() and updateMany() methods in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the difference between updateOne() and updateMany() methods in MongoDB?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003305	When should use findAndModify() method instead of findOneAndUpdate() or findOneAndReplace() methods?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'When should use findAndModify() method instead of findOneAndUpdate() or findOneAndReplace() methods?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003306	What is bulkWrite() method in MongoDB and what does it do?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is bulkWrite() method in MongoDB and what does it do?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003307	Can the upsert option be used with all the methods mentioned in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Can the upsert option be used with all the methods mentioned in the paragraph?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003308	What is the purpose of the _id field in a MongoDB document?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the purpose of the _id field in a MongoDB document?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003309	How would you describe the address field in a MongoDB document?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'How would you describe the address field in a MongoDB document?'  
C002100033	Introduccion a MongoDB	Ejemplo	synthetic_question	"Los siguientes ejemplos muestran operaciones de inserción: db.Customers.insert({ ""_id"": ""410002X"", ""name"": ""Jordi"", ""address"": { ""street"": ""c. Sant Marti 4"", ""city"": ""Girona"", ""zipCode"": ""17001"", ""country"": ""Spain"" } }); db.Customers.insertMany([ {""_id"": ""520002X"", ""name"": ""John"", ""address"": { ""street"": ""221B Baker Street"",""city"": ""London"", ""zipCode"": ""NW1"", ""country"": ""UK"" }}, {""_id"": ""410003Y"", ""name"": ""Andrea"", ""address"": { ""street"": ""Via Aldo Moro, 52"", ""city"": ""Borgo San Giacomo"", ""zipCode"": ""25022"", ""country"": ""Italy"" }} ]); Los siguientes métodos también pueden agregar nuevos documentos a una colección: ¢ = db.collection.update(): cuando se usa con la opción upsert: true. db.collection.updateOne(): cuando se usa con la opción upsert: true. db.collection.updateMany(): cuando se usa con la opción upsert: true. db.collection.findAndModify(): cuando se usa con la opción upsert: true. db.collection.findOneAndUpdate(): cuando se usa con la opción upsert: true. db.collection.findOneAndReplace(): cuando se usa con la opción upsert: true. db.collection.bulkWrite(): realiza múltiples operaciones de escritura permitiendo usar controles para gestionar el orden de ejecución. La opción upsert: true indica que si ningún documento coincide con los criterios de consulta se inserta un nuevo documento."	C00210003310	In which country is the city of Girona located?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'In which country is the city of Girona located?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003401	What is the purpose of the find() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'What is the purpose of the find() method in MongoDB?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003402	How do you specify the conditions for searching documents using the find() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'How do you specify the conditions for searching documents using the find() method in MongoDB?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003403	What is the difference between the find() and findOne() methods in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'What is the difference between the find() and findOne() methods in MongoDB?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003404	Can you use the find() method to retrieve only specific fields from a document?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'Can you use the find() method to retrieve only specific fields from a document?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003405	How do you project specific fields when retrieving documents using the find() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'How do you project specific fields when retrieving documents using the find() method in MongoDB?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003406	Is it possible to exclude certain fields from being returned in the results of a find() operation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'Is it possible to exclude certain fields from being returned in the results of a find() operation in MongoDB?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003407	Can you use the find() method to search for documents based on a specific field equal to a certain value?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'Can you use the find() method to search for documents based on a specific field equal to a certain value?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003408	How do you perform a search using the find() method in MongoDB if you want to return only one document?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'How do you perform a search using the find() method in MongoDB if you want to return only one document?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003409	Can you use the find() method to search for documents based on multiple criteria?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'Can you use the find() method to search for documents based on multiple criteria?'  
C002100034	Introduccion a MongoDB	4.2. Consulta	synthetic_question	"Para realizar consultas, Mongo shell dispone de los siguientes métodos: db.collection.find(<filter>, <projection>): se utiliza para consultar los documentos de una colección. El parámetro filter permite de- finir las condiciones de búsqueda, mientras que el parámetro projection indica qué campos del documento se deben devolver. El parámetro projection es el equivalente a la cláusula SELECT de SQL. db.collection.findOne(<filter>, <projection>): también realiza una operación de lectura para devolver un solo documento. Internamente, actúa como el método db.collection.find(), con un límite de 1. <filter> especifica las condiciones que determinan qué registros se seleccionarán y es el equivalente a la cláusula WHERE de SQL. Es un documento en formato JSON, en el que se utilizan expresiones <atributo>:<valor> para especificar la condición de igualdad, junto con otros operadores de consulta.5 Estos operadores de consulta permiten implementar, entre otras, expresiones campos en los documentos coincidentes. Al realizar una consulta, se puede incluir un documento JSON como parámetro <projection> para especificar o restringir los campos que se devolverán. Se utilizan expresiones <atributo>:<valor>, donde el valor es 1 para indicar qué atributos se mostrarán además del atributo _id, que se muestra siempre de forma predeterminada. Se puede eliminar el campo _id de los resultados asignando un valor de 0 en la proyección. La siguiente consulta recupera todos los documentos de la colección Customers donde el campo name es igual a ”John”. En esta consulta tan solo se utiliza el filtro y por ello retornará todos los campos de cada documento que cumplan la condición. db.Customers.find( { ""name"": ""John"" } );"	C00210003410	How does the find() method handle null or missing values in the search criteria in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.2. Consulta'; content: 'How does the find() method handle null or missing values in the search criteria in MongoDB?'  
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003501	What is the purpose of the find() method in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'What is the purpose of the find() method in MongoDB?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003502	How do we retrieve specific fields in a document using the find() method?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'How do we retrieve specific fields in a document using the find() method?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003503	Can we use nested objects within our query to filter results?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'Can we use nested objects within our query to filter results?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003504	"In which field does the value ""Girona"" appear in the given paragraph?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'In which field does the value ""Girona"" appear in the given paragraph?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003505	What is the name of the collection being queried in the given paragraph?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'What is the name of the collection being queried in the given paragraph?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003506	How do we specify multiple conditions in a single query using the find() method?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'How do we specify multiple conditions in a single query using the find() method?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003507	Is it possible to search for values within arrays or nested objects using the find() method?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'Is it possible to search for values within arrays or nested objects using the find() method?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003508	Can we use logical operators (e.g., AND, OR) to combine multiple conditions in a single query?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'Can we use logical operators (e.g., AND, OR) to combine multiple conditions in a single query?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003509	How would we modify the given query to retrieve only the address field from the documents that match the condition?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'How would we modify the given query to retrieve only the address field from the documents that match the condition?'  "
C002100035	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"" } );"	synthetic_question	"Si se desea añadir condiciones, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” y el campo city embebido en el campo address es igual a ”Girona”. db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	C00210003510	What is the difference between using.find() and.forEach() when retrieving data from a MongoDB collection?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"" } );'; content: 'What is the difference between using.find() and.forEach() when retrieving data from a MongoDB collection?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003601	What is the purpose of the second query in the paragraph?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'What is the purpose of the second query in the paragraph?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003602	How does the second query differ from the first one in terms of the filter criteria?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'How does the second query differ from the first one in terms of the filter criteria?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003603	What is the value of the field name in the second query?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'What is the value of the field name in the second query?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003604	Is the field address.city an embedded document in the Customer collection?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'Is the field address.city an embedded document in the Customer collection?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003605	Can you explain the difference between the $or operator and the $in operator in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'Can you explain the difference between the $or operator and the $in operator in MongoDB?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003606	Why is the field _id not included in the projection of the second query?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'Why is the field _id not included in the projection of the second query?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003607	What is the purpose of the readConcern parameter in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'What is the purpose of the readConcern parameter in MongoDB?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003608	How does increasing the value of readConcern affect data availability?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'How does increasing the value of readConcern affect data availability?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003609	In which situations might you want to use the readConcern parameter in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'In which situations might you want to use the readConcern parameter in MongoDB?'  "
C002100036	Introduccion a MongoDB	"db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );"	synthetic_question	"En cambio, la siguiente consulta recupera todos los documentos de la colección Customers, donde el campo name es igual a ”John” o aquellos en que el valor del campo city embebido en el campo address sea igual a ”Girona”. db.Customers.find( { $or: [ { ""name"": ""John""}, { ""address.city"":""Girona""} ] } ); (5)Los operadores disponibles pueden consultarse en <https:// docs.mongodb.com/manual/ reference/operator/query/>. Finalmente, se expone el siguiente ejemplo que recupera todos los documentos de la colección Customers, donde el campo city embebido en el campo address es igual a ”Girona” o ”London”. Esta consulta tan solo proyectará para cada documento el atributo name, identificado con un 1 en la cláusula PROJECTION, ya que en ella se especifica que no se muestre el atributo _id, mediante 0. db.Customers.find({ ""address.city"": { $in: [ ""Girona"", ""London"" ] }} , { ""_id"":0,""name"":1 } ); Opcionalmente, en las operaciones de lectura se puede especificar el nivel de la garantía con la que MongoDB realiza las operaciones de lectura, read concern. Este parámetro, permite ajustar la consistencia que se quiere que tengan los datos obtenidos en la operación de lectura. Como se verá posteriormente, aumentar el valor de read concern permite aumentar la consistencia de los datos leídos, pero puede reducir su disponibilidad."	C00210003610	Can you provide an example of how to use the readConcern parameter in a real-world scenario?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.find( { ""name"": ""John"", ""address.city"":""Girona"" } );'; content: 'Can you provide an example of how to use the readConcern parameter in a real-world scenario?'  "
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003701	What is the purpose of the update() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is the purpose of the update() method in MongoDB?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003702	How does the update() method identify the documents to modify?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'How does the update() method identify the documents to modify?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003703	What is the difference between the updateOne() and updateMany() methods in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is the difference between the updateOne() and updateMany() methods in MongoDB?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003704	Can the update() method replace entire documents or just specific fields within them?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Can the update() method replace entire documents or just specific fields within them?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003705	What is the purpose of the filter parameter in the update() method?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is the purpose of the filter parameter in the update() method?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003706	How do the writeConcern and collation parameters affect the update() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'How do the writeConcern and collation parameters affect the update() method in MongoDB?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003707	Is it possible to update multiple documents at once using the update() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Is it possible to update multiple documents at once using the update() method in MongoDB?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003708	Can the update() method be used to insert new documents into a collection if they do not already exist?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Can the update() method be used to insert new documents into a collection if they do not already exist?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003709	Are there any limitations or restrictions on the use of the update() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Are there any limitations or restrictions on the use of the update() method in MongoDB?'  
C002100037	Introduccion a MongoDB	4.3. Actualización	synthetic_question	La operación para actualizar los datos de los documentos es la operación update en sus distintas variantes. Esta operación identifica los documentos a modificar utilizando la condición indicada en el parámetro <filter>. Para el uso de este parámetro están disponibles los mismos selectores de consulta que en el método find(). Posteriormente, actualiza dichos documentos en función del parámetro <update>. Este parámetro permite indicar un documento (en caso de que se quiera cambiar un documento por otro) o información relativa a sus campos (en caso de que solo se quieran cambiar algunos campos del documento). En el parámetro <update> se incluyen los operadores de actualización, como $set, para modificar los valores de los campos especificados.6 En lo que corresponde a las opciones, <options>, estas pueden ser: upsert, writeConcern, collation, multiple. Los siguientes métodos también pueden actualizar documentos a una colección: • db.collection.update(<filter>, <update>, <options>): actualiza o reemplaza los documentos que coinciden con un filtro especificado. De forma predeterminada actualiza un solo documento. En el caso que se desee actualizar varios documentos, será necesario utilizar la opción multiple. • db.collection.updateOne(<filter>, <update>, <options>): actualiza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado. (6)Los operadores disponibles pueden consultarse en https:// docs.mongodb.com/manual/ reference/operator/update/ db.collection.updateMany(<filter>,<update>,<options>): actualiza todos los documentos que coincidan con el filtro especificado. db.collection.replaceOne(<filter>,<replacement>,<options>): reemplaza como máximo un solo documento, aunque otros documentos también puedan coincidir con el filtro especificado.	C00210003710	How does the update() method differ from the replaceOne() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'How does the update() method differ from the replaceOne() method in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003801	What is the purpose of the findOneAndReplace() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is the purpose of the findOneAndReplace() method in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003802	How does the findOneAndUpdate() method differ from findOneAndReplace() in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'How does the findOneAndUpdate() method differ from findOneAndReplace() in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003803	What is the difference between findAndModify() and findOneAndReplace() in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is the difference between findAndModify() and findOneAndReplace() in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003804	Can you use findAndModify() to modify multiple documents at once in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Can you use findAndModify() to modify multiple documents at once in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003805	What is the default behavior of findAndModify() when it comes to returning modified documents in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is the default behavior of findAndModify() when it comes to returning modified documents in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003806	How can you retrieve modified documents including the changes made during an update operation using findAndModify() in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'How can you retrieve modified documents including the changes made during an update operation using findAndModify() in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003807	What is bulkWrite() in MongoDB, and how does it work?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'What is bulkWrite() in MongoDB, and how does it work?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003808	Can you execute multiple write operations simultaneously using bulkWrite() in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Can you execute multiple write operations simultaneously using bulkWrite() in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003809	Is there a limit to the number of documents that can be updated using bulkWrite() in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'Is there a limit to the number of documents that can be updated using bulkWrite() in MongoDB?'  
C002100038	Introduccion a MongoDB	4.3. Actualización	synthetic_question	db.collection.findOneAndReplace(<filter>,<replacement>,<options>): reemplaza todo un documento que cumpla con el filtro especificado. db.collection.findOneAndUpdate(): actualiza un solo documento según criterios de selección y ordenación. • db.collection.findAndModify(): modifica y devuelve un solo documento. De forma predeterminada, el documento devuelto no incluye las modificaciones realizadas en la actualización. Para devolver el documento con las modificaciones realizadas en la actualización, es necesario utilizar la opción new. db.collection.bulkWrite(): se pasa como parámetro un array de operaciones de escritura y ejecuta cada una de ellas. Por defecto, las operaciones se ejecutan en orden.	C00210003810	How does bulkWrite() handle conflicts when updating multiple documents in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.3. Actualización'; content: 'How does bulkWrite() handle conflicts when updating multiple documents in MongoDB?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003901	What is the purpose of the example given in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the purpose of the example given in the paragraph?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003902	Which field does the update operation modify in the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Which field does the update operation modify in the example?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003903	What is the value of the _id field in the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the value of the _id field in the example?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003904	How many fields are updated in the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'How many fields are updated in the example?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003905	Is the update operation performed using the findAndModify() method or the updateOne() method?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Is the update operation performed using the findAndModify() method or the updateOne() method?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003906	What is the new value assigned to the name field in the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the new value assigned to the name field in the example?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003907	Does the example demonstrate a write operation or a read operation?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Does the example demonstrate a write operation or a read operation?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003908	Can the update operation be applied to multiple documents at once?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Can the update operation be applied to multiple documents at once?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003909	Are there any conditions specified in the update operation to filter which documents should be updated?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Are there any conditions specified in the update operation to filter which documents should be updated?'  
C002100039	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo actualizar el valor del campo name del documento cuyo ”_id” es igual a ”520002X”. db.Customers.updateOne( { ""_id"": ""520002X"" }, { $set: { ""name"": ""Paul"" } });"	C00210003910	What is the result of running the update operation according to the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the result of running the update operation according to the example?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004001	What is the purpose of the deleteMany() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'What is the purpose of the deleteMany() method in MongoDB?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004002	How do we specify conditions for deleting documents using the deleteMany() method?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'How do we specify conditions for deleting documents using the deleteMany() method?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004003	What is the default value for the writeConcern parameter in the deleteMany() method?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'What is the default value for the writeConcern parameter in the deleteMany() method?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004004	What is the purpose of the collation parameter in the deleteMany() method?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'What is the purpose of the collation parameter in the deleteMany() method?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004005	Can we use an empty filter object ({}) to delete all documents in a collection using the deleteMany() method?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'Can we use an empty filter object ({}) to delete all documents in a collection using the deleteMany() method?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004006	Is it possible to delete a single document using the deleteOne() method?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'Is it possible to delete a single document using the deleteOne() method?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004007	What is the difference between the deleteMany() and deleteOne() methods in terms of their functionality?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'What is the difference between the deleteMany() and deleteOne() methods in terms of their functionality?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004008	Can we use the drop() method to delete all documents in a collection without specifying any filters or conditions?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'Can we use the drop() method to delete all documents in a collection without specifying any filters or conditions?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004009	What happens if we try to delete a document that does not exist in the collection?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'What happens if we try to delete a document that does not exist in the collection?'  
C002100040	Introduccion a MongoDB	4.4. Borrado	synthetic_question	Para borrar documentos de una colección se utiliza un conjunto de operaciones. Estas operaciones pueden recibir un conjunto de condiciones en el documento <filter> que permiten encontrar los documentos a eliminar: • db.collection.deleteMany ( <filter>, {writeConcern: <document>, collation: <document> }): elimina todos los documentos de una colección que coinciden con el filtro especificado. collation permite a las personas usuarias especificar reglas específicas del idioma para la comparación de cadenas, como reglas para letras y tildes. Para eliminar todos los documentos de una colección, se puede utilizar un documento de filtro vacío {}. Los parámetros writeConcern y collation son opcionales. db.collection.drop(): elimina todos los documentos de una colección. db.collection.deleteOne ( <filter>, {writeConcern: <document>, collation: <document> }): elimina un único documento de una colección que coincida con el filtro especificado.	C00210004010	Are there any optional parameters that we can pass to the deleteMany() method to customize its behavior?	passage: document 'Introduccion a MongoDB'; paragraph: '4.4. Borrado'; content: 'Are there any optional parameters that we can pass to the deleteMany() method to customize its behavior?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004101	What is the purpose of the example shown in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the purpose of the example shown in the paragraph?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004102	Which field does the example use to identify the document to delete?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Which field does the example use to identify the document to delete?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004103	What is the value of the field used to identify the document to delete?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the value of the field used to identify the document to delete?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004104	In which collection is the deleted document located?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'In which collection is the deleted document located?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004105	What is the name of the database where the deleted document is stored?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'What is the name of the database where the deleted document is stored?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004106	"Can the example be applied to delete multiple documents with the same value in the ""name"" field?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Can the example be applied to delete multiple documents with the same value in the ""name"" field?'  "
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004107	How many documents are expected to be deleted using the example?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'How many documents are expected to be deleted using the example?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004108	Does the example require any additional information or parameters to execute successfully?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Does the example require any additional information or parameters to execute successfully?'  
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004109	"Is the example suitable for deleting documents based on other fields besides ""name""?"	"passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Is the example suitable for deleting documents based on other fields besides ""name""?'  "
C002100041	Introduccion a MongoDB	Ejemplo	synthetic_question	"En el siguiente ejemplo se muestra cómo eliminar un documento de la colección en el que el valor del campo name sea igual a ”Paul”. db.Customers.deleteOne( { ""name"": ""Paul""} );"	C00210004110	Can the example be modified to delete documents based on multiple conditions?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplo'; content: 'Can the example be modified to delete documents based on multiple conditions?'  
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004201	What is the purpose of the agggregation pipeline in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'What is the purpose of the agggregation pipeline in MongoDB?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004202	What are the three forms of aggregation available in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'What are the three forms of aggregation available in MongoDB?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004203	What is the difference between aggregate methods and map reduce?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'What is the difference between aggregate methods and map reduce?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004204	Can you count the number of documents in a collection or query using the count() method?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'Can you count the number of documents in a collection or query using the count() method?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004205	How do single-purpose aggregation methods differ from map reduce?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'How do single-purpose aggregation methods differ from map reduce?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004206	What is the purpose of the count() method in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'What is the purpose of the count() method in MongoDB?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004207	Can you group values from different documents and perform calculations on them using aggregation?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'Can you group values from different documents and perform calculations on them using aggregation?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004208	Are there any predefined aggregation pipelines in MongoDB?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'Are there any predefined aggregation pipelines in MongoDB?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004209	Can you use the count() method to retrieve the number of documents matching a specific query?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'Can you use the count() method to retrieve the number of documents matching a specific query?'  "
C002100042	Introduccion a MongoDB	"db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación"	synthetic_question	Las operaciones de agregación procesan conjuntos de documentos y permiten generar distintos cálculos sobre los mismos. Estas operaciones permiten agrupar valores de distintos documentos y realizar una variedad de operaciones en los datos agrupados para devolver un solo resultado. MongoDB proporciona tres formas de realizar la agregación: aggregationpipeline, map reduce y los métodos de agregación de propósito único. Los métodos de agregación de propósito único son los más parecidos a los que se encontrarían en una base de datos relacional, y están compuestos por las siguientes operaciones: db.collection.count(): cuenta el número de documentos de la colección o de una determinada consulta.	C00210004210	Is it possible to perform multiple operations within an aggregation pipeline?	"passage: document 'Introduccion a MongoDB'; paragraph: 'db.Customers.deleteOne( { ""name"": ""Paul""} );.  4.5. Agregación'; content: 'Is it possible to perform multiple operations within an aggregation pipeline?'  "
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004301	What is the main purpose of the distinct() method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'What is the main purpose of the distinct() method in MongoDB?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004302	How does the group() method in MongoDB differ from the GROUP BY clause in SQL?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'How does the group() method in MongoDB differ from the GROUP BY clause in SQL?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004303	Can you explain the concept of an aggregation pipeline in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'Can you explain the concept of an aggregation pipeline in MongoDB?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004304	What is the difference between using aggregate functions versus using a custom JavaScript function in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'What is the difference between using aggregate functions versus using a custom JavaScript function in MongoDB?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004305	In which situation would you use db.collection.distinct() instead of db.collection.group()?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'In which situation would you use db.collection.distinct() instead of db.collection.group()?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004306	How do you ensure that duplicate values are not returned in the results when using db.collection.distinct()?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'How do you ensure that duplicate values are not returned in the results when using db.collection.distinct()?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004307	Can you describe the process of transforming documents into aggregated results using the aggregation framework in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'Can you describe the process of transforming documents into aggregated results using the aggregation framework in MongoDB?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004308	What is the significance of the () operator in the aggregation pipeline in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'What is the significance of the () operator in the aggregation pipeline in MongoDB?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004309	How do you handle missing or invalid data in the input documents during the aggregation process in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'How do you handle missing or invalid data in the input documents during the aggregation process in MongoDB?'  
C002100043	Introduccion a MongoDB	e	synthetic_question	db.collection.distinct(): evita devolver valores duplicados. • db.collection.group(): agrupa los datos de una colección –o de una consulta– en función de un conjunto de campos (el equivalente a la cláusula GROUP BY de SQL). El aggregation framework7 (o pipeline) de MongoDB se basa en el concepto de canalizaciones de procesamiento de datos. Los documentos son procesados en distintas etapas, que permiten transformar los documentos en el resultado agregado esperado. MongoDB también permite utilizar funciones de JavaScript personalizadas para realizar agregaciones utilizando una estrategia map reduce. (7)Se puede completar la información referente a aggregation framework en <https:// docs.mongodb.com/manual/core/ aggregation-pipeline/>.	C00210004310	Can you provide an example of how to use the aggregation framework in MongoDB to perform a complex data transformation task?	passage: document 'Introduccion a MongoDB'; paragraph: 'e'; content: 'Can you provide an example of how to use the aggregation framework in MongoDB to perform a complex data transformation task?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004401	What is the main topic discussed in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'What is the main topic discussed in the paragraph?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004402	According to the paragraph, what is the mechanism of replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'According to the paragraph, what is the mechanism of replication in MongoDB?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004403	How does MongoDB handle fragmentation of data?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'How does MongoDB handle fragmentation of data?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004404	Can you summarize the purpose of replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'Can you summarize the purpose of replication in MongoDB?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004405	In which situations might fragmentation occur in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'In which situations might fragmentation occur in MongoDB?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004406	How does MongoDB ensure consistency between replica sets?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'How does MongoDB ensure consistency between replica sets?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004407	What is the difference between replication and fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'What is the difference between replication and fragmentation in MongoDB?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004408	Can you explain the process of replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'Can you explain the process of replication in MongoDB?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004409	How does MongoDB manage conflicts during replication?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'How does MongoDB manage conflicts during replication?'  
C002100044	Introduccion a MongoDB	5. Estrategias de distribución y replicación	synthetic_question	Hasta aquí se han visto las características y el funcionamiento de MongoDB. En este apartado se estudiará cómo funciona su mecanismo de replicación y fragmentación de datos.	C00210004410	What is the benefit of using replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5. Estrategias de distribución y replicación'; content: 'What is the benefit of using replication in MongoDB?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004501	What is the main purpose of replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the main purpose of replication in MongoDB?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004502	How does MongoDB manage replication among nodes?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'How does MongoDB manage replication among nodes?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004503	Can you describe the different types of nodes in a MongoDB replica set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Can you describe the different types of nodes in a MongoDB replica set?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004504	What is the role of the primary node in a MongoDB replica set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the role of the primary node in a MongoDB replica set?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004505	How do secondary nodes differ from primary nodes in a MongoDB replica set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'How do secondary nodes differ from primary nodes in a MongoDB replica set?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004506	What is the purpose of having nodes with different priorities in a MongoDB replica set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the purpose of having nodes with different priorities in a MongoDB replica set?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004507	How does MongoDB ensure data consistency across all nodes in a replica set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'How does MongoDB ensure data consistency across all nodes in a replica set?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004508	What is the difference between strong consistency and eventual consistency in MongoDB replication?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the difference between strong consistency and eventual consistency in MongoDB replication?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004509	Can you explain how MongoDB handles write operations during replication?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Can you explain how MongoDB handles write operations during replication?'  
C002100045	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	MongoDB permite la replicación de datos mediante los denominados conjuntos de réplicas o replica sets. Un replica set engloba un conjunto de nodos que almacenan réplicas de unos mismos datos. Por tanto, en MongoDB los nodos que replican los mismos datos se denominan replica set. En MongoDB, los conjuntos de réplicas se gestionan de acuerdo con una estrategia master-slave asíncrona. Por tanto, los miembros de un conjunto de réplicas pueden ser de dos tipos: • Nodoprimario: solo hay un nodo primario, y es el que recibe operaciones de lectura y escritura. Las operaciones de escritura se replican de forma asíncrona a los nodos secundarios. • Nodossecundarios: nodos que solo permiten operaciones de lectura. Los nodos secundarios pueden tener configuraciones adicionales, como por ejemplo prioridades de escritura o privilegios de lectura. Cuando el nodo primario cae, se escoge un nuevo nodo primario entre los nodos secundarios del conjunto de réplicas. Es posible tener nodos de tipo árbitro, que participen en las elecciones de los nuevos nodos primarios pero que no almacenen datos. Para condicionar la elección, quien diseña la base de datos puede establecer distintas prioridades para cada nodo. En caso contrario, el nodo que tiene las escrituras más recientes se elige como primario para minimizar la pérdida de datos en el peor de los casos. La replicación sigue una estrategia master-slave. Los cambios se efectúan contra la réplica primaria (que está en el nodo master) y se transfieren de forma asíncrona a las réplicas secundarias (que están en los nodos slave). La consistencia puede ser fuerte (strong consistency) o final en el tiempo (eventual consistency), en función de si las consultas se efectúan siempre contra la copia primaria o si se permite realizar consultas en las réplicas secundarias.	C00210004510	In what situations might it be beneficial to use an arbitrator node in a MongoDB replica set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'In what situations might it be beneficial to use an arbitrator node in a MongoDB replica set?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004601	What is the main idea of the fifth point in the introduction to MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the main idea of the fifth point in the introduction to MongoDB?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004602	According to the passage, what does strong consistency guarantee in a database?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'According to the passage, what does strong consistency guarantee in a database?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004603	How does eventual consistency differ from strong consistency in a database, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'How does eventual consistency differ from strong consistency in a database, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004604	What is the consequence of providing eventual consistency in a database, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the consequence of providing eventual consistency in a database, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004605	Can the inconsistencies in values between replicas be visible to applications and users, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Can the inconsistencies in values between replicas be visible to applications and users, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004606	Is it possible for all replicas to have the same values physically in the database, but not necessarily under the same point of view, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Is it possible for all replicas to have the same values physically in the database, but not necessarily under the same point of view, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004607	What is the relationship between strong consistency and eventual consistency in a database, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'What is the relationship between strong consistency and eventual consistency in a database, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004608	How do the values of different replicas compare to each other when using eventual consistency, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'How do the values of different replicas compare to each other when using eventual consistency, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004609	Can the application or user obtain consistent values across all replicas when using eventual consistency, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Can the application or user obtain consistent values across all replicas when using eventual consistency, according to the passage?'  
C002100046	Introduccion a MongoDB	5.1. Replicación de datos	synthetic_question	Hay que recordar que la strongconsistency garantiza que las aplicaciones (y en consecuencia las personas usuarias) tengan una visión consistente de la base de datos (bajo su punto de vista, todas las réplicas tienen los mismos valores aunque físicamente, en la base de datos, esto no sea así). Por su parte, cuando se provee eventualconsistency, la falta de concordancia en los valores de unas mismas réplicas puede ser visible para las aplicaciones y las personas usuarias (es decir, las personas usuarias pueden obtener valores inconsistentes).	C00210004610	Does the passage suggest that eventual consistency is suitable for certain use cases where strong consistency is not feasible, such as in high availability systems?	passage: document 'Introduccion a MongoDB'; paragraph: '5.1. Replicación de datos'; content: 'Does the passage suggest that eventual consistency is suitable for certain use cases where strong consistency is not feasible, such as in high availability systems?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004701	What are the two main stages of data synchronization in a Replica Set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'What are the two main stages of data synchronization in a Replica Set?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004702	When should a new node be added to an existing Replica Set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'When should a new node be added to an existing Replica Set?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004703	How does MongoDB manage conflicts when multiple nodes have different versions of the same data?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'How does MongoDB manage conflicts when multiple nodes have different versions of the same data?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004704	What is the purpose of the initial sync process in a Replica Set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'What is the purpose of the initial sync process in a Replica Set?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004705	How often do secondary nodes in a Replica Set synchronize their data with the primary node?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'How often do secondary nodes in a Replica Set synchronize their data with the primary node?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004706	Can a node be promoted to primary status if it has been offline for too long?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'Can a node be promoted to primary status if it has been offline for too long?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004707	What happens if a node detects corrupted data during the initial sync process?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'What happens if a node detects corrupted data during the initial sync process?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004708	Is there a default policy for managing replicas in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'Is there a default policy for managing replicas in MongoDB?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004709	Can operations be performed only on the primary copy of the data in a Replica Set?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'Can operations be performed only on the primary copy of the data in a Replica Set?'  
C002100047	Introduccion a MongoDB	5.2. Sincronización de datos entre réplicas	synthetic_question	Hay dos etapas principales para sincronizar un nodo en un replica set: • Una sincronización inicial en la que todos los datos se copian a través de la red, y los datos y los índices se reconstruyen desde cero en el nodo de destino. • Procesamiento de un registro de operaciones incrementales, donde un lote de actualizaciones ya realizadas en el nodo primario se aplica a los datos en un nodo secundario. La sincronización inicial, initial sync, es un proceso que consume muchos recursos, tanto respecto a la red como a la capacidad de procesamiento y almacenamiento. Por ello, esta etapa solo debería suceder cuando: Se agrega un nuevo nodo a un conjunto de réplicas existente. • Un nodo ha estado fuera de línea demasiado tiempo. • Se detecta algún dato corrupto en un nodo, lo que significa que ya no se puede confiar en sus datos. A modo de resumen, recordad que, por defecto, las réplicas en MongoDB siguen una política de gestión de réplicas master-slave asíncrona, donde: Existe un solo maestro (o réplica primaria) por cada replica set. • Las operaciones de lectura y escritura se realizan solo sobre la copia primaria. • Los datos de las copias (o réplicas) secundarias se sincronizan a partir de las operaciones realizadas en la copia primaria de forma asíncrona. • En caso de que el nodo que almacena la copia primaria caiga, se promociona una copia secundaria como nueva copia primaria. • Opcionalmente, pueden añadirse nodos de tipo árbitro a un replica set. Estos árbitros permitirán desempatar las votaciones que puedan surgir al escoger nuevas copias primarias. Se pueden definir prioridades sobre las distintas copias secundarias para incrementar (o decrementar) su probabilidad de ser escogidas como nodo primario.	C00210004710	Are secondary nodes in a Replica Set allowed to perform write operations?	passage: document 'Introduccion a MongoDB'; paragraph: '5.2. Sincronización de datos entre réplicas'; content: 'Are secondary nodes in a Replica Set allowed to perform write operations?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004801	What type of replica management does MongoDB offer?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'What type of replica management does MongoDB offer?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004802	What is the basis for MongoDB's replica management?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'What is the basis for MongoDB's replica management?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004803	Can you describe the peculiarities of MongoDB's replica management?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'Can you describe the peculiarities of MongoDB's replica management?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004804	How do cuórums play a role in MongoDB's replica management?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'How do cuórums play a role in MongoDB's replica management?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004805	What is the purpose of replica management in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'What is the purpose of replica management in MongoDB?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004806	How does MongoDB's replica management differ from other databases?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'How does MongoDB's replica management differ from other databases?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004807	"Can you explain the concept of ""cuórum"" in the context of MongoDB's replica management?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'Can you explain the concept of ""cuórum"" in the context of MongoDB's replica management?'  "
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004808	"What is the significance of ""cueros"" in MongoDB's replica management?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'What is the significance of ""cueros"" in MongoDB's replica management?'  "
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004809	How does MongoDB ensure data consistency across all replicas?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'How does MongoDB ensure data consistency across all replicas?'  
C002100048	Introduccion a MongoDB	5.3. Gestión de réplicas	synthetic_question	MongoDB ofrece una gestión de réplicas basada en cuórums con ciertas peculiaridades, que se describen a continuación.	C00210004810	Can you discuss the advantages of using MongoDB's replica management feature?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3. Gestión de réplicas'; content: 'Can you discuss the advantages of using MongoDB's replica management feature?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004901	What is the purpose of the write concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'What is the purpose of the write concern in MongoDB?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004902	How many replicas should be updated according to the write concern?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'How many replicas should be updated according to the write concern?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004903	Is it mandatory to have written the data to disk before accepting the operation?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'Is it mandatory to have written the data to disk before accepting the operation?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004904	What is the default value of the write concern?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'What is the default value of the write concern?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004905	Can the write concern be set to require confirmation from multiple nodes?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'Can the write concern be set to require confirmation from multiple nodes?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004906	What is the difference between write concern {w:0} and {w:1}?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'What is the difference between write concern {w:0} and {w:1}?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004907	How does the write concern affect the time needed to accept transactions?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'How does the write concern affect the time needed to accept transactions?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004908	What happens if the write concern timeout is exceeded?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'What happens if the write concern timeout is exceeded?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004909	Does the write concern require the node to receive and execute the operation before accepting it?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'Does the write concern require the node to receive and execute the operation before accepting it?'  
C002100049	Introduccion a MongoDB	5.3.1. Write concern	synthetic_question	El cometido de escritura, o write concern, permite indicar el número de réplicas que deben actualizarse en una operación de modificación para que dicha operación se dé por buena. Este parámetro también permite indicar si es obligatorio haber escrito los datos en disco antes de aceptar la operación. Es el equivalente al parámetro W de la gestión de réplicas mediante cuórums. Hay que tener en cuenta que, cuanto mayor sea el write concern, mayor será el tiempo necesario para aceptar las transacciones de escritura, puesto que será necesario esperar la confirmación de un mayor número de nodos. Para indicar el valor W de write concern se pueden usar distintos valores: { w:0 }: no se espera confirmación. Es suficiente con haber conectado con el nodo primario y haberle enviado la petición de escritura. En este caso, se lanza la modificación y no se espera a saber si se ha ejecutado correctamente. Es un método rápido pero inseguro. { w:1 }: se espera únicamente la confirmación del nodo primario. Es el valor por defecto. { w:2 }: se espera la confirmación del nodo primario y de uno de los secundarios. majority: se espera la confirmación de una mayoría simple de nodos dentro del conjunto de réplicas. Existen también dos opciones involucradas en el mecanismo de cometido de escritura: j <true|false>: requiere que el nodo reciba la operación y la escriba en el fichero de transacciones antes de poder aceptar la transacción. • Wtimeout <int>: permite especificar un límite de tiempo para evitar que las operaciones de escritura se bloqueen indefinidamente. En caso de superar el tiempo indicado, se rechazará la transacción y se desharán los cambios que hayan podido realizar.	C00210004910	Can the write concern be disabled?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.1. Write concern'; content: 'Can the write concern be disabled?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005001	What is the purpose of the read concern mechanism in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'What is the purpose of the read concern mechanism in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005002	How does the read concern mechanism differ from the write concern mechanism in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'How does the read concern mechanism differ from the write concern mechanism in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005003	What are the four modalities of read concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'What are the four modalities of read concern in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005004	What is the default level of read concern in MongoDB operations against the primary node?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'What is the default level of read concern in MongoDB operations against the primary node?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005005	Can read concerns be applied to operations performed against secondary nodes in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Can read concerns be applied to operations performed against secondary nodes in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005006	When would a document not appear in an operation of reading in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'When would a document not appear in an operation of reading in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005007	Is it guaranteed that a document will be consistent across all members of the cluster when using read concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Is it guaranteed that a document will be consistent across all members of the cluster when using read concern in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005008	In what cases may a document obtained through read concern not be consistent in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'In what cases may a document obtained through read concern not be consistent in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005009	How does the availability of a document affect the read concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'How does the availability of a document affect the read concern in MongoDB?'  
C002100050	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	Se puede considerar el cometido de lectura, read concern, como el concepto complementario a write concern, pero para las operaciones de lectura. Es un mecanismo que aumenta las garantías de que los datos leídos por la aplicación son fiables y están actualizados. Sería un parámetro equivalente al parámetro R de la gestión de réplicas mediante cuórums. El parámetro read concern permite obtener ciertas garantías de que el dato que se está leyendo es consistente. Cuando se utiliza, únicamente devolverá datos cuya grabación haya sido confirmada por el número de nodos especificados en sus opciones. Se puede escoger entre devolver el dato más reciente que exista en el clúster, o el dato recibido por una mayoría de miembros en el clúster. El hecho de que un documento no «aparezca» en una operación de lectura no quiere decir necesariamente que se haya perdido, sino que, en el momento de su lectura, no se han cumplido las condiciones necesarias de consistencia para que haya sido devuelto. Podría ser que la lectura se produzca antes de que el dato haya sido propagado al número mínimo de miembros necesario. En este caso, el dato estaría disponible en lecturas sucesivas. Existen cuatro modalidades de read concern: • local: devuelve el dato más reciente en el clúster. Cualquier dato que haya sido escrito en el nodo primario puede ser elegido para devolverse en el read concern local. Sin embargo, no se garantiza que este dato sea replicado a los miembros del conjunto en caso de fallo. Este es el nivel por defecto en las operaciones de lectura contra el nodo primario. available: es el equivalente de local, pero cuando las operaciones de lectura se efectúan contra un nodo secundario. • majority: devuelve datos únicamente en el caso de que hayan sido confirmados en una mayoría de nodos dentro del conjunto. El único escenario en el que un dato obtenido con majority no sea consistente es cuando se produce un fallo en una mayoría de nodos del conjunto y ese dato no ha sido escrito a ninguno de los nodos restantes.	C00210005010	Can read concerns be used to ensure that data is consistent across multiple nodes in a MongoDB cluster?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Can read concerns be used to ensure that data is consistent across multiple nodes in a MongoDB cluster?'  
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005101	"What is the main purpose of the ""linearizable"" option in MongoDB?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'What is the main purpose of the ""linearizable"" option in MongoDB?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005102	"How does the ""linearizable"" option in MongoDB ensure data consistency?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'How does the ""linearizable"" option in MongoDB ensure data consistency?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005103	"Can you describe the majority voting mechanism used by MongoDB's ""linearizable"" option?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Can you describe the majority voting mechanism used by MongoDB's ""linearizable"" option?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005104	"How do developers establish their own functionality using MongoDB's ""linearizable"" option?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'How do developers establish their own functionality using MongoDB's ""linearizable"" option?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005105	"Is the ""linearizable"" option available only in certain versions of MongoDB?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Is the ""linearizable"" option available only in certain versions of MongoDB?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005106	"Can you explain the difference between ""linearizable"" and ""strong"" consistency models in MongoDB?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Can you explain the difference between ""linearizable"" and ""strong"" consistency models in MongoDB?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005107	"When would you choose to use the ""linearizable"" option over the ""strong"" consistency model in MongoDB?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'When would you choose to use the ""linearizable"" option over the ""strong"" consistency model in MongoDB?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005108	"Are there any performance trade-offs associated with using the ""linearizable"" option in MongoDB?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Are there any performance trade-offs associated with using the ""linearizable"" option in MongoDB?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005109	"Can you provide an example scenario where the ""linearizable"" option might be more appropriate than the ""strong"" consistency model in MongoDB?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'Can you provide an example scenario where the ""linearizable"" option might be more appropriate than the ""strong"" consistency model in MongoDB?'  "
C002100051	Introduccion a MongoDB	5.3.2. Read concern	synthetic_question	• linearizable: devuelve datos que hayan sido confirmados por una mayoría de nodos, permitiendo a la persona desarrolladora establecer su propia funcionalidad.	C00210005110	"How does the ""linearizable"" option impact the scalability of MongoDB applications?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.2. Read concern'; content: 'How does the ""linearizable"" option impact the scalability of MongoDB applications?'  "
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005201	What is the purpose of the preferencia de lectura mechanism in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the purpose of the preferencia de lectura mechanism in MongoDB?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005202	How does the preferencia de lectura mechanism work by default in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'How does the preferencia de lectura mechanism work by default in MongoDB?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005203	What are the five modes of preferencia de lectura available in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What are the five modes of preferencia de lectura available in MongoDB?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005204	In which mode does MongoDB perform all reads by default?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'In which mode does MongoDB perform all reads by default?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005205	What is the difference between primaryPreferred and secondaryPreferred modes of preferencia de lectura?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the difference between primaryPreferred and secondaryPreferred modes of preferencia de lectura?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005206	When would you use secondaryPreferred mode instead of primaryPreferred mode?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'When would you use secondaryPreferred mode instead of primaryPreferred mode?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005207	What is the nearest mode of preferencia de lectura and how does it work?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the nearest mode of preferencia de lectura and how does it work?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005208	"Can you explain the concept of ""obsolete"" data in the context of MongoDB's preferencia de lectura?"	"passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'Can you explain the concept of ""obsolete"" data in the context of MongoDB's preferencia de lectura?'  "
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005209	How do the parameters write concern, read concern, and read preference help in adjusting the behavior of the database?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'How do the parameters write concern, read concern, and read preference help in adjusting the behavior of the database?'  
C002100052	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	Se pueden aplicar distintos niveles de lectura al leer datos de conjuntos de réplicas. La preferencia de lectura es un mecanismo que permite enrutar las operaciones de lectura hasta los nodos secundarios. Es una opción principalmente del driver que conecta con la base de datos, por lo que se debe consultar la documentación del mismo para conocer el modo de utilizarlo. Por defecto, en un conjunto replicado, las operaciones de lectura/escritura se efectúan sobre el nodo primario. Con la preferencia de lectura se puede obligar a obtener los datos de un nodo secundario. Existen cinco modos distintos de preferencia de lectura: primary: enruta todas las operaciones de lectura al nodo primario, únicamente. • primaryPreferred: enruta las operaciones de lectura al nodo primario, pero si el nodo primario no está disponible, la aplicación puede redirigir la lectura a un nodo secundario. secondary: enruta todas las operaciones de lectura únicamente a los nodos secundarios. secondaryPreferred: enruta todas las operaciones de lectura a los nodos secundarios, pero en caso de no haber ninguno disponible, las enruta al nodo primario. • nearest: enruta las operaciones de lectura al nodo potencialmente más cercano, es decir, el nodo con una menor latencia, independientemente de que sea primario o secundario. Esto permite el soporte de operaciones de lectura geográficamente locales. Siempre que se obtengan datos de nodos secundarios puede darse la circunstancia de que las operaciones de lectura reciban datos obsoletos. Los parámetros write concern, read concern y read preference permiten múltiples combinaciones que dan flexibilidad y permiten ajustar el comportamiento de la base de datos a distintas necesidades. Algunas de sus configuraciones podrían ser: • Maximizarlaconsistencia: utilizar la preferencia de lectura primary con j = true y read concern majority para consultar solo datos actualizados.	C00210005210	What is the main advantage of using the preferencia de lectura mechanism in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the main advantage of using the preferencia de lectura mechanism in MongoDB?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005301	What is the main goal of configuring preference for reading in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the main goal of configuring preference for reading in MongoDB?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005302	According to the passage, what happens when there are reads to nodes that are only available as secondary nodes?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'According to the passage, what happens when there are reads to nodes that are only available as secondary nodes?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005303	How does using a primary preferred node maximize availability in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'How does using a primary preferred node maximize availability in MongoDB?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005304	What type of workloads should be executed on secondary nodes in MongoDB, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What type of workloads should be executed on secondary nodes in MongoDB, according to the passage?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005305	What is the purpose of regularizing workload tasks in MongoDB, as mentioned in the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the purpose of regularizing workload tasks in MongoDB, as mentioned in the passage?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005306	In which scenario might using a secondary node for certain workloads lead to potentially outdated results, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'In which scenario might using a secondary node for certain workloads lead to potentially outdated results, according to the passage?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005307	What is the difference between primary and secondary nodes in MongoDB, in terms of their ability to handle read operations?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the difference between primary and secondary nodes in MongoDB, in terms of their ability to handle read operations?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005308	Why might it be beneficial to use a more distant node for obtaining quick responses in MongoDB, according to the passage?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'Why might it be beneficial to use a more distant node for obtaining quick responses in MongoDB, according to the passage?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005309	How do the preferences for reading in MongoDB affect the availability and latency of read operations?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'How do the preferences for reading in MongoDB affect the availability and latency of read operations?'  
C002100053	Introduccion a MongoDB	5.3.3. Preferencia de lectura	synthetic_question	• Maximizarladisponibilidad: usar el nodo definido como primaryPreferred para obtener lecturas consistentes cuando hay lecturas a nodos primarios y potencialmente obsoletas cuando solo están disponibles los nodos secundarios. • Minimizarlalatencia: utilizar el nodo más cercano para obtener respuestas de lectura rápidas, pero con posibles resultados obsoletos. • Regularlascargasdetrabajo: usar el nodo secundario para cargas de trabajo especiales de alto impacto (como agregaciones sin índice) para que el primario nunca se sobrecargue.	C00210005310	What is the relationship between the primary and secondary nodes in MongoDB, in terms of handling read operations and maintaining consistent results?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.3. Preferencia de lectura'; content: 'What is the relationship between the primary and secondary nodes in MongoDB, in terms of handling read operations and maintaining consistent results?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005401	What is the main guarantee offered by MongoDB regarding data consistency?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is the main guarantee offered by MongoDB regarding data consistency?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005402	According to the paragraph, what type of consistency does MongoDB provide?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'According to the paragraph, what type of consistency does MongoDB provide?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005403	Can applications have a consistent view of the data even if some nodes are behind others in terms of data replication?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'Can applications have a consistent view of the data even if some nodes are behind others in terms of data replication?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005404	How does MongoDB ensure consistency between primary and secondary nodes?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'How does MongoDB ensure consistency between primary and secondary nodes?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005405	What is the relationship between writes and reads concerning consistency in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is the relationship between writes and reads concerning consistency in MongoDB?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005406	Can operations depend logically on previous operations in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'Can operations depend logically on previous operations in MongoDB?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005407	What is an example of a situation where causal consistency would be beneficial in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is an example of a situation where causal consistency would be beneficial in MongoDB?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005408	How can MongoDB achieve causal consistency according to the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'How can MongoDB achieve causal consistency according to the paragraph?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005409	Is eventual consistency mentioned in the paragraph as a possible consistency model in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'Is eventual consistency mentioned in the paragraph as a possible consistency model in MongoDB?'  
C002100054	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	Según la documentación de MongoDB, su uso con la configuración por defecto garantiza la consistencia estricta. Esto, desde un punto de vista teórico, no es del todo exacto. Realmente garantiza consistencia fuerte, es decir, las aplicaciones tienen siempre una visión consistente de los datos, aunque a escala física, mientras se propagan los cambios de la copia primaria a las secundarias no todas las réplicas de unos mismos datos contienen los mismos valores. Como se ha visto, MongoDB también permite que se realicen consultas directas sobre los nodos secundarios, siempre que se configure adecuadamente. Como la sincronización entre el nodo primario y los secundarios se realiza de forma asíncrona, realizar consultas sobre nodos secundarios puede implicar leer datos obsoletos y, por tanto, se rebajaría la consistencia a consistencia final en el tiempo (eventual consistency). Los valores de write y read concern pueden ajustarse para maximizar la disponibilidad o la consistencia de los datos en diferentes niveles. Si una operación depende lógicamente de una operación anterior, existe una relación causal entre las operaciones. Por ejemplo, una operación de escritura que elimina todos los documentos según una condición especificada y una operación de lectura posterior que verifica que la operación de eliminación haya funcionado correctamente. En este caso, es conveniente proveer consistencia causal, es decir, que un programa pueda acceder a los datos que previamente ha modificado. Este tipo de consistencia puede satisfacerse en MongoDB mediante el uso de sesiones causalmente consistentes, donde el sistema gestor de bases de datos ejecuta las operaciones en orden, respetando las relaciones causales y permitiendo que los clientes observen resultados consistentes desde su punto de vista.	C00210005410	What is the difference between strong consistency and eventual consistency in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is the difference between strong consistency and eventual consistency in MongoDB?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005501	What is the main purpose of maintaining consistency in a database system like MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is the main purpose of maintaining consistency in a database system like MongoDB?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005502	What type of consistence does MongoDB provide to ensure correctness of data?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What type of consistence does MongoDB provide to ensure correctness of data?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005503	How do operations in MongoDB execute to maintain consistency according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'How do operations in MongoDB execute to maintain consistency according to the given paragraph?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005504	What is the significance of setting read and write concerns in MongoDB to achieve strong consistency?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is the significance of setting read and write concerns in MongoDB to achieve strong consistency?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005505	Can you explain the difference between read and write concerns in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'Can you explain the difference between read and write concerns in MongoDB?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005506	In what situations might it be important to use majority write concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'In what situations might it be important to use majority write concern in MongoDB?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005507	How does MongoDB guarantee that operations are executed in the order established?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'How does MongoDB guarantee that operations are executed in the order established?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005508	What is the relationship between read and write concerns in ensuring consistency in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'What is the relationship between read and write concerns in ensuring consistency in MongoDB?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005509	Can you describe an example scenario where consistent reading and writing would be crucial in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'Can you describe an example scenario where consistent reading and writing would be crucial in MongoDB?'  
C002100055	Introduccion a MongoDB	5.3.4. Consistencia	synthetic_question	La consistencia causal debe garantizar que: • Las operaciones de lectura reflejen los resultados de las operaciones de escritura que las preceden. • Las operaciones de lectura no devuelvan resultados que correspondan a un estado anterior a los datos obtenidos en las lecturas previas. Las operaciones se ejecuten en el orden establecido. Esta consistencia causal solo se puede proveer si se mantienen ciertas configuraciones de write y read concern. Según MongoDB, para mantener este tipo de consistencia debe garantizarse que las operaciones de lectura van asociadas con un read concern igual a majority, y que las operaciones de escritura utilizan un write concern de tipo majority. Bajo esta configuración, se tendrá un sistema que garantiza consistencia fuerte y, en consecuencia, que ofrezca siempre valores válidos, satisfaciendo también la consistencia causal.	C00210005510	How does MongoDB's consistency model differ from other NoSQL databases or traditional relational databases?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.4. Consistencia'; content: 'How does MongoDB's consistency model differ from other NoSQL databases or traditional relational databases?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005601	What is the main cause of latency in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'What is the main cause of latency in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005602	Where do nodes normally reside in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'Where do nodes normally reside in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005603	What is the name of the log that stores proposed changes in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'What is the name of the log that stores proposed changes in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005604	How do nodes secure their data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'How do nodes secure their data in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005605	What is the default value of the write concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'What is the default value of the write concern in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005606	Can writings be confirmed only on the primary node in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'Can writings be confirmed only on the primary node in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005607	What happens if a primary node fails before propagating its changes?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'What happens if a primary node fails before propagating its changes?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005608	How does MongoDB handle conflicts when multiple nodes have different versions of the same data?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'How does MongoDB handle conflicts when multiple nodes have different versions of the same data?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005609	Is it possible to write data without specifying an explicit value for write concern in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'Is it possible to write data without specifying an explicit value for write concern in MongoDB?'  
C002100056	Introduccion a MongoDB	5.3.5. Latencia	synthetic_question	Debido a que los nodos normalmente residen en diferentes máquinas (y probablemente también en diferentes centros de datos), siempre habrá algún retraso en la replicación a medida que los datos del registrodeoperaciones, llamado oplog en MongoDB, se propaguen a través de la red a los nodos secundarios. Los nodos secundarios aplicarán los cambios propuestos por el registro de operaciones tan pronto como los reciban. El tiempo que va desde el momento en que se acepta una escritura en el nodo primario y se aplica dicho cambio en el nodo secundario se denomina retraso de replicación, y genera una ventana de inconsistencia en la que los nodos secundarios podrán servir valores obsoletos. Los nodos secundarios pueden obtener las actualizaciones de sus réplicas directamente desde el nodo primario o desde otro nodo secundario, lo que se denomina chained replication. Una aplicación puede optar por escribir ciertos datos sin indicar un valor explícito para write concern. MongoDB usa, de forma predeterminada, el valor de {w: 1} en el write concern. Por tanto, por defecto, todas las escrituras se confirman solo en el nodo primario y se propagan a los nodos secundarios de forma asíncrona. Si el primario falla antes de propagar sus cambios, es posible que la escritura se pierda temporalmente. Esta escritura se revertiría finalmente cuando el nodo se recuperase y se uniera de nuevo al conjunto de réplicas. En el mejor de los casos, el cambio se aplicaría cuando el nodo volviera a estar disponible. Pero en algunos casos, cuando haya habido nuevas escrituras sobre ese mismo dato durante el tiempo en que el nodo ha estado inactivo, su aplicación podría no ser directa. En estos casos se requerirá una intervención manual para solucionar el conflicto.	C00210005610	What is the purpose of chained replication in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.3.5. Latencia'; content: 'What is the purpose of chained replication in MongoDB?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005701	What is the strategy used by MongoDB for distributing data across multiple nodes?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'What is the strategy used by MongoDB for distributing data across multiple nodes?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005702	How does MongoDB perform fragmentation at the collection level?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'How does MongoDB perform fragmentation at the collection level?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005703	Can the distribution of data in MongoDB be customized according to specific fields or ranges of values?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'Can the distribution of data in MongoDB be customized according to specific fields or ranges of values?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005704	What is the default method used by MongoDB for distributed fragmentation?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'What is the default method used by MongoDB for distributed fragmentation?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005705	Is it possible to specify a custom fragmentation function in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'Is it possible to specify a custom fragmentation function in MongoDB?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005706	How do the distributed fragments in MongoDB communicate with each other?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'How do the distributed fragments in MongoDB communicate with each other?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005707	What is the difference between automatic fragmentation and manual fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'What is the difference between automatic fragmentation and manual fragmentation in MongoDB?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005708	Can fragmentation be performed on a per-collection basis or on a per-database basis in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'Can fragmentation be performed on a per-collection basis or on a per-database basis in MongoDB?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005709	Are there any performance benefits associated with using fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'Are there any performance benefits associated with using fragmentation in MongoDB?'  
C002100057	Introduccion a MongoDB	5.4. Fragmentación	synthetic_question	MongoDB utiliza una estrategia de fragmentación horizontal para distribuir los datos de la base de datos en distintos nodos. La fragmentación en MongoDB se realiza a nivel de colección. Para cada colección se debe informar de qué campo o conjunto de campos se tendrán en cuenta para distribuir los datos. Además, se deberá informar de cómo se debe realizar la distribución. Existen dos opciones: automáticamente mediante una función de hash o según un rango de valores predefinido que puedan tomar un conjunto de campos de la colección.	C00210005710	How does MongoDB handle fragmentation when performing write operations?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4. Fragmentación'; content: 'How does MongoDB handle fragmentation when performing write operations?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005801	What is the main purpose of configuring how data is distributed in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'What is the main purpose of configuring how data is distributed in MongoDB?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005802	How does MongoDB automatically distribute data among different nodes in a database?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'How does MongoDB automatically distribute data among different nodes in a database?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005803	What is the term used to describe the fields whose values determine where each document is stored in a collection?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'What is the term used to describe the fields whose values determine where each document is stored in a collection?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005804	Can you identify an example of a field that could be used as a shard key in a MongoDB collection?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'Can you identify an example of a field that could be used as a shard key in a MongoDB collection?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005805	How do you choose a suitable shard key for a MongoDB collection?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'How do you choose a suitable shard key for a MongoDB collection?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005806	What is the significance of selecting a well-suited shard key for efficient distribution of data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'What is the significance of selecting a well-suited shard key for efficient distribution of data in MongoDB?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005807	In what way does the choice of shard key affect the number of fragments, load balancing, and system performance in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'In what way does the choice of shard key affect the number of fragments, load balancing, and system performance in MongoDB?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005808	Why is it essential to include an index for each shard key in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'Why is it essential to include an index for each shard key in MongoDB?'  
C002100058	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	MongoDB permite distribuir los datos entre los distintos nodos de la base de datos de forma automática. Los datos que se utilizan para realizar esta distribución de datos y el modo en que se distribuyen deben ser configurados por quien administre la base de datos. En MongoDB, la fragmentación es una decisión de diseño que debe tomarse de acuerdo entre las personas desarrolladoras y las administradoras de la base de datos. Para cada colección, se debe: • Indicar el campo (o los campos) cuyos valores se utilizarán para distribuir los datos. Los campos utilizados para determinar en qué fragmento se distribuye cada documento se denominan clave de distribución o shard key. • Identificar cómo se distribuirán los datos (según el rango de los campos o mediante una función de hash). Cuando llega el momento de fragmentar colecciones, hay que elegir una clave de distribución, shard key, que contendrá los distintos campos que se utilizarán para distribuir los documentos de la colección en distintos fragmentos de forma disjunta. El espacio de valores de la clave de distribución se divide en distintos bloques, denominados chunks en MongoDB. Un chunk se define como el conjunto de valores de una clave de distribución que permite distribuir los documentos en un mismo fragmento. Por tanto, los documentos cuya clave de distribución pertenezcan al mismo chunk se almacenarán en el mismo fragmento. Debe existir un índice para cada clave de distribución. MongoDB lo creará en el caso de que no exista. La clave de distribución elegida puede tener un impacto importante en el número de fragmentos, en la distribución de carga entre los mismos y en la eficiencia del sistema en general. Por lo tanto, es importante escoger una clave de distribución que permita distribuir los documentos de forma equitativa entre los distintos fragmentos. Es importante también que la clave de distribución sea selectiva y que forme parte de las consultas previstas. Esto permitirá responder las preguntas consultando un solo nodo. Por ejemplo, suponed que, para una colección de clientes, se crea una clave de distribución por los primeros dos dígitos del campo codigo_postal (que indican la provincia). En tal caso, las consultas que obtuvieran datos de clientes por población, comarca o provincia se podrían resolver mediante consultas a un solo fragmento.	C00210005809	How does the selection of a shard key influence the query performance in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'How does the selection of a shard key influence the query performance in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005901	What is the purpose of defining a partition key in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'What is the purpose of defining a partition key in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005902	How does MongoDB automatically distribute data when a partition key is defined?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'How does MongoDB automatically distribute data when a partition key is defined?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005903	Can the fragmentation of documents in MongoDB be done manually or automatically?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'Can the fragmentation of documents in MongoDB be done manually or automatically?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005904	What is an example of a manual fragmentation method in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'What is an example of a manual fragmentation method in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005905	How do range values determine chunk sizes in automatic fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'How do range values determine chunk sizes in automatic fragmentation in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005906	Can you explain the difference between manual and automatic fragmentation methods in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'Can you explain the difference between manual and automatic fragmentation methods in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005907	When would you choose to use manual fragmentation over automatic fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'When would you choose to use manual fragmentation over automatic fragmentation in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005908	How does the choice of partition key affect the distribution of data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'How does the choice of partition key affect the distribution of data in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005909	What is the significance of the ranges used in automatic fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'What is the significance of the ranges used in automatic fragmentation in MongoDB?'  
C002100059	Introduccion a MongoDB	5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos	synthetic_question	Una vez definida la clave de partición para una colección se puede indicar cómo fragmentar sus documentos de forma manual, indicando los diferentes chunks y los rangos de valores que los determinan, o de forma automática, mediante una función de hash. A continuación se verá un ejemplo de cada caso.	C00210005910	Can you provide an example of how automatic fragmentation might work differently depending on the chosen partition key in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.1. Cómo definir qué fragmentos utilizar y cómo se distribuyen los datos'; content: 'Can you provide an example of how automatic fragmentation might work differently depending on the chosen partition key in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006001	What is the purpose of fragmentation in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'What is the purpose of fragmentation in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006002	How does MongoDB perform fragmentation?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'How does MongoDB perform fragmentation?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006003	What is the effect of fragmentation on query performance in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'What is the effect of fragmentation on query performance in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006004	Can you explain the concept of ranges in MongoDB fragmentation?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'Can you explain the concept of ranges in MongoDB fragmentation?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006005	How do chunk boundaries affect query performance in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'How do chunk boundaries affect query performance in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006006	In what cases might distributed but uneven distributions occur in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'In what cases might distributed but uneven distributions occur in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006007	How can uneven distributions impact query efficiency in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'How can uneven distributions impact query efficiency in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006008	Are there any advantages to using range-based queries in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'Are there any advantages to using range-based queries in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006009	Can you provide an example scenario where range-based queries would be beneficial in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'Can you provide an example scenario where range-based queries would be beneficial in MongoDB?'  
C002100060	Introduccion a MongoDB	Ejemplos	synthetic_question	En el primer caso, la fragmentación se realiza en función del valor de los atributos. Por tanto, se crea un conjunto de rangos en función de los posibles valores del campo x {(-∞, 75), [-75,25), [25,175), [175,∞)} . Cada uno de estos cuatro intervalos define un bloque de partición o chunk de datos. Como puede verse en la figura, los documentos con valores cercanos de la clave de partición caerán en el mismo chunk y, por tanto, acabarán en el mismo fragmento, mientras que los documentos con valores lejanos es probable que caigan en chunks distintos y, por lo tanto, acabarán en fragmentos distintos. Eso puede ser conveniente en algunos casos, porque permitirá agilizar las consultas por rangos o por valor, pero puede comportar distribuciones poco equilibradas o consultas ineficientes (consultas por rangos en función de otros campos) en otros casos.	C00210006010	How might uneven distribution affect the results of range-based queries in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Ejemplos'; content: 'How might uneven distribution affect the results of range-based queries in MongoDB?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006101	What was the previous limitation regarding modifying values in MongoDB's distribution key?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'What was the previous limitation regarding modifying values in MongoDB's distribution key?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006102	How does MongoDB distribute data when using a hash function?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'How does MongoDB distribute data when using a hash function?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006103	Can there be performance issues in MongoDB due to sequential or range queries?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'Can there be performance issues in MongoDB due to sequential or range queries?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006104	Why is it important to study MongoDB's documentation carefully for proper data distribution and load management?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'Why is it important to study MongoDB's documentation carefully for proper data distribution and load management?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006105	Are there different options available in MongoDB for controlling data distribution processes?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'Are there different options available in MongoDB for controlling data distribution processes?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006106	According to the passage, what is one potential issue with distributing data using a hash function in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'According to the passage, what is one potential issue with distributing data using a hash function in MongoDB?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006107	In which case might there be a more even distribution of data between nodes in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'In which case might there be a more even distribution of data between nodes in MongoDB?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006108	How does the choice of field affect the distribution of data in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'How does the choice of field affect the distribution of data in MongoDB?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006109	Is there any mention in the passage of specific tools or features in MongoDB that can help with data distribution and load management?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'Is there any mention in the passage of specific tools or features in MongoDB that can help with data distribution and load management?'  
C002100061	Introduccion a MongoDB	Clave de distribución	synthetic_question	En versiones anteriores a la 4.2, MongoDB no permitía modificar los valores de la clave de distribución. Fuente: elaboración propia En un segundo caso se puede ver la distribución de datos mediante una función de hash. En este caso, documentos con valores cercanos del campo a utilizar se asignan, potencialmente, en distintos nodos, consiguiendo, en el caso general, un reparto más equilibrado de los datos entre los distintos nodos. A pesar de ello, podrían existir problemas de rendimiento en algunos casos en los que hubieran muchas consultas secuenciales o por rango. Fuente: elaboración propia En el caso de utilizar MongoDB, es importante estudiar atentamente sus manuales para hacer una buena distribución de datos y mantener una carga de datos adecuada. Hay distintas opciones para controlar dichos procesos en MongoDB, pero explicarlos en detalle queda fuera del alcance de este módulo.	C00210006110	What is the main idea behind the last sentence of the passage regarding studying MongoDB's documentation carefully for proper data distribution and load management?	passage: document 'Introduccion a MongoDB'; paragraph: 'Clave de distribución'; content: 'What is the main idea behind the last sentence of the passage regarding studying MongoDB's documentation carefully for proper data distribution and load management?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006201	What is the main purpose of MongoDB's fragmentation architecture, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'What is the main purpose of MongoDB's fragmentation architecture, according to the given paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006202	How does MongoDB distribute data across different nodes in a cluster, as described in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'How does MongoDB distribute data across different nodes in a cluster, as described in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006203	What is the function of Mongos in the MongoDB fragmentation architecture, as mentioned in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'What is the function of Mongos in the MongoDB fragmentation architecture, as mentioned in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006204	Why is it recommended to deploy multiple routers in a MongoDB cluster, as stated in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'Why is it recommended to deploy multiple routers in a MongoDB cluster, as stated in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006205	According to the paragraph, what is the minimum number of elements required to create a production-ready MongoDB cluster?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'According to the paragraph, what is the minimum number of elements required to create a production-ready MongoDB cluster?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006206	Can you identify the three types of components that make up a MongoDB cluster, as listed in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'Can you identify the three types of components that make up a MongoDB cluster, as listed in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006207	What is the purpose of Config Servers in a MongoDB cluster, as explained in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'What is the purpose of Config Servers in a MongoDB cluster, as explained in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006208	How do Shards contribute to the overall functionality of a MongoDB cluster, as described in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'How do Shards contribute to the overall functionality of a MongoDB cluster, as described in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006209	In a MongoDB cluster, how do Enroutors facilitate the distribution of queries, as mentioned in the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'In a MongoDB cluster, how do Enroutors facilitate the distribution of queries, as mentioned in the paragraph?'  
C002100062	Introduccion a MongoDB	5.4.2. Arquitectura de fragmentación	synthetic_question	En la figura 9 se pueden ver los distintos componentes que utiliza MongoDB para gestionar la fragmentación de datos. Fuente: MongoDB Un clúster fragmentado de MongoDB consta de los siguientes componentes: • Los datos de la base de datos se distribuyen en shards o fragmentos que se pueden distribuir en distintos nodos. Cada fragmento contiene un subconjunto de los datos. A partir de MongoDB 3.6, los fragmentos deben implementarse en el contexto de un replica set. • Mongos actúa como un enrutador de consultas, proporcionando una interfaz entre las aplicaciones cliente y el clúster fragmentado. Se recomienda desplegar distintos enrutadores para reducir la latencia de red. • Los servidores de configuración, config servers, almacenan metadatos y ajustes de configuración para el clúster. Su información permite que los enrutadores puedan identificar en qué nodo está la información requerida y, en consecuencia, son necesarios para que las consultas se puedan distribuir eficientemente entre los distintos nodos de la base de datos. Con el fin de asegurar que los datos sean redundantes y que el sistema tenga una alta disponibilidad en entornos de producción, MongoDB propone crear clústeres que contengan, como mínimo, los siguientes elementos: • Implementar los Config Servers como un conjunto de réplicas de tres miembros. Implementar cada Shard como un conjunto de réplicas de tres miembros. Implementar uno o más enrutadores mongos. Fuente: elaboración propia	C00210006210	What is the significance of redundant data in a MongoDB cluster, as mentioned in the final sentence of the paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.2. Arquitectura de fragmentación'; content: 'What is the significance of redundant data in a MongoDB cluster, as mentioned in the final sentence of the paragraph?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006301	What is the main topic discussed in this paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'What is the main topic discussed in this paragraph?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006302	According to the passage, what is the difference between fragmented and non-fragmented collections in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'According to the passage, what is the difference between fragmented and non-fragmented collections in MongoDB?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006303	Where are the fragments stored in a MongoDB database?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'Where are the fragments stored in a MongoDB database?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006304	Can operations be performed directly on a single fragment in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'Can operations be performed directly on a single fragment in MongoDB?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006305	How does the policy management system work in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'How does the policy management system work in MongoDB?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006306	Who has access to the data in a MongoDB fragment?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'Who has access to the data in a MongoDB fragment?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006307	Are there any restrictions on who can use local user accounts in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'Are there any restrictions on who can use local user accounts in MongoDB?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006308	Can users connect to multiple fragments in a MongoDB database?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'Can users connect to multiple fragments in a MongoDB database?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006309	Is it possible to perform administrative tasks and maintenance activities only locally within a fragment in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'Is it possible to perform administrative tasks and maintenance activities only locally within a fragment in MongoDB?'  
C002100063	Introduccion a MongoDB	5.4.3. Gestión y acceso a los distintos fragmentos	synthetic_question	En MongoDB, pueden coexistir colecciones fragmentadas y colecciones no fragmentadas en la misma base de datos. Las colecciones fragmentadas se particionan y distribuyen entre distintos conjuntos de réplicas, como se ha visto anteriormente. Las colecciones sin fragmentar se almacenan en un fragmento principal. Cada base de datos tiene su propio fragmento principal, como se puede ver en la figura 11. Las operaciones en la base de datos deben realizarse mediante una conexión a un enrutador (mongos). Se pueden realizar conexiones directamente a un fragmento, pero solo para realizar operaciones locales administrativas y de mantenimiento. Realizar consultas en un solo fragmento devolvería solo los datos disponibles en ese fragmento y, por lo tanto, no podrían ofrecer una visión completa de la base de datos. El control de acceso a la base de datos y a sus fragmentos se realiza mediante una política de gestión de usuarios basada en roles. Eso permite restringir el acceso no autorizado a distintas operaciones, datos, fragmentos y datos de fragmentos. Por otro lado, cada fragmento puede tener sus propios usuarios locales que, al ser locales, no pueden usarse en otros fragmentos ni para conectarse a otro clúster a través de un enrutador.	C00210006310	What is the purpose of an enroute (mongos) in MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.3. Gestión y acceso a los distintos fragmentos'; content: 'What is the purpose of an enroute (mongos) in MongoDB?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006401	What is the main purpose of Mongos according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'What is the main purpose of Mongos according to the given paragraph?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006402	How does Mongos determine which fragments contain the data of interest?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'How does Mongos determine which fragments contain the data of interest?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006403	What is the role of the enroute feature in Mongos, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'What is the role of the enroute feature in Mongos, according to the given paragraph?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006404	Can you describe how Mongos distributes operations across multiple fragments?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'Can you describe how Mongos distributes operations across multiple fragments?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006405	What is the significance of the shared key or prefix in the query, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'What is the significance of the shared key or prefix in the query, according to the given paragraph?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006406	How does Mongos handle queries that do not specify a fragment or a range of fragments?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'How does Mongos handle queries that do not specify a fragment or a range of fragments?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006407	What is the output of the sh.status() method in an instance of Mongos, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'What is the output of the sh.status() method in an instance of Mongos, according to the given paragraph?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006408	In what way does the distribution of chunks among fragments contribute to the overall performance of the system, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'In what way does the distribution of chunks among fragments contribute to the overall performance of the system, according to the given paragraph?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006409	Can you explain how Mongos ensures that each fragment contains only a subset of the data, rather than all of the data, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'Can you explain how Mongos ensures that each fragment contains only a subset of the data, rather than all of the data, according to the given paragraph?'  
C002100064	Introduccion a MongoDB	5.4.4. Enrutador	synthetic_question	Mongos proporciona una única interfaz para un clúster fragmentado desde la perspectiva de las aplicaciones. El enrutador utiliza los metadatos de los servidores de configuración para rastrear qué datos están en cada fragmento y enrutar las operaciones desde las aplicaciones de cliente a las instancias mongos. Una instancia de mongos enruta una consulta a un clúster realizando las siguientes acciones: • Determina la lista de fragmentos que deben recibir la consulta. Establece un cursor en todos los fragmentos objetivo. • Al final de la operación, fusiona los datos provenientes de cada uno de los fragmentos y devuelve a la aplicación el resultado. Ciertos modificadores de consulta, como por ejemplo la ordenación, pueden realizarse localmente en cada fragmento antes de que mongos recupere e integre los resultados. Cuando la shared key o un prefijo de esta clave forma parte de la consulta, mongos es capaz de detectar en qué fragmentos se encuentran los datos y enviar las consultas al subconjunto de fragmentos que contienen los datos de interés. En caso de que no sea así y no pueda determinarse en qué fragmento se encuentran los datos de interés, mongos distribuye la operación a todos los fragmentos del clúster. Por ejemplo, si la clave del fragmento es {postal_code: 1, city_name: 1, neighborhood_name: 1}, mongos sería capaz de detectar los fragmentos que contienen los datos de interés para una consulta, siempre que la consulta realizase una búsqueda en función del código postal, el código postal y la población, o el código postal, la población y el nombre del barrio. En caso de que la búsqueda fuera por nombre de cliente, no sería posible saber en qué fragmento se encuentra el documento (o los documentos) de interés. 8 en una instancia de mongos se Cuando se ejecuta el método sh.status() muestra un informe referente a la configuración de fragmentación y los fragmentos existentes. Este informe incluye cuál es el fragmento principal para la base de datos y la distribución de chunks entre los fragmentos.	C00210006410	How does the use of Mongos improve the scalability of the system, compared to using a single server for the entire database, according to the given paragraph?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.4. Enrutador'; content: 'How does the use of Mongos improve the scalability of the system, compared to using a single server for the entire database, according to the given paragraph?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006501	What type of metadata do servers store configuration?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'What type of metadata do servers store configuration?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006502	How often does MongoDB update cache when there are changes to metadata?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'How often does MongoDB update cache when there are changes to metadata?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006503	Can fragments also access metadata about chunks stored on servers?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Can fragments also access metadata about chunks stored on servers?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006504	What is an example of configuration information stored on servers?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'What is an example of configuration information stored on servers?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006505	Must each cluster have its own set of server configurations?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Must each cluster have its own set of server configurations?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006506	Where can you find more information about authentication methods supported by MongoDB?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Where can you find more information about authentication methods supported by MongoDB?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006507	Are there any restrictions on who can access metadata stored on servers?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Are there any restrictions on who can access metadata stored on servers?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006508	How does MongoDB ensure data consistency across all fragments within a cluster?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'How does MongoDB ensure data consistency across all fragments within a cluster?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006509	Can you use the sh.status method to retrieve metadata from servers?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Can you use the sh.status method to retrieve metadata from servers?'  
C002100065	Introduccion a MongoDB	5.4.5. Servidores de configuración	synthetic_question	Los servidores de configuración almacenan los metadatos de un clúster fragmentado. Los metadatos reflejan el estado y la organización de todos los datos y componentes dentro del clúster. Los metadatos incluyen la lista de chunks en cada fragmento y los rangos que los definen. Las instancias de mongos almacenan en caché estos datos y los utilizan para enrutar operaciones de lectura y escritura a los fragmentos correctos. Mongos actualiza la caché cuando hay cambios de metadatos para el clúster, como una nueva partición de chunks o la agregación de un nuevo fragmento. Los fragmentos también leen los metadatos referentes a los chunks de los servidores de configuración. Los servidores de configuración también almacenan información de configuración de autenticación, como el control de acceso basado en roles o la configuración de autenticación interna para el clúster. Cada clúster debe tener sus propios servidores de configuración. (8)Ver <https:// docs.mongodb.com/manual/ reference/method/sh.status/>.	C00210006510	Is it possible to configure authentication settings for specific roles or internal authentication within a cluster?	passage: document 'Introduccion a MongoDB'; paragraph: '5.4.5. Servidores de configuración'; content: 'Is it possible to configure authentication settings for specific roles or internal authentication within a cluster?'  
